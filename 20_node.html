<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Node.js :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="css/ejs.css"><script>
      var page = {"type":"chapter","number":20}</script></head>

<body><article>
<nav><a href="19_paint.html" title="previous chapter" aria-label="previous chapter">◂</a>&nbsp;<a href="index.html" title="cover" aria-label="cover">●</a>&nbsp;<a href="21_skillsharing.html" title="next chapter" aria-label="next chapter">▸</a>&nbsp;<button class="help" title="help" aria-label="help"><strong>?</strong></button>
</nav>

<h1>Node.js</h1>

<blockquote>

<p><a class="p_ident" id="p-+0XsOMiWpx" href="#p-+0XsOMiWpx" tabindex="-1" role="presentation"></a>Un estudiante preguntó, ‘Los programadores del pasado solo usaban máquinas simples y ningún lenguaje de programación, sin embargo, creaban programas hermosos. ¿Por qué nosotros usamos máquinas complicadas y lenguajes de programación?’. Fu-Tzu respondió, ‘Los constructores del pasado solo usaban palos y barro, sin embargo, creaban hermosas chozas.’</p>

<footer>Maestro Yuan-Ma, <cite>El Libro de la Programación</cite></footer>

</blockquote><figure class="chapter framed"><img src="images/chapter_picture_20.jpg" alt="Ilustración mostrando un poste telefónico con un enredo de cables yendo en todas direcciones"></figure>

<p><a class="p_ident" id="p-Pc2oOBWZBP" href="#p-Pc2oOBWZBP" tabindex="-1" role="presentation"></a>Hasta ahora, hemos usado el lenguaje JavaScript en un solo entorno: el navegador. Este capítulo y el <a href="21_skillsharing.html">siguiente</a> introducirán brevemente Node.js, un programa que te permite aplicar tus habilidades JavaScript fuera del navegador. Con él, puedes construir desde pequeñas herramientas de línea de comandos hasta servidores HTTP que alimentan sitios web dinámicos.</p>

<p><a class="p_ident" id="p-0DDXh+YCUB" href="#p-0DDXh+YCUB" tabindex="-1" role="presentation"></a>Estos capítulos tienen como objetivo enseñarte los conceptos principales que Node.js utiliza y darte la información suficiente para escribir programas útiles para él. No intentan ser un tratamiento completo, ni siquiera exhaustivo, de la plataforma.</p>

<p><a class="p_ident" id="p-NM5XbgzOCu" href="#p-NM5XbgzOCu" tabindex="-1" role="presentation"></a>Mientras que podías ejecutar el código en los capítulos anteriores directamente en estas páginas, ya sea JavaScript raw o escrito para el navegador, los ejemplos de código en este capítulo están escritos para Node y a menudo no se ejecutarán en el navegador.</p>

<p><a class="p_ident" id="p-yDXmkj8agX" href="#p-yDXmkj8agX" tabindex="-1" role="presentation"></a>Si deseas seguir y ejecutar el código en este capítulo, necesitarás instalar Node.js versión 18 o superior. Para hacerlo, ve a <a href="https://nodejs.org"><em>https://nodejs.org</em></a> y sigue las instrucciones de instalación para tu sistema operativo. También puedes encontrar más documentación sobre Node.js allí.</p>

<h2><a class="h_ident" id="h-ZN1g/hoEn+" href="#h-ZN1g/hoEn+" tabindex="-1" role="presentation"></a>Antecedentes</h2>

<p><a class="p_ident" id="p-fSdNrY4Yml" href="#p-fSdNrY4Yml" tabindex="-1" role="presentation"></a>Cuando se construyen sistemas que se comunican a través de la red, la forma en que se gestiona la entrada y salida, es decir, la lectura y escritura de datos desde y hacia la red y el disco duro, puede marcar una gran diferencia en la rapidez con la que un sistema responde al usuario o a las solicitudes de la red.</p><p><a class="p_ident" id="p-DokqnUuxtX" href="#p-DokqnUuxtX" tabindex="-1" role="presentation"></a>En tales programas, la programación asíncrona a menudo es útil. Permite que el programa envíe y reciba datos desde y hacia múltiples dispositivos al mismo tiempo sin una complicada gestión de hilos y sincronización.</p>

<p><a class="p_ident" id="p-RCasOwXmol" href="#p-RCasOwXmol" tabindex="-1" role="presentation"></a>Node fue concebido inicialmente con el propósito de hacer que la programación asíncrona fuera fácil y conveniente. JavaScript se presta bien a un sistema como Node. Es uno de los pocos lenguajes de programación que no tienen una forma integrada de hacer entrada y salida. De esta manera, JavaScript podría adaptarse al enfoque bastante excéntrico de Node para la programación de red y sistema de archivos sin terminar con dos interfaces inconsistentes. En 2009, cuando se estaba diseñando Node, la gente ya estaba haciendo programación basada en devolución de llamada en el navegador, por lo que la comunidad en torno al lenguaje estaba acostumbrada a un estilo de programación asíncrona.</p>

<h2><a class="h_ident" id="h-TUzbi7lU/0" href="#h-TUzbi7lU/0" tabindex="-1" role="presentation"></a>El comando node</h2>

<p><a class="p_ident" id="p-rE0vPeaAdk" href="#p-rE0vPeaAdk" tabindex="-1" role="presentation"></a>Cuando Node.js está instalado en un sistema, proporciona un programa llamado <code>node</code>, que se utiliza para ejecutar archivos de JavaScript. Supongamos que tienes un archivo <code>hello.js</code>, que contiene este código:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Ys/5/PYPJK" href="#c-Ys/5/PYPJK" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">mensaje</span> = <span class="tok-string">"Hola mundo"</span>;
console.log(mensaje);</pre>

<p><a class="p_ident" id="p-AQLpVQwSlg" href="#p-AQLpVQwSlg" tabindex="-1" role="presentation"></a>Luego puedes ejecutar <code>node</code> desde la línea de comandos de la siguiente manera para ejecutar el programa:</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-+NijqTTZNf" href="#c-+NijqTTZNf" tabindex="-1" role="presentation"></a>$ node hello.js
Hola mundo</pre>

<p><a class="p_ident" id="p-m31aN0FBwM" href="#p-m31aN0FBwM" tabindex="-1" role="presentation"></a>El método <code>console.log</code> en Node hace algo similar a lo que hace en el navegador. Imprime un trozo de texto. Pero en Node, el texto se enviará al flujo de salida estándar del proceso, en lugar de a la consola de JavaScript del navegador. Al ejecutar <code>node</code> desde la línea de comandos, significa que verás los valores registrados en tu terminal.</p>

<p><a class="p_ident" id="p-0xbG1KLur9" href="#p-0xbG1KLur9" tabindex="-1" role="presentation"></a>Si ejecutas <code>node</code> sin darle un archivo, te proporcionará un indicador en el cual puedes escribir código de JavaScript y ver inmediatamente el resultado.</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-d/9k6S5oD+" href="#c-d/9k6S5oD+" tabindex="-1" role="presentation"></a>$ node
&gt; 1 + 1
2
&gt; [-1, -2, -3].map(Math.abs)
[1, 2, 3]
&gt; process.exit(0)
$</pre><p><a class="p_ident" id="p-gu0HNk/tPj" href="#p-gu0HNk/tPj" tabindex="-1" role="presentation"></a>La <code>process</code> vinculante, al igual que la vinculante <code>console</code>, está disponible globalmente en Node. Proporciona varias formas de inspeccionar y manipular el programa actual. El método <code>exit</code> termina el proceso y puede recibir un código de estado de salida, que le indica al programa que inició <code>node</code> (en este caso, la terminal de línea de comandos) si el programa se completó con éxito (código cero) o si se produjo un error (cualquier otro código).</p>

<p><a class="p_ident" id="p-r76dNN6hR1" href="#p-r76dNN6hR1" tabindex="-1" role="presentation"></a>Para encontrar los argumentos de línea de comandos dados a su script, puede leer <code>process.argv</code>, que es un array de strings. Tenga en cuenta que también incluye el nombre del comando <code>node</code> y el nombre de su script, por lo que los argumentos reales comienzan en el índice 2. Si <code>showargv.js</code> contiene la instrucción <code>console.<wbr>log(process.<wbr>argv)</code>, podría ejecutarlo así:</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-WCisDZr57g" href="#c-WCisDZr57g" tabindex="-1" role="presentation"></a>$ node showargv.js one --and two
["node", "/tmp/showargv.js", "one", "--and", "two"]</pre>

<p><a class="p_ident" id="p-ols5jgMHp4" href="#p-ols5jgMHp4" tabindex="-1" role="presentation"></a>Todas las vinculantes globales estándar de JavaScript, como <code>Array</code>, <code>Math</code> y <code>JSON</code>, también están presentes en el entorno de Node. La funcionalidad relacionada con el navegador, como <code>document</code> o <code>prompt</code>, no lo está.</p>

<h2><a class="h_ident" id="h-BOlGLA/wK7" href="#h-BOlGLA/wK7" tabindex="-1" role="presentation"></a>Módulos</h2>

<p><a class="p_ident" id="p-7uiDKmOxBC" href="#p-7uiDKmOxBC" tabindex="-1" role="presentation"></a>Además de las vinculantes que mencioné, como <code>console</code> y <code>process</code>, Node coloca algunas vinculantes adicionales en el alcance global. Si desea acceder a la funcionalidad integrada, debe solicitarla al sistema de módulos.</p>

<p><a class="p_ident" id="p-sGZ2maLmxa" href="#p-sGZ2maLmxa" tabindex="-1" role="presentation"></a>Node comenzó utilizando el sistema de módulos CommonJS, basado en la función <code>require</code>, que vimos en <a href="10_modules.html#commonjs">Capítulo 10</a>. Todavía utilizará este sistema de forma predeterminada cuando cargue un archivo <code>.js</code>.</p>

<p><a class="p_ident" id="p-RuYuVMUiwV" href="#p-RuYuVMUiwV" tabindex="-1" role="presentation"></a>Pero también admite el sistema de módulos más moderno de ES. Cuando el nombre de un archivo de script termina en <code>.mjs</code>, se considera un módulo de este tipo, y puede utilizar <code>import</code> y <code>export</code> en él (pero no <code>require</code>). Utilizaremos módulos de ES en este capítulo.</p>

<p><a class="p_ident" id="p-a8zlaHIaUU" href="#p-a8zlaHIaUU" tabindex="-1" role="presentation"></a>Al importar un módulo, ya sea con <code>require</code> o <code>import</code>, Node tiene que resolver la cadena dada a un archivo real que pueda cargar. Los nombres que comienzan con <code>/</code>, <code>./</code> o <code>../</code> se resuelven como archivos, relativos a la ruta del módulo actual. Aquí, <code>.</code> representa el directorio actual, <code>../</code> representa un directorio hacia arriba, y <code>/</code> representa la raíz del sistema de archivos. Entonces, si solicita <code>"./<wbr>graph.<wbr>mjs"</code> desde el archivo <code>/<wbr>tmp/<wbr>robot/<wbr>robot.<wbr>mjs</code>, Node intentará cargar el archivo <code>/<wbr>tmp/<wbr>robot/<wbr>graph.<wbr>mjs</code>.</p><p><a class="p_ident" id="p-Jbv0K2DaVF" href="#p-Jbv0K2DaVF" tabindex="-1" role="presentation"></a>Cuando se importa una cadena que no parece ser una ruta relativa o absoluta, se asume que se refiere a un módulo integrado o un módulo instalado en un directorio <code>node_modules</code>. Por ejemplo, importar <code>"node:fs"</code> te dará el módulo de sistema de archivos integrado de Node. E importar <code>"robot"</code> podría intentar cargar la biblioteca encontrada en <code>node_modules/<wbr>robot/<wbr></code>. Una forma común de instalar estas bibliotecas es utilizando NPM, a lo que volveremos en un momento.</p>

<p><a class="p_ident" id="p-nVdHCtPw94" href="#p-nVdHCtPw94" tabindex="-1" role="presentation"></a>Vamos a configurar un pequeño proyecto que consiste en dos archivos. El primero, llamado <code>main.mjs</code>, define un script que puede ser llamado desde la línea de comandos para revertir una cadena.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-l0vKU6uh/+" href="#c-l0vKU6uh/+" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">reverse</span>} <span class="tok-keyword">from</span> <span class="tok-string">"./reverse.mjs"</span>;

<span class="tok-comment">// El índice 2 contiene el primer argumento real de la línea de comandos</span>
<span class="tok-keyword">let</span> <span class="tok-definition">argumento</span> = process.argv[<span class="tok-number">2</span>];

console.log(reverse(argumento));</pre>

<p><a class="p_ident" id="p-4ZPnC8Ok8r" href="#p-4ZPnC8Ok8r" tabindex="-1" role="presentation"></a>El archivo <code>reverse.mjs</code> define una biblioteca para revertir cadenas, que puede ser utilizada tanto por esta herramienta de línea de comandos como por otros scripts que necesiten acceso directo a una función para revertir cadenas.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-p8FJa0H1D4" href="#c-p8FJa0H1D4" tabindex="-1" role="presentation"></a><span class="tok-keyword">export</span> <span class="tok-keyword">function</span> <span class="tok-definition">reverse</span>(<span class="tok-definition">cadena</span>) {
  <span class="tok-keyword">return</span> Array.from(cadena).reverse().join(<span class="tok-string">""</span>);
}</pre>

<p><a class="p_ident" id="p-30cETgfqDq" href="#p-30cETgfqDq" tabindex="-1" role="presentation"></a>Recuerda que <code>export</code> se utiliza para declarar que un enlace es parte de la interfaz del módulo. Eso permite que <code>main.mjs</code> importe y utilice la función.</p>

<p><a class="p_ident" id="p-S/nc4v84fJ" href="#p-S/nc4v84fJ" tabindex="-1" role="presentation"></a>Ahora podemos llamar a nuestra herramienta de la siguiente manera:</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-LYQo5Arp8G" href="#c-LYQo5Arp8G" tabindex="-1" role="presentation"></a>$ node main.mjs JavaScript
tpircSavaJ</pre>

<h2><a class="h_ident" id="h-J6hW/SmL/a" href="#h-J6hW/SmL/a" tabindex="-1" role="presentation"></a>Instalación con NPM</h2>

<p><a class="p_ident" id="p-AqsLxRwSwm" href="#p-AqsLxRwSwm" tabindex="-1" role="presentation"></a>NPM, que fue introducido en <a href="10_modules.html#modules_npm">Capítulo 10</a>, es un repositorio en línea de módulos de JavaScript, muchos de los cuales están escritos específicamente para Node. Cuando instalas Node en tu computadora, también obtienes el comando <code>npm</code>, que puedes utilizar para interactuar con este repositorio.</p><p><a class="p_ident" id="p-S050oa0uFn" href="#p-S050oa0uFn" tabindex="-1" role="presentation"></a>El uso principal de NPM es descargar paquetes. Vimos el paquete <code>ini</code> en <a href="10_modules.html#modules_ini">Capítulo 10</a>. Podemos usar NPM para buscar e instalar ese paquete en nuestra computadora.</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-K3dytBLqfv" href="#c-K3dytBLqfv" tabindex="-1" role="presentation"></a>$ npm install ini
added 1 package in 723ms

$ node
&gt; const {parse} = require("ini");
&gt; parse("x = 1\ny = 2");
{ x: '1', y: '2' }</pre>

<p><a class="p_ident" id="p-NBQHpDdZuw" href="#p-NBQHpDdZuw" tabindex="-1" role="presentation"></a>Después de ejecutar <code>npm install</code>, NPM habrá creado un directorio llamado <code>node_modules</code>. Dentro de ese directorio habrá un directorio <code>ini</code> que contiene la biblioteca. Puedes abrirlo y ver el código. Cuando importamos <code>"ini"</code>, esta biblioteca se carga y podemos llamar a su propiedad <code>parse</code> para analizar un archivo de configuración.</p>

<p><a class="p_ident" id="p-sKeXO3qL6G" href="#p-sKeXO3qL6G" tabindex="-1" role="presentation"></a>Por defecto, NPM instala paquetes bajo el directorio actual, en lugar de en un lugar centralizado. Si estás acostumbrado a otros gestores de paquetes, esto puede parecer inusual, pero tiene ventajas: coloca a cada aplicación en control total de los paquetes que instala y facilita la gestión de versiones y la limpieza al eliminar una aplicación.</p>

<h3><a class="i_ident" id="i-IMZP7FN0pF" href="#i-IMZP7FN0pF" tabindex="-1" role="presentation"></a>Archivos de paquete</h3>

<p><a class="p_ident" id="p-5HO/QjCY7A" href="#p-5HO/QjCY7A" tabindex="-1" role="presentation"></a>Después de ejecutar <code>npm install</code> para instalar algún paquete, encontrarás no solo un directorio <code>node_modules</code>, sino también un archivo llamado <code>package.json</code> en tu directorio actual. Se recomienda tener dicho archivo para cada proyecto. Puedes crearlo manualmente o ejecutar <code>npm init</code>. Este archivo contiene información sobre el proyecto, como su nombre y versión, y enumera sus dependencias.</p>

<p><a class="p_ident" id="p-NT9giTr6Q2" href="#p-NT9giTr6Q2" tabindex="-1" role="presentation"></a>La simulación de robot del <a href="07_robot.html">Capítulo 7</a>, modularizada en el ejercicio en <a href="10_modules.html#modular_robot">Capítulo 10</a>, podría tener un archivo <code>package.json</code> como este:</p>

<pre class="snippet" data-language="json"><a class="c_ident" id="c-uk0kgUiaJg" href="#c-uk0kgUiaJg" tabindex="-1" role="presentation"></a>{
  <span class="tok-string">"author"</span>: <span class="tok-string">"Marijn Haverbeke"</span>,
  <span class="tok-string">"name"</span>: <span class="tok-string">"eloquent-javascript-robot"</span>,
  <span class="tok-string">"description"</span>: <span class="tok-string">"Simulación de un robot de entrega de paquetes"</span>,
  <span class="tok-string">"version"</span>: <span class="tok-string">"1.0.0"</span>,
  <span class="tok-string">"main"</span>: <span class="tok-string">"run.mjs"</span>,
  <span class="tok-string">"dependencies"</span>: {
    <span class="tok-string">"dijkstrajs"</span>: <span class="tok-string">"^1.0.1"</span>,
    <span class="tok-string">"random-item"</span>: <span class="tok-string">"^1.0.0"</span>
  },
  <span class="tok-string">"license"</span>: <span class="tok-string">"ISC"</span>
}</pre><p><a class="p_ident" id="p-LA2QNdOUqm" href="#p-LA2QNdOUqm" tabindex="-1" role="presentation"></a>Cuando ejecutas <code>npm install</code> sin especificar un paquete para instalar, NPM instalará las dependencias listadas en <code>package.json</code>. Cuando instalas un paquete específico que no está listado como una dependencia, NPM lo añadirá a <code>package.json</code>.</p>

<h3><a class="i_ident" id="i-ojkQfvKPbv" href="#i-ojkQfvKPbv" tabindex="-1" role="presentation"></a>Versiones</h3>

<p><a class="p_ident" id="p-UrPIybyUA4" href="#p-UrPIybyUA4" tabindex="-1" role="presentation"></a>Un archivo <code>package.json</code> lista tanto la versión del propio programa como las versiones de sus dependencias. Las versiones son una forma de manejar el hecho de que los paquetes evolucionan separadamente, y el código escrito para funcionar con un paquete tal como existía en un punto puede que no funcione con una versión posterior modificada del paquete.</p>

<p><a class="p_ident" id="p-CvfHe7sDbQ" href="#p-CvfHe7sDbQ" tabindex="-1" role="presentation"></a>NPM exige que sus paquetes sigan un esquema llamado <em>versionado semántico</em>, que codifica cierta información sobre qué versiones son <em>compatibles</em> (no rompen la interfaz antigua) en el número de versión. Una versión semántica consiste en tres números, separados por períodos, como <code>2.3.0</code>. Cada vez que se agrega nueva funcionalidad, el número del medio tiene que incrementarse. Cada vez que se rompe la compatibilidad, de modo que el código existente que usa el paquete puede que no funcione con la nueva versión, el primer número tiene que incrementarse.</p>

<p><a class="p_ident" id="p-gTL1n2TLHm" href="#p-gTL1n2TLHm" tabindex="-1" role="presentation"></a>Un carácter de acento circunflejo (<code>^</code>) delante del número de versión para una dependencia en <code>package.json</code> indica que se puede instalar cualquier versión compatible con el número dado. Así, por ejemplo, <code>"^2.<wbr>3.<wbr>0"</code> significaría que cualquier versión mayor o igual a 2.3.0 y menor que 3.0.0 está permitida.</p>

<p><a class="p_ident" id="p-HcGcWqTR8/" href="#p-HcGcWqTR8/" tabindex="-1" role="presentation"></a>El comando <code>npm</code> también se usa para publicar nuevos paquetes o nuevas versiones de paquetes. Si ejecutas <code>npm publish</code> en un directorio que contiene un archivo <code>package.json</code>, se publicará un paquete con el nombre y la versión listados en el archivo JSON en el registro. Cualquiera puede publicar paquetes en NPM, aunque solo bajo un nombre de paquete que aún no esté en uso ya que no sería conveniente que personas aleatorias pudieran actualizar paquetes existentes.</p>

<p><a class="p_ident" id="p-u9CNibuDC7" href="#p-u9CNibuDC7" tabindex="-1" role="presentation"></a>Este libro no se adentrará más en los detalles del uso de NPM. Consulta <a href="https://npmjs.org"><em>https://npmjs.org</em></a> para obtener más documentación y buscar paquetes.</p>

<h2><a class="h_ident" id="h-o2abiQU0TD" href="#h-o2abiQU0TD" tabindex="-1" role="presentation"></a>El módulo del sistema de archivos</h2>

<p><a class="p_ident" id="p-HumHNRQKJx" href="#p-HumHNRQKJx" tabindex="-1" role="presentation"></a>Uno de los módulos integrados más utilizados en Node es el módulo <code>node:fs</code>, que significa <em>sistema de archivos</em>. Exporta funciones para trabajar con archivos y directorios.</p><p><a class="p_ident" id="p-75RFSIQwdU" href="#p-75RFSIQwdU" tabindex="-1" role="presentation"></a>Por ejemplo, la función llamada <code>readFile</code> lee un archivo y luego llama a un callback con el contenido del archivo.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-vwpa9FujQK" href="#c-vwpa9FujQK" tabindex="-1" role="presentation"></a><span class="tok-keyword">importar</span> {<span class="tok-definition">readFile</span>} <span class="tok-keyword">desde</span> <span class="tok-string">"node:fs"</span>;
readFile(<span class="tok-string">"file.txt"</span>, <span class="tok-string">"utf8"</span>, (<span class="tok-definition">error</span>, <span class="tok-definition">texto</span>) =&gt; {
  <span class="tok-keyword">si</span> (error) <span class="tok-keyword">lanzar</span> error;
  console.log(<span class="tok-string">"El archivo contiene:"</span>, texto);
});</pre>

<p><a class="p_ident" id="p-kiSsXyNElK" href="#p-kiSsXyNElK" tabindex="-1" role="presentation"></a>El segundo argumento de <code>readFile</code> indica la <em>codificación de caracteres</em> utilizada para decodificar el archivo a una cadena de texto. Hay varias formas en las que el texto puede ser codificado en datos binarios, pero la mayoría de los sistemas modernos utilizan UTF-8. Así que a menos que tengas razones para creer que se utiliza otra codificación, pasa <code>"utf8"</code> al leer un archivo de texto. Si no pasas una codificación, Node asumirá que estás interesado en los datos binarios y te dará un objeto <code>Buffer</code> en lugar de una cadena de texto. Este es un objeto similar a un array que contiene números representando los bytes (porciones de datos de 8 bits) en los archivos.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-a0H6Ao5E+M" href="#c-a0H6Ao5E+M" tabindex="-1" role="presentation"></a><span class="tok-keyword">importar</span> {<span class="tok-definition">readFile</span>} <span class="tok-keyword">desde</span> <span class="tok-string">"node:fs"</span>;
readFile(<span class="tok-string">"archivo.txt"</span>, (<span class="tok-definition">error</span>, <span class="tok-definition">buffer</span>) =&gt; {
  <span class="tok-keyword">si</span> (error) <span class="tok-keyword">lanzar</span> error;
  console.log(<span class="tok-string">"El archivo contenía"</span>, buffer.length, <span class="tok-string">"bytes."</span>,
              <span class="tok-string">"El primer byte es:"</span>, buffer[<span class="tok-number">0</span>]);
});</pre>

<p><a class="p_ident" id="p-2eNWgxdLGx" href="#p-2eNWgxdLGx" tabindex="-1" role="presentation"></a>Una función similar, <code>writeFile</code>, se utiliza para escribir un archivo en el disco.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-EBPVY7LdZ1" href="#c-EBPVY7LdZ1" tabindex="-1" role="presentation"></a><span class="tok-keyword">importar</span> {<span class="tok-definition">writeFile</span>} <span class="tok-keyword">desde</span> <span class="tok-string">"node:fs"</span>;
writeFile(<span class="tok-string">"graffiti.txt"</span>, <span class="tok-string">"Node estuvo aquí"</span>, <span class="tok-definition">err</span> =&gt; {
  <span class="tok-keyword">si</span> (err) console.log(<span class="tok-string2">`Error al escribir el archivo: </span>${err}<span class="tok-string2">`</span>);
  <span class="tok-keyword">sino</span> console.log(<span class="tok-string">"Archivo escrito."</span>);
});</pre><p><a class="p_ident" id="p-rDd4gjDwV6" href="#p-rDd4gjDwV6" tabindex="-1" role="presentation"></a>Here it was not necessary to specify the encoding—<code>writeFile</code> will assume that when it is given a string to write, rather than a <code>Buffer</code> object, it should write it out as text using its default character encoding, which is UTF-8.</p>

<p><a class="p_ident" id="p-SJ/BKOfrhB" href="#p-SJ/BKOfrhB" tabindex="-1" role="presentation"></a>The <code>node:fs</code> module contains many other useful functions: <code>readdir</code> will give you the files in a directory as an array of strings, <code>stat</code> will retrieve information about a file, <code>rename</code> will rename a file, <code>unlink</code> will remove one, and so on. See the documentation at <a href="https://nodejs.org"><em>https://nodejs.org</em></a> for specifics.</p>

<p><a class="p_ident" id="p-e3QJHgZtmU" href="#p-e3QJHgZtmU" tabindex="-1" role="presentation"></a>Most of these take a callback function as the last parameter, which they call either with an error (the first argument) or with a successful result (the second). As we saw in <a href="11_async.html">Chapter 11</a>, there are downsides to this style of programming—the biggest one being that error handling becomes verbose and error-prone.</p>

<p><a class="p_ident" id="p-8dYVVsE4xv" href="#p-8dYVVsE4xv" tabindex="-1" role="presentation"></a>The <code>node:fs/promises</code> module exports most of the same functions as the old <code>node:fs</code> module, but uses promises rather than callback functions.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-UnYqgzBSbm" href="#c-UnYqgzBSbm" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">readFile</span>} <span class="tok-keyword">from</span> <span class="tok-string">"node:fs/promises"</span>;
readFile(<span class="tok-string">"file.txt"</span>, <span class="tok-string">"utf8"</span>)
  .then(<span class="tok-definition">text</span> =&gt; console.log(<span class="tok-string">"El archivo contiene:"</span>, text));</pre>

<p><a class="p_ident" id="p-RKcdbQa/Ot" href="#p-RKcdbQa/Ot" tabindex="-1" role="presentation"></a>Sometimes you don’t need asynchronicity, and it just gets in the way. Many of the functions in <code>node:fs</code> also have a synchronous variant, which has the same name with <code>Sync</code> added to the end. For example, the synchronous version of <code>readFile</code> is called <code>readFileSync</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Xb5Jjk4nDg" href="#c-Xb5Jjk4nDg" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">readFileSync</span>} <span class="tok-keyword">from</span> <span class="tok-string">"node:fs"</span>;
console.log(<span class="tok-string">"El archivo contiene:"</span>,
            readFileSync(<span class="tok-string">"file.txt"</span>, <span class="tok-string">"utf8"</span>));</pre><p><a class="p_ident" id="p-C0yp9W48Cn" href="#p-C0yp9W48Cn" tabindex="-1" role="presentation"></a>Recuerda que mientras se realiza una operación síncrona de este tipo, tu programa se detiene por completo. Si debería estar respondiendo al usuario u a otras máquinas en la red, quedar atascado en una acción síncrona podría producir retrasos molestos.</p>

<h2><a class="h_ident" id="h-3O5dGIJE9F" href="#h-3O5dGIJE9F" tabindex="-1" role="presentation"></a>El módulo HTTP</h2>

<p><a class="p_ident" id="p-DmbHt+6pJm" href="#p-DmbHt+6pJm" tabindex="-1" role="presentation"></a>Otro módulo central se llama <code>node:http</code>. Proporciona funcionalidad para ejecutar un servidor HTTP.</p>

<p><a class="p_ident" id="p-5AqaLQsq5V" href="#p-5AqaLQsq5V" tabindex="-1" role="presentation"></a>Esto es todo lo que se necesita para iniciar un servidor HTTP:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-iG/Ok1vO37" href="#c-iG/Ok1vO37" tabindex="-1" role="presentation"></a><span class="tok-keyword">importar</span> {<span class="tok-definition">createServer</span>} <span class="tok-keyword">de</span> <span class="tok-string">"node:http"</span>;
<span class="tok-keyword">let</span> <span class="tok-definition">servidor</span> = createServer((<span class="tok-definition">solicitud</span>, <span class="tok-definition">respuesta</span>) =&gt; {
  respuesta.writeHead(<span class="tok-number">200</span>, {<span class="tok-string">"Content-Type"</span>: <span class="tok-string">"text/html"</span>});
  respuesta.write(<span class="tok-string2">`</span>
<span class="tok-string2">    &lt;h1&gt;¡Hola!&lt;/h1&gt;</span>
<span class="tok-string2">    &lt;p&gt;Has solicitado &lt;code&gt;</span>${solicitud.url}<span class="tok-string2">&lt;/code&gt;&lt;/p&gt;`</span>);
  respuesta.end();
});
servidor.listen(<span class="tok-number">8000</span>);
console.log(<span class="tok-string">"¡Escuchando! (puerto 8000)"</span>);</pre>

<p><a class="p_ident" id="p-aWcDaGah2b" href="#p-aWcDaGah2b" tabindex="-1" role="presentation"></a>Si ejecutas este script en tu propia máquina, puedes apuntar tu navegador web a <a href="http://localhost:8000/hello"><em>http://localhost:8000/hello</em></a> para hacer una solicitud a tu servidor. Responderá con una pequeña página HTML.</p>

<p><a class="p_ident" id="p-ZiHH2p8YG0" href="#p-ZiHH2p8YG0" tabindex="-1" role="presentation"></a>La función pasada como argumento a <code>createServer</code> se llama cada vez que un cliente se conecta al servidor. Las vinculaciones de <code>request</code> y <code>response</code> son objetos que representan los datos entrantes y salientes. El primero contiene información sobre la solicitud, como su propiedad <code>url</code>, que nos dice a qué URL se hizo la solicitud.</p>

<p><a class="p_ident" id="p-ufJ1Rx8+U9" href="#p-ufJ1Rx8+U9" tabindex="-1" role="presentation"></a>Entonces, cuando abres esa página en tu navegador, envía una solicitud a tu propia computadora. Esto hace que la función del servidor se ejecute y envíe una respuesta, que luego puedes ver en el navegador.</p><p><a class="p_ident" id="p-eHNvwd3lFU" href="#p-eHNvwd3lFU" tabindex="-1" role="presentation"></a>Para enviar algo al cliente, se llaman métodos en el objeto <code>response</code>. El primero, <code>writeHead</code>, escribirá los encabezados de la respuesta (ver <a href="18_http.html#headers">Capítulo 18</a>). Se le proporciona el código de estado (200 para "OK" en este caso) y un objeto que contiene los valores de los encabezados. El ejemplo establece el encabezado <code>Content-Type</code> para informar al cliente que estaremos enviando un documento HTML de vuelta.</p>

<p><a class="p_ident" id="p-AVzTSVzXSM" href="#p-AVzTSVzXSM" tabindex="-1" role="presentation"></a>Luego, el cuerpo de la respuesta real (el documento en sí) se envía con <code>response.write</code>. Se permite llamar a este método varias veces si se desea enviar la respuesta pieza por pieza, por ejemplo, para transmitir datos al cliente a medida que estén disponibles. Finalmente, <code>response.end</code> señala el final de la respuesta.</p>

<p><a class="p_ident" id="p-evKrjFovQf" href="#p-evKrjFovQf" tabindex="-1" role="presentation"></a>La llamada a <code>server.listen</code> hace que el servidor comience a esperar conexiones en el puerto 8000. Por eso debes conectarte a <em>localhost:8000</em> para comunicarte con este servidor, en lugar de solo <em>localhost</em>, que usaría el puerto predeterminado 80.</p>

<p><a class="p_ident" id="p-fc62/ayv5k" href="#p-fc62/ayv5k" tabindex="-1" role="presentation"></a>Cuando ejecutas este script, el proceso simplemente se queda allí esperando. Cuando un script está escuchando eventos, en este caso, conexiones de red, <code>node</code> no saldrá automáticamente al llegar al final del script. Para cerrarlo, presiona <span class="keyname">control</span>-C.</p>

<p><a class="p_ident" id="p-7qMlOUUlqm" href="#p-7qMlOUUlqm" tabindex="-1" role="presentation"></a>Un servidor web real generalmente hace más que el del ejemplo: examina el método de la solicitud (la propiedad <code>method</code>) para ver qué acción está intentando realizar el cliente y examina la URL de la solicitud para averiguar en qué recurso se está realizando esta acción. Veremos un servidor más avanzado <a href="20_node.html#file_server">más adelante en este capítulo</a>.</p>

<p><a class="p_ident" id="p-p3ahXsNmuS" href="#p-p3ahXsNmuS" tabindex="-1" role="presentation"></a>El módulo <code>node:http</code> también proporciona una función <code>request</code>, que se puede utilizar para hacer solicitudes HTTP. Sin embargo, es mucho más engorroso de usar que <code>fetch</code>, que vimos en <a href="18_http.html">Capítulo 18</a>. Afortunadamente, <code>fetch</code> también está disponible en Node, como una unión global. A menos que desees hacer algo muy específico, como procesar el documento de respuesta pieza por pieza a medida que llegan los datos a través de la red, recomiendo quedarse con <code>fetch</code>.</p>

<h2><a class="h_ident" id="h-dJhdomfGgD" href="#h-dJhdomfGgD" tabindex="-1" role="presentation"></a>Flujos</h2>

<p><a class="p_ident" id="p-Wekb742ncQ" href="#p-Wekb742ncQ" tabindex="-1" role="presentation"></a>El objeto de respuesta al que el servidor HTTP podría escribir es un ejemplo de un objeto de <em>flujo de escritura</em>, que es un concepto ampliamente utilizado en Node. Tales objetos tienen un método <code>write</code> al que se le puede pasar una cadena o un objeto <code>Buffer</code> para escribir algo en el flujo. Su método <code>end</code> cierra el flujo y opcionalmente toma un valor para escribir en el flujo antes de cerrarlo. Ambos métodos también pueden recibir una devolución de llamada como argumento adicional, que se llamará cuando la escritura o el cierre hayan terminado.</p><p><a class="p_ident" id="p-L3YcfbxZV7" href="#p-L3YcfbxZV7" tabindex="-1" role="presentation"></a>Es posible crear un flujo de escritura que apunte a un archivo con la función <code>createWriteStream</code> del módulo <code>node:fs</code>. Luego puedes usar el método <code>write</code> en el objeto resultante para escribir el archivo de a pedazos, en lugar de hacerlo de una vez como con <code>writeFile</code>.</p>

<p><a class="p_ident" id="p-93VQIHGgFt" href="#p-93VQIHGgFt" tabindex="-1" role="presentation"></a>Los <em>flujos de lectura</em> son un poco más complejos. El argumento <code>request</code> para la devolución de llamada del servidor HTTP es un flujo de lectura. La lectura desde un flujo se hace usando manejadores de eventos, en lugar de métodos.</p>

<p><a class="p_ident" id="p-CaPkx6i5f+" href="#p-CaPkx6i5f+" tabindex="-1" role="presentation"></a>Los objetos que emiten eventos en Node tienen un método llamado <code>on</code> que es similar al método <code>addEventListener</code> en el navegador. Le das un nombre de evento y luego una función, y registrará esa función para que se llame cada vez que ocurra el evento dado.</p>

<p><a class="p_ident" id="p-3yAsJAs/Gl" href="#p-3yAsJAs/Gl" tabindex="-1" role="presentation"></a>Los flujos de lectura tienen eventos <code>"data"</code> y <code>"end"</code>. El primero se dispara cada vez que llegan datos, y el segundo se llama cuando el flujo llega a su final. Este modelo es más adecuado para <em>transmitir</em> datos que se pueden procesar inmediatamente, incluso cuando no está disponible todo el documento. Un archivo se puede leer como un flujo de lectura usando la función <code>createReadStream</code> de <code>node:fs</code>.</p>

<p><a class="p_ident" id="p-DQmM9KjDIA" href="#p-DQmM9KjDIA" tabindex="-1" role="presentation"></a>Este código crea un servidor que lee los cuerpos de las solicitudes y los transmite de vuelta al cliente como texto completamente en mayúsculas:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-WGmsdnB9wt" href="#c-WGmsdnB9wt" tabindex="-1" role="presentation"></a><span class="tok-keyword">importar</span> {<span class="tok-definition">createServer</span>} <span class="tok-keyword">de</span> <span class="tok-string">"node:http"</span>;
createServer((<span class="tok-definition">solicitud</span>, <span class="tok-definition">respuesta</span>) =&gt; {
  respuesta.writeHead(<span class="tok-number">200</span>, {<span class="tok-string">"Tipo de contenido"</span>: <span class="tok-string">"texto plano"</span>});
  solicitud.on(<span class="tok-string">"datos"</span>, <span class="tok-definition">chunk</span> =&gt;
    respuesta.write(chunk.toString().toUpperCase()));
  solicitud.on(<span class="tok-string">"fin"</span>, () =&gt; respuesta.end());
}).escuchar(<span class="tok-number">8000</span>);</pre>

<p><a class="p_ident" id="p-cE/QJiL9Ih" href="#p-cE/QJiL9Ih" tabindex="-1" role="presentation"></a>El valor <code>chunk</code> pasado al controlador de datos será un <code>Buffer</code> binario. Podemos convertir esto a un string decodificándolo como caracteres codificados en UTF-8 con su método <code>toString</code>.</p><p><a class="p_ident" id="p-6S1XXBZo7w" href="#p-6S1XXBZo7w" tabindex="-1" role="presentation"></a>El siguiente fragmento de código, cuando se ejecute con el servidor de mayúsculas activo, enviará una solicitud a ese servidor y escribirá la respuesta que recibe:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-sOV/OX0P/s" href="#c-sOV/OX0P/s" tabindex="-1" role="presentation"></a>fetch(<span class="tok-string">"http://localhost:8000/"</span>, {
  <span class="tok-definition">method</span>: <span class="tok-string">"POST"</span>,
  <span class="tok-definition">body</span>: <span class="tok-string">"Hola servidor"</span>
}).then(<span class="tok-definition">resp</span> =&gt; resp.text()).then(console.log);
<span class="tok-comment">// → HOLA SERVIDOR</span></pre>

<h2 id="file_server"><a class="h_ident" id="h-yAdw1Y7bgN" href="#h-yAdw1Y7bgN" tabindex="-1" role="presentation"></a>Un servidor de archivos</h2>

<p><a class="p_ident" id="p-m8AQqOO4Ya" href="#p-m8AQqOO4Ya" tabindex="-1" role="presentation"></a>Combinemos nuestro nuevo conocimiento sobre servidores HTTP y el trabajo con el sistema de archivos para crear un puente entre ambos: un servidor HTTP que permite acceso remoto a un sistema de archivos. Este tipo de servidor tiene todo tipo de usos, ya que permite a las aplicaciones web almacenar y compartir datos, o puede proporcionar acceso compartido a un grupo de personas a un conjunto de archivos.</p>

<p><a class="p_ident" id="p-Pu9mO8Vutb" href="#p-Pu9mO8Vutb" tabindex="-1" role="presentation"></a>Cuando tratamos los archivos como recursos HTTP, los métodos HTTP <code>GET</code>, <code>PUT</code> y <code>DELETE</code> se pueden utilizar para leer, escribir y eliminar los archivos, respectivamente. Interpretaremos la ruta en la solicitud como la ruta del archivo al que se refiere la solicitud.</p>

<p><a class="p_ident" id="p-ISZx6yrjrK" href="#p-ISZx6yrjrK" tabindex="-1" role="presentation"></a>Probablemente no queremos compartir todo nuestro sistema de archivos, así que interpretaremos estas rutas como comenzando en el directorio de trabajo del servidor, que es el directorio en el que se inició. Si ejecuté el servidor desde <code>/tmp/public/</code> (o <code>C:\tmp\public\</code> en Windows), entonces una solicitud para <code>/file.txt</code> debería referirse a <code>/tmp/public/file.txt</code> (o <code>C:\tmp\public\file.txt</code>).</p>

<p><a class="p_ident" id="p-sVgrQ04Hby" href="#p-sVgrQ04Hby" tabindex="-1" role="presentation"></a>Construiremos el programa pieza por pieza, utilizando un objeto llamado <code>methods</code> para almacenar las funciones que manejan los diferentes métodos HTTP. Los manejadores de métodos son funciones <code>async</code> que reciben el objeto de solicitud como argumento y devuelven una promesa que se resuelve a un objeto que describe la respuesta.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-D89ixYkv4U" href="#c-D89ixYkv4U" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">createServer</span>} <span class="tok-keyword">from</span> <span class="tok-string">"node:http"</span>;<span class="tok-keyword">const</span> <span class="tok-definition">methods</span> = Object.create(<span class="tok-keyword">null</span>);

createServer((<span class="tok-definition">request</span>, <span class="tok-definition">response</span>) =&gt; {
  <span class="tok-keyword">let</span> <span class="tok-definition">handler</span> = methods[request.method] || notAllowed;
  handler(request).catch(<span class="tok-definition">error</span> =&gt; {
    <span class="tok-keyword">if</span> (error.status != <span class="tok-keyword">null</span>) <span class="tok-keyword">return</span> error;
    <span class="tok-keyword">return</span> {<span class="tok-definition">body</span>: String(error), <span class="tok-definition">status</span>: <span class="tok-number">500</span>};
  }).then(({body, status = <span class="tok-number">200</span>, type = <span class="tok-string">"text/plain"</span>}) =&gt; {
    response.writeHead(status, {<span class="tok-string">"Content-Type"</span>: type});
    <span class="tok-keyword">if</span> (body &amp;&amp; body.pipe) body.pipe(response);
    <span class="tok-keyword">else</span> response.end(body);
  });
}).listen(<span class="tok-number">8000</span>);

<span class="tok-keyword">async</span> <span class="tok-keyword">function</span> <span class="tok-definition">notAllowed</span>(<span class="tok-definition">request</span>) {
  <span class="tok-keyword">return</span> {
    <span class="tok-definition">status</span>: <span class="tok-number">405</span>,
    <span class="tok-definition">body</span>: <span class="tok-string2">`Method </span>${request.method}<span class="tok-string2"> not allowed.`</span>
  };
}</pre>

<p><a class="p_ident" id="p-XQyghTfOgS" href="#p-XQyghTfOgS" tabindex="-1" role="presentation"></a>Esto inicia un servidor que solo devuelve respuestas de error 405, que es el código utilizado para indicar que el servidor se niega a manejar un determinado método.</p>

<p><a class="p_ident" id="p-JXw1kc0aXP" href="#p-JXw1kc0aXP" tabindex="-1" role="presentation"></a>Cuando la promesa del manejador de la solicitud es rechazada, la llamada de <code>catch</code> traduce el error en un objeto de respuesta, si no lo es ya, para que el servidor pueda enviar una respuesta de error al cliente informando que falló al manejar la solicitud.</p>

<p><a class="p_ident" id="p-hqnRLFr4tm" href="#p-hqnRLFr4tm" tabindex="-1" role="presentation"></a>El campo <code>status</code> de la descripción de la respuesta puede omitirse, en cuyo caso se establece en 200 (OK) por defecto. El tipo de contenido, en la propiedad <code>type</code>, también puede omitirse, en cuyo caso se asume que la respuesta es texto plano.</p>

<p><a class="p_ident" id="p-exZyYeIqg6" href="#p-exZyYeIqg6" tabindex="-1" role="presentation"></a>Cuando el valor de <code>body</code> es un flujo legible, tendrá un método <code>pipe</code> que se utiliza para reenviar todo el contenido de un flujo legible a un flujo escribible. Si no lo es, se asume que es o bien <code>null</code> (sin cuerpo), una cadena o un búfer, y se pasa directamente al método <code>end</code> de la respuesta.</p><p><a class="p_ident" id="p-pL6vfBBk4E" href="#p-pL6vfBBk4E" tabindex="-1" role="presentation"></a>Para descifrar qué ruta de archivo corresponde a una URL de solicitud, la función <code>urlPath</code> utiliza la clase incorporada <code>URL</code> (que también existe en el navegador) para analizar la URL. Este constructor espera una URL completa, no solo la parte que comienza con la barra que obtenemos de <code>request.url</code>, por lo que le damos un nombre de dominio falso para completar. Extrae su ruta, que será algo como <code>"/<wbr>file.<wbr>txt"</code>, decodifica eso para deshacerse de los códigos de escape estilo <code>%20</code>, y la resuelve con respecto al directorio de trabajo del programa.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-1oMZwGp7TL" href="#c-1oMZwGp7TL" tabindex="-1" role="presentation"></a><span class="tok-keyword">importar</span> {<span class="tok-definition">parse</span>} <span class="tok-keyword">desde</span> <span class="tok-string">"node:url"</span>;
<span class="tok-keyword">importar</span> {<span class="tok-definition">resolver</span>, <span class="tok-definition">sep</span>} <span class="tok-keyword">desde</span> <span class="tok-string">"node:path"</span>;

<span class="tok-keyword">const</span> <span class="tok-definition">baseDirectory</span> = process.cwd();

<span class="tok-keyword">function</span> <span class="tok-definition">urlPath</span>(<span class="tok-definition">url</span>) {
  <span class="tok-keyword">let</span> {pathname} = <span class="tok-keyword">nuevo</span> URL(url, <span class="tok-string">"http://d"</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">path</span> = resolver(decodeURIComponent(pathname).slice(<span class="tok-number">1</span>));
  <span class="tok-keyword">si</span> (path != baseDirectory &amp;&amp;
      !path.startsWith(baseDirectory + sep)) {
    <span class="tok-keyword">lanzar</span> {<span class="tok-definition">estado</span>: <span class="tok-number">403</span>, <span class="tok-definition">cuerpo</span>: <span class="tok-string">"Prohibido"</span>};
  }
  <span class="tok-keyword">return</span> path;
}</pre>

<p><a class="p_ident" id="p-1NWx24yrl9" href="#p-1NWx24yrl9" tabindex="-1" role="presentation"></a>Tan pronto como configures un programa para aceptar solicitudes de red, debes empezar a preocuparte por la seguridad. En este caso, si no somos cuidadosos, es probable que accidentalmente expongamos todo nuestro sistema de archivos a la red.</p>

<p><a class="p_ident" id="p-m0GNABM8RH" href="#p-m0GNABM8RH" tabindex="-1" role="presentation"></a>Las rutas de archivo son cadenas en Node. Para mapear una cadena así a un archivo real, hay una cantidad no trivial de interpretación. Las rutas pueden, por ejemplo, incluir <code>../</code> para referirse a un directorio padre. Entonces una fuente obvia de problemas serían solicitudes de rutas como <code>/../secret_file</code>.</p>

<p><a class="p_ident" id="p-RqOQ15MdP0" href="#p-RqOQ15MdP0" tabindex="-1" role="presentation"></a>Para evitar tales problemas, <code>urlPath</code> utiliza la función <code>resolver</code> del módulo <code>node:path</code>, que resuelve rutas relativas. Luego verifica que el resultado esté <em>debajo</em> del directorio de trabajo. La función <code>process.cwd</code> (donde <code>cwd</code> significa "directorio de trabajo actual") se puede utilizar para encontrar este directorio de trabajo. El enlace <code>sep</code> del paquete <code>node:path</code> es el separador de ruta del sistema: una barra invertida en Windows y una barra inclinada en la mayoría de los otros sistemas. Cuando la ruta no comienza con el directorio base, la función lanza un objeto de respuesta de error, utilizando el código de estado HTTP que indica que el acceso al recurso está prohibido.</p><p><a class="p_ident" id="p-Xq2qYv1Lff" href="#p-Xq2qYv1Lff" tabindex="-1" role="presentation"></a>Vamos a configurar el método <code>GET</code> para devolver una lista de archivos al leer un directorio y devolver el contenido del archivo al leer un archivo regular.</p>

<p><a class="p_ident" id="p-zj6fKVP9SD" href="#p-zj6fKVP9SD" tabindex="-1" role="presentation"></a>Una pregunta complicada es qué tipo de encabezado <code>Content-Type</code> debemos establecer al devolver el contenido de un archivo. Dado que estos archivos podrían ser de cualquier tipo, nuestro servidor no puede simplemente devolver el mismo tipo de contenido para todos ellos. NPM puede ayudarnos aquí nuevamente. El paquete <code>mime-types</code> (indicadores de tipo de contenido como <code>text/plain</code> también se llaman <em>tipos MIME</em>) conoce el tipo correcto para una gran cantidad de extensiones de archivo.</p>

<p><a class="p_ident" id="p-ZZr+O24IMr" href="#p-ZZr+O24IMr" tabindex="-1" role="presentation"></a>El siguiente comando de <code>npm</code>, en el directorio donde reside el script del servidor, instala una versión específica de <code>mime</code>:</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-EObiWUZetK" href="#c-EObiWUZetK" tabindex="-1" role="presentation"></a>$ npm install mime-types@2.1.0</pre>

<p><a class="p_ident" id="p-0oNrzailqn" href="#p-0oNrzailqn" tabindex="-1" role="presentation"></a>Cuando un archivo solicitado no existe, el código de estado HTTP correcto a devolver es 404. Usaremos la función <code>stat</code>, que busca información sobre un archivo, para averiguar tanto si el archivo existe como si es un directorio.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-nfmdPfwRar" href="#c-nfmdPfwRar" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">createReadStream</span>} <span class="tok-keyword">from</span> <span class="tok-string">"node:fs"</span>;
<span class="tok-keyword">import</span> {<span class="tok-definition">stat</span>, <span class="tok-definition">readdir</span>} <span class="tok-keyword">from</span> <span class="tok-string">"node:fs/promises"</span>;
<span class="tok-keyword">import</span> {<span class="tok-definition">lookup</span>} <span class="tok-keyword">from</span> <span class="tok-string">"mime-types"</span>;

methods.GET = <span class="tok-keyword">async</span> <span class="tok-keyword">function</span>(<span class="tok-definition">request</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">path</span> = urlPath(request.url);
  <span class="tok-keyword">let</span> <span class="tok-definition">stats</span>;
  <span class="tok-keyword">try</span> {
    stats = <span class="tok-keyword">await</span> stat(path);
  } <span class="tok-keyword">catch</span> (<span class="tok-definition">error</span>) {
    <span class="tok-keyword">if</span> (error.code != <span class="tok-string">"ENOENT"</span>) <span class="tok-keyword">throw</span> error;
    <span class="tok-keyword">else</span> <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">404</span>, <span class="tok-definition">body</span>: <span class="tok-string">"Archivo no encontrado"</span>};
  }
  <span class="tok-keyword">if</span> (stats.isDirectory()) {
    <span class="tok-keyword">return</span> {<span class="tok-definition">body</span>: (<span class="tok-keyword">await</span> readdir(path)).join(<span class="tok-string">"</span><span class="tok-string2">\n</span><span class="tok-string">"</span>)};
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">return</span> {<span class="tok-definition">body</span>: createReadStream(path),
            <span class="tok-definition">type</span>: lookup(path)};
  }
};</pre><p><a class="p_ident" id="p-iYt4Ms5dC4" href="#p-iYt4Ms5dC4" tabindex="-1" role="presentation"></a>Dado que tiene que tocar el disco y por lo tanto podría llevar un tiempo, <code>stat</code> es asíncrono. Dado que estamos usando promesas en lugar del estilo de devolución de llamada, debe importarse desde <code>node:fs/promises</code> en lugar de directamente desde <code>node:fs</code>.</p>

<p><a class="p_ident" id="p-tdTunaPFS/" href="#p-tdTunaPFS/" tabindex="-1" role="presentation"></a>Cuando el archivo no existe, <code>stat</code> lanzará un objeto de error con una propiedad <code>code</code> de <code>"ENOENT"</code>. Estos códigos algo oscuros, inspirados en Unix, son cómo se reconocen los tipos de errores en Node.</p>

<p><a class="p_ident" id="p-f1+vCwgX9M" href="#p-f1+vCwgX9M" tabindex="-1" role="presentation"></a>El objeto <code>stats</code> devuelto por <code>stat</code> nos dice varias cosas sobre un archivo, como su tamaño (propiedad <code>size</code>) y su fecha de modificación (propiedad <code>mtime</code>). Aquí nos interesa la pregunta de si es un directorio o un archivo regular, lo cual nos dice el método <code>isDirectory</code>.</p>

<p><a class="p_ident" id="p-E8HtJSMMtj" href="#p-E8HtJSMMtj" tabindex="-1" role="presentation"></a>Usamos <code>readdir</code> para leer el array de archivos en un directorio y devolverlo al cliente. Para archivos normales, creamos un flujo legible con <code>createReadStream</code> y lo devolvemos como cuerpo, junto con el tipo de contenido que el paquete <code>mime</code> nos da para el nombre del archivo.</p>

<p><a class="p_ident" id="p-3SF21U54yR" href="#p-3SF21U54yR" tabindex="-1" role="presentation"></a>El código para manejar las solicitudes <code>DELETE</code> es ligeramente más simple.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-JlCZDm9eg3" href="#c-JlCZDm9eg3" tabindex="-1" role="presentation"></a><span class="tok-keyword">importar</span> {<span class="tok-definition">rmdir</span>, <span class="tok-definition">unlink</span>} <span class="tok-keyword">desde</span> <span class="tok-string">"node:fs/promises"</span>;

methods.DELETE = <span class="tok-keyword">async</span> <span class="tok-keyword">function</span>(<span class="tok-definition">solicitud</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">ruta</span> = urlPath(request.url);
  <span class="tok-keyword">let</span> <span class="tok-definition">stats</span>;
  <span class="tok-keyword">tratar</span> {
    stats = <span class="tok-keyword">await</span> stat(path);
  } <span class="tok-keyword">atrapar</span> (<span class="tok-definition">error</span>) {
    <span class="tok-keyword">si</span> (error.code != <span class="tok-string">"ENOENT"</span>) <span class="tok-keyword">lanzar</span> error;
    <span class="tok-keyword">sino</span> <span class="tok-keyword">regresar</span> {<span class="tok-definition">estado</span>: <span class="tok-number">204</span>};
  }
  <span class="tok-keyword">si</span> (stats.isDirectory()) <span class="tok-keyword">await</span> rmdir(path);
  <span class="tok-keyword">sino</span> <span class="tok-keyword">await</span> unlink(path);
  <span class="tok-keyword">regresar</span> {<span class="tok-definition">estado</span>: <span class="tok-number">204</span>};
};</pre><p><a class="p_ident" id="p-LTgtgu0j3m" href="#p-LTgtgu0j3m" tabindex="-1" role="presentation"></a>Cuando una respuesta HTTP no contiene ningún dato, el código de estado 204 ("sin contenido") se puede usar para indicar esto. Dado que la respuesta a la eliminación no necesita transmitir ninguna información más allá de si la operación tuvo éxito, tiene sentido devolver eso aquí.</p>

<p><a class="p_ident" id="p-1CFycX4t/q" href="#p-1CFycX4t/q" tabindex="-1" role="presentation"></a>Puede que te estés preguntando por qué intentar eliminar un archivo que no existe devuelve un código de estado de éxito, en lugar de un error. Cuando el archivo que se está eliminando no está ahí, se podría decir que el objetivo de la solicitud ya se ha cumplido. El estándar HTTP nos anima a hacer solicitudes <em>idempotentes</em>, lo que significa que hacer la misma solicitud varias veces produce el mismo resultado que hacerla una vez. De cierta manera, si intentas eliminar algo que ya no está, el efecto que intentabas lograr se ha alcanzado—la cosa ya no está allí.</p>

<p><a class="p_ident" id="p-q7xnjGCxyr" href="#p-q7xnjGCxyr" tabindex="-1" role="presentation"></a>Este es el controlador para las solicitudes <code>PUT</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-ChtmXskNos" href="#c-ChtmXskNos" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">createWriteStream</span>} <span class="tok-keyword">from</span> <span class="tok-string">"node:fs"</span>;

<span class="tok-keyword">function</span> <span class="tok-definition">pipeStream</span>(<span class="tok-definition">from</span>, <span class="tok-definition">to</span>) {
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Promise((<span class="tok-definition">resolve</span>, <span class="tok-definition">reject</span>) =&gt; {
    from.on(<span class="tok-string">"error"</span>, reject);
    to.on(<span class="tok-string">"error"</span>, reject);
    to.on(<span class="tok-string">"finish"</span>, resolve);
    from.pipe(to);
  });
}

methods.PUT = <span class="tok-keyword">async</span> <span class="tok-keyword">function</span>(<span class="tok-definition">request</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">path</span> = urlPath(request.url);
  <span class="tok-keyword">await</span> pipeStream(request, createWriteStream(path));
  <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">204</span>};
};</pre>

<p><a class="p_ident" id="p-VID3l4baJ4" href="#p-VID3l4baJ4" tabindex="-1" role="presentation"></a>No necesitamos verificar si el archivo existe esta vez—si lo hace, simplemente lo sobrescribiremos. Nuevamente usamos <code>pipe</code> para mover datos de un flujo legible a uno escribible, en este caso desde la solicitud al archivo. Pero como <code>pipe</code> no está diseñado para devolver una promesa, tenemos que escribir un envoltorio, <code>pipeStream</code>, que cree una promesa alrededor del resultado de llamar a <code>pipe</code>.</p><p><a class="p_ident" id="p-DGGAMEixPQ" href="#p-DGGAMEixPQ" tabindex="-1" role="presentation"></a>Cuando algo sale mal al abrir el archivo, <code>createWriteStream</code> seguirá devolviendo un stream, pero ese stream lanzará un evento <code>"error"</code>. El stream de la solicitud también puede fallar, por ejemplo si la red se cae. Por lo tanto, conectamos los eventos <code>"error"</code> de ambos streams para rechazar la promesa. Cuando la operación <code>pipe</code> se completa, se cierra el stream de salida, lo que provoca que lance un evento <code>"finish"</code>. Ese es el momento en el que podemos resolver exitosamente la promesa (sin devolver nada).</p>

<p><a class="p_ident" id="p-ig7HitKqRz" href="#p-ig7HitKqRz" tabindex="-1" role="presentation"></a>El script completo para el servidor está disponible en <a href="https://eloquentjavascript.net/code/file_server.mjs"><em>https://eloquentjavascript.net/code/file_server.mjs</em></a>. Puedes descargarlo y, después de instalar sus dependencias, ejecutarlo con Node para iniciar tu propio servidor de archivos. Y, por supuesto, puedes modificarlo y extenderlo para resolver los ejercicios de este capítulo o para experimentar.</p>

<p><a class="p_ident" id="p-fBFWTJncql" href="#p-fBFWTJncql" tabindex="-1" role="presentation"></a>La herramienta de línea de comandos <code>curl</code>, ampliamente disponible en sistemas tipo Unix (como macOS y Linux), se puede utilizar para hacer solicitudes HTTP. La siguiente sesión prueba brevemente nuestro servidor. La opción <code>-X</code> se usa para establecer el método de la solicitud, y <code>-d</code> se usa para incluir un cuerpo de solicitud.</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-qgxdz4oRrt" href="#c-qgxdz4oRrt" tabindex="-1" role="presentation"></a>$ curl http://localhost:8000/file.txt
Archivo no encontrado
$ curl -X PUT -d CONTENIDO http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
CONTENIDO
$ curl -X DELETE http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
Archivo no encontrado</pre>

<p><a class="p_ident" id="p-AmMFBJGSkb" href="#p-AmMFBJGSkb" tabindex="-1" role="presentation"></a>La primera solicitud para <code>file.txt</code> falla ya que el archivo aún no existe. La solicitud <code>PUT</code> crea el archivo, y voilà, la siguiente solicitud lo recupera exitosamente. Después de eliminarlo con una solicitud <code>DELETE</code>, el archivo vuelve a estar ausente.</p>

<h2><a class="h_ident" id="h-ErccPg/l98" href="#h-ErccPg/l98" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-aI1QIDZs29" href="#p-aI1QIDZs29" tabindex="-1" role="presentation"></a>Node es un sistema bonito y pequeño que nos permite ejecutar JavaScript en un contexto no navegador. Originalmente diseñado para tareas de red para desempeñar el papel de un <em>nodo</em> en una red. Pero se presta para todo tipo de tareas de script, y si te gusta escribir JavaScript, automatizar tareas con Node funciona bien.</p>

<p><a class="p_ident" id="p-MwBwTRGbNG" href="#p-MwBwTRGbNG" tabindex="-1" role="presentation"></a>NPM ofrece paquetes para todo lo que puedas imaginar (y bastantes cosas que probablemente nunca pensarías), y te permite obtener e instalar esos paquetes con el programa <code>npm</code>. Node viene con varios módulos integrados, incluido el módulo <code>node:fs</code> para trabajar con el sistema de archivos y el módulo <code>node:http</code> para ejecutar servidores HTTP.</p><p><a class="p_ident" id="p-Xy6fcZFlrO" href="#p-Xy6fcZFlrO" tabindex="-1" role="presentation"></a>Toda la entrada y salida en Node se realiza de forma asíncrona, a menos que uses explícitamente una variante síncrona de una función, como <code>readFileSync</code>. Inicialmente, Node utilizaba devoluciones de llamada para funcionalidades asíncronas, pero el paquete <code>node:fs/promises</code> proporciona una interfaz basada en promesas para el sistema de archivos.</p>

<h2><a class="h_ident" id="h-TcUD2vzyMe" href="#h-TcUD2vzyMe" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-9+y+iovU0J" href="#i-9+y+iovU0J" tabindex="-1" role="presentation"></a>Herramienta de búsqueda</h3>

<p><a class="p_ident" id="p-ca6ZBtGx1B" href="#p-ca6ZBtGx1B" tabindex="-1" role="presentation"></a>En sistemas Unix, existe una herramienta de línea de comandos llamada <code>grep</code> que se puede utilizar para buscar rápidamente archivos mediante una expresión regular.</p>

<p><a class="p_ident" id="p-SPdJt6R1Qc" href="#p-SPdJt6R1Qc" tabindex="-1" role="presentation"></a>Escribe un script de Node que se pueda ejecutar desde la línea de comandos y funcione de manera similar a <code>grep</code>. Trata el primer argumento de la línea de comandos como una expresión regular y trata cualquier argumento adicional como archivos a buscar. Debe mostrar los nombres de los archivos cuyo contenido coincida con la expresión regular.</p>

<p><a class="p_ident" id="p-W1JsnLA2+S" href="#p-W1JsnLA2+S" tabindex="-1" role="presentation"></a>Cuando eso funcione, extiéndelo para que cuando uno de los argumentos sea un directorio, busque en todos los archivos de ese directorio y sus subdirectorios.</p>

<p><a class="p_ident" id="p-y4ht4tsxKI" href="#p-y4ht4tsxKI" tabindex="-1" role="presentation"></a>Utiliza funciones asíncronas o síncronas del sistema de archivos según lo consideres apropiado. Configurar las cosas para que se soliciten múltiples acciones asíncronas al mismo tiempo podría acelerar un poco las cosas, pero no en gran medida, ya que la mayoría de los sistemas de archivos solo pueden leer una cosa a la vez.</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-iPJi2aEAkj" href="#p-iPJi2aEAkj" tabindex="-1" role="presentation"></a>Tu primer argumento de la línea de comandos, la expresión regular, se puede encontrar en <code>process.argv[2]</code>. Los archivos de entrada vienen después de eso. Puedes usar el constructor <code>RegExp</code> para convertir una cadena en un objeto de expresión regular.</p>

<p><a class="p_ident" id="p-24MnW7A2/l" href="#p-24MnW7A2/l" tabindex="-1" role="presentation"></a>Hacer esto de forma síncrona, con <code>readFileSync</code>, es más directo, pero si usas <code>node:fs/promises</code> para obtener funciones que devuelven promesas y escribes una función <code>async</code>, el código se ve similar.</p>

<p><a class="p_ident" id="p-r0XgnA8VK0" href="#p-r0XgnA8VK0" tabindex="-1" role="presentation"></a>Para determinar si algo es un directorio, nuevamente puedes usar <code>stat</code> (o <code>statSync</code>) y el método <code>isDirectory</code> del objeto de estadísticas.</p>

<p><a class="p_ident" id="p-KiWSClPPul" href="#p-KiWSClPPul" tabindex="-1" role="presentation"></a>Explorar un directorio es un proceso de ramificación. Puedes hacerlo usando una función recursiva o manteniendo una matriz de trabajo (archivos que aún deben ser explorados). Para encontrar los archivos en un directorio, puedes llamar a <code>readdir</code> o <code>readdirSync</code>. Observa la extraña capitalización: la nomenclatura de las funciones del sistema de archivos de Node se basa vagamente en las funciones estándar de Unix, como <code>readdir</code>, que son todas en minúsculas, pero luego agrega <code>Sync</code> con una letra mayúscula.</p><p><a class="p_ident" id="p-Aq7fsBfKsj" href="#p-Aq7fsBfKsj" tabindex="-1" role="presentation"></a>Para convertir un nombre de archivo leído con <code>readdir</code> a un nombre de ruta completo, debes combinarlo con el nombre del directorio, ya sea poniendo <code>sep</code> de <code>node:path</code> entre ellos, o utilizando la función <code>join</code> de ese mismo paquete.</p>

</div></details>

<h3><a class="i_ident" id="i-h8iNiA8ezX" href="#i-h8iNiA8ezX" tabindex="-1" role="presentation"></a>Creación de directorios</h3>

<p><a class="p_ident" id="p-eKscmrM/cp" href="#p-eKscmrM/cp" tabindex="-1" role="presentation"></a>Aunque el método <code>DELETE</code> en nuestro servidor de archivos puede eliminar directorios (usando <code>rmdir</code>), actualmente el servidor no proporciona ninguna forma de <em>crear</em> un directorio.</p>

<p><a class="p_ident" id="p-GpjSLUJk84" href="#p-GpjSLUJk84" tabindex="-1" role="presentation"></a>Agrega soporte para el método <code>MKCOL</code> (“make collection”), que debería crear un directorio llamando a <code>mkdir</code> desde el módulo <code>node:fs</code>. <code>MKCOL</code> no es un método HTTP ampliamente utilizado, pero existe con el mismo propósito en el estándar <em>WebDAV</em>, que especifica un conjunto de convenciones sobre HTTP que lo hacen adecuado para crear documentos.</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-Ptyerm4lHs" href="#p-Ptyerm4lHs" tabindex="-1" role="presentation"></a>Puedes usar la función que implementa el método <code>DELETE</code> como un modelo para el método <code>MKCOL</code>. Cuando no se encuentra ningún archivo, intenta crear un directorio con <code>mkdir</code>. Cuando existe un directorio en esa ruta, puedes devolver una respuesta 204 para que las solicitudes de creación de directorios sean idempotentes. Si existe un archivo que no es un directorio aquí, devuelve un código de error. El código 400 (“solicitud incorrecta”) sería apropiado.</p>

</div></details>

<h3><a class="i_ident" id="i-TLRTlwK6ZU" href="#i-TLRTlwK6ZU" tabindex="-1" role="presentation"></a>Un espacio público en la web</h3>

<p><a class="p_ident" id="p-vTdeqF/5aL" href="#p-vTdeqF/5aL" tabindex="-1" role="presentation"></a>Dado que el servidor de archivos sirve cualquier tipo de archivo e incluso incluye la cabecera <code>Content-Type</code> correcta, puedes usarlo para servir un sitio web. Dado que permite a todos eliminar y reemplazar archivos, sería un tipo de sitio web interesante: uno que puede ser modificado, mejorado y vandalizado por todos los que se tomen el tiempo de hacer la solicitud HTTP correcta.</p>

<p><a class="p_ident" id="p-S5RQ8T3sNn" href="#p-S5RQ8T3sNn" tabindex="-1" role="presentation"></a>Escribe una página HTML básica que incluya un archivo JavaScript simple. Coloca los archivos en un directorio servido por el servidor de archivos y ábrelos en tu navegador.</p>

<p><a class="p_ident" id="p-UerJ/YohV1" href="#p-UerJ/YohV1" tabindex="-1" role="presentation"></a>A continuación, como ejercicio avanzado o incluso como proyecto de fin de semana, combina todo el conocimiento que obtuviste de este libro para construir una interfaz más amigable para modificar el sitio web—desde <em>dentro</em> del sitio web.</p><p><a class="p_ident" id="p-PMJCxe07g5" href="#p-PMJCxe07g5" tabindex="-1" role="presentation"></a>Utiliza un formulario HTML para editar el contenido de los archivos que conforman el sitio web, permitiendo al usuario actualizarlos en el servidor mediante solicitudes HTTP, según se describe en <a href="18_http.html">Capítulo 18</a>.</p>

<p><a class="p_ident" id="p-hWSA1+odAv" href="#p-hWSA1+odAv" tabindex="-1" role="presentation"></a>Comienza haciendo que solo un archivo sea editable. Luego permite al usuario seleccionar qué archivo editar. Usa el hecho de que nuestro servidor de archivos devuelve listas de archivos al leer un directorio.</p>

<p><a class="p_ident" id="p-5JDgu6tuAT" href="#p-5JDgu6tuAT" tabindex="-1" role="presentation"></a>No trabajes directamente en el código expuesto por el servidor de archivos, ya que si cometes un error, es probable que dañes los archivos allí. En su lugar, realiza tu trabajo fuera del directorio de acceso público y copia allí cuando estés probando.</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-v9JKMD5WJI" href="#p-v9JKMD5WJI" tabindex="-1" role="presentation"></a>Puedes crear un elemento <code>&lt;textarea&gt;</code> para contener el contenido del archivo que se está editando. Una solicitud <code>GET</code>, usando <code>fetch</code>, puede recuperar el contenido actual del archivo. Puedes usar URLs relativas como <em>index.html</em>, en lugar de <a href="http://localhost:8000/index.html"><em>http://localhost:8000/index.html</em></a>, para referirte a archivos en el mismo servidor que el script en ejecución.</p>

<p><a class="p_ident" id="p-AddxfNwTA3" href="#p-AddxfNwTA3" tabindex="-1" role="presentation"></a>Luego, cuando el usuario hace clic en un botón (puedes usar un elemento <code>&lt;form&gt;</code> y el evento <code>"submit"</code>), realiza una solicitud <code>PUT</code> a la misma URL, con el contenido del <code>&lt;textarea&gt;</code> como cuerpo de la solicitud, para guardar el archivo.</p>

<p><a class="p_ident" id="p-LI3MHsPkwQ" href="#p-LI3MHsPkwQ" tabindex="-1" role="presentation"></a>Luego puedes añadir un elemento <code>&lt;select&gt;</code> que contenga todos los archivos en el directorio raíz del servidor agregando elementos <code>&lt;option&gt;</code> que contengan las líneas devueltas por una solicitud <code>GET</code> a la URL <code>/</code>. Cuando el usuario seleccione otro archivo (un evento <code>"change"</code> en el campo), el script debe recuperar y mostrar ese archivo. Al guardar un archivo, usa el nombre de archivo actualmente seleccionado.</p>

</div></details><nav><a href="19_paint.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="21_skillsharing.html" title="próximo capítulo" aria-label="próximo capítulo">▸</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>
</article>

<script src="js/ejs.js"></script>
</body></html>
<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Valores, Tipos y Operadores :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="css/ejs.css"><script>
      var page = {"type":"chapter","number":1}</script></head>

<body><article>
<nav><a href="00_intro.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="02_program_structure.html" title="próximo capítulo" aria-label="próximo capítulo">▸</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>

<h1>Valores, Tipos y Operadores</h1>

<blockquote>

<p><a class="p_ident" id="p-93S4YBaGUf" href="#p-93S4YBaGUf" tabindex="-1" role="presentation"></a>Debajo de la superficie de la máquina, el programa se mueve. Sin esfuerzo, se expande y contrae. En gran armonía, los electrones se dispersan y se reagrupan. Las formas en el monitor son solo ondulaciones sobre el agua. La esencia permanece invisiblemente abajo.</p>

<footer>Maestro Yuan-Ma, <cite>El Libro de la Programación</cite></footer>

</blockquote><figure class="chapter framed"><img src="images/chapter_picture_1.jpg" alt="Ilustración de un mar de puntos oscuros y brillantes (bits) con islas en él"></figure>

<p><a class="p_ident" id="p-zX5VpoZKoK" href="#p-zX5VpoZKoK" tabindex="-1" role="presentation"></a>En el mundo de la computadora, solo existen datos. Puedes leer datos, modificar datos, crear nuevos datos, pero aquello que no es dato no puede ser mencionado. Todos estos datos se almacenan como largas secuencias de bits y, por lo tanto, son fundamentalmente iguales.</p>

<p><a class="p_ident" id="p-W1gJpe5a7/" href="#p-W1gJpe5a7/" tabindex="-1" role="presentation"></a><em>Bits</em> son cualquier tipo de cosas de dos valores, generalmente descritas como ceros y unos. Dentro de la computadora, toman formas como una carga eléctrica alta o baja, una señal fuerte o débil, o un punto brillante o opaco en la superficie de un CD. Cualquier pieza de información discreta puede reducirse a una secuencia de ceros y unos y, por lo tanto, representarse en bits.</p>

<p><a class="p_ident" id="p-PDoqiRoGSa" href="#p-PDoqiRoGSa" tabindex="-1" role="presentation"></a>Por ejemplo, podemos expresar el número 13 en bits. Esto funciona de la misma manera que un número decimal, pero en lugar de 10 dígitos diferentes, solo tenemos 2, y el peso de cada uno aumenta por un factor de 2 de derecha a izquierda. Aquí están los bits que componen el número 13, con los pesos de los dígitos mostrados debajo de ellos:</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-+fMMNc3yUt" href="#c-+fMMNc3yUt" tabindex="-1" role="presentation"></a>   0   0   0   0   1   1   0   1
 128  64  32  16   8   4   2   1</pre>

<p><a class="p_ident" id="p-ZHgrWKXJ6A" href="#p-ZHgrWKXJ6A" tabindex="-1" role="presentation"></a>Ese es el número binario 00001101. Sus dígitos no nulos representan 8, 4 y 1, y suman 13.</p>

<h2><a class="h_ident" id="h-sVZPaxUSy/" href="#h-sVZPaxUSy/" tabindex="-1" role="presentation"></a>Valores</h2><p><a class="p_ident" id="p-ySnc2wG5kf" href="#p-ySnc2wG5kf" tabindex="-1" role="presentation"></a>Imagina un mar de bits, un océano de ellos. Un computador moderno típico tiene más de 100 mil millones de bits en su almacenamiento de datos volátil (memoria de trabajo). El almacenamiento no volátil (el disco duro o equivalente) tiende a tener unas cuantas órdenes de magnitud más.</p>

<p><a class="p_ident" id="p-JRdY+sw4TV" href="#p-JRdY+sw4TV" tabindex="-1" role="presentation"></a>Para poder trabajar con tales cantidades de bits sin perderse, los separamos en fragmentos que representan piezas de información. En un entorno de JavaScript, esos fragmentos se llaman <em>valores</em>. Aunque todos los valores están hechos de bits, desempeñan roles diferentes. Cada valor tiene un tipo que determina su función. Algunos valores son números, algunos valores son fragmentos de texto, algunos valores son funciones, y así sucesivamente.</p>

<p><a class="p_ident" id="p-+ayfFmFdze" href="#p-+ayfFmFdze" tabindex="-1" role="presentation"></a>Para crear un valor, simplemente debes invocar su nombre. Esto es conveniente. No tienes que reunir materiales de construcción para tus valores ni pagar por ellos. Solo llamas a uno, y <em>zas</em>, lo tienes. Por supuesto, los valores no se crean realmente de la nada. Cada uno debe almacenarse en algún lugar, y si quieres usar una cantidad gigantesca de ellos al mismo tiempo, podrías quedarte sin memoria de computador. Afortunadamente, este es un problema solo si los necesitas todos simultáneamente. Tan pronto como dejes de usar un valor, se disipará, dejando sus bits atrás para ser reciclados como material de construcción para la próxima generación de valores.</p>

<p><a class="p_ident" id="p-wayGTXjTs5" href="#p-wayGTXjTs5" tabindex="-1" role="presentation"></a>El resto de este capítulo introduce los elementos atómicos de los programas de JavaScript, es decir, los tipos de valores simples y los operadores que pueden actuar sobre dichos valores.</p>

<h2><a class="h_ident" id="h-flOCH3CuFg" href="#h-flOCH3CuFg" tabindex="-1" role="presentation"></a>Números</h2>

<p><a class="p_ident" id="p-lB/BspzEbz" href="#p-lB/BspzEbz" tabindex="-1" role="presentation"></a>Los valores del tipo <em>número</em> son, como era de esperar, valores numéricos. En un programa de JavaScript, se escriben de la siguiente manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-/u5ErTZbax" href="#c-/u5ErTZbax" tabindex="-1" role="presentation"></a><span class="tok-number">13</span></pre>

<p><a class="p_ident" id="p-FfoImV0xfL" href="#p-FfoImV0xfL" tabindex="-1" role="presentation"></a>Usar eso en un programa hará que el patrón de bits del número 13 cobre vida dentro de la memoria de la computadora.</p>

<p><a class="p_ident" id="p-TBpgYLjzVr" href="#p-TBpgYLjzVr" tabindex="-1" role="presentation"></a>JavaScript utiliza un número fijo de bits, 64 de ellos, para almacenar un único valor numérico. Solo hay tantos patrones que puedes crear con 64 bits, lo que limita la cantidad de números diferentes que se pueden representar. Con <em>N</em> dígitos decimales, puedes representar 10<sup>N</sup> números. De manera similar, dado 64 dígitos binarios, puedes representar 2<sup>64</sup> números diferentes, que son alrededor de 18 trillones (un 18 seguido de 18 ceros). Eso es mucho.</p><p><a class="p_ident" id="p-WcfWpTcQB6" href="#p-WcfWpTcQB6" tabindex="-1" role="presentation"></a>La memoria de las computadoras solía ser mucho más pequeña, y la gente solía usar grupos de 8 o 16 bits para representar sus números. Era fácil desbordar accidentalmente estos pequeños números, llegar a un número que no cabía en la cantidad de bits dada. Hoy en día, incluso las computadoras que caben en tu bolsillo tienen mucha memoria, por lo que puedes utilizar trozos de 64 bits, y solo necesitas preocuparte por el desbordamiento cuando lidias con números verdaderamente astronómicos.</p>

<p><a class="p_ident" id="p-qgS+bpqvEk" href="#p-qgS+bpqvEk" tabindex="-1" role="presentation"></a>No todos los números enteros inferiores a 18 cuatrillones caben en un número de JavaScript. Esos bits también almacenan números negativos, por lo que un bit indica el signo del número. Un problema mayor es representar números no enteros. Para hacer esto, algunos de los bits se utilizan para almacenar la posición del punto decimal. El máximo número entero real que se puede almacenar está más en el rango de 9 cuatrillones (15 ceros), lo cual sigue siendo sorprendentemente enorme.</p>

<p><a class="p_ident" id="p-+wzyK91zcb" href="#p-+wzyK91zcb" tabindex="-1" role="presentation"></a>Los números fraccionarios se escriben usando un punto:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-tM8nqv41Gp" href="#c-tM8nqv41Gp" tabindex="-1" role="presentation"></a><span class="tok-number">9.81</span></pre>

<p><a class="p_ident" id="p-j34c/ZU9g4" href="#p-j34c/ZU9g4" tabindex="-1" role="presentation"></a>Para números muy grandes o muy pequeños, también puedes usar la notación científica agregando una <em>e</em> (de <em>exponente</em>), seguido por el exponente del número:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-6ew5w+VhSM" href="#c-6ew5w+VhSM" tabindex="-1" role="presentation"></a><span class="tok-number">2.998e8</span></pre>

<p><a class="p_ident" id="p-X49AdXyL/c" href="#p-X49AdXyL/c" tabindex="-1" role="presentation"></a>Eso es 2.998 × 10<sup>8</sup> = 299,800,000.</p>

<p><a class="p_ident" id="p-8KgYC0F1fX" href="#p-8KgYC0F1fX" tabindex="-1" role="presentation"></a>Los cálculos con números enteros (también llamados <em>enteros</em>) que son más pequeños que los mencionados 9 cuatrillones están garantizados de ser siempre precisos. Desafortunadamente, los cálculos con números fraccionarios generalmente no lo son. Así como π (pi) no puede ser expresado con precisión por un número finito de dígitos decimales, muchos números pierden algo de precisión cuando solo se dispone de 64 bits para almacenarlos. Esto es una lástima, pero solo causa problemas prácticos en situaciones específicas. Lo importante es ser consciente de ello y tratar los números digitales fraccionarios como aproximaciones, no como valores precisos.</p>

<h3><a class="i_ident" id="i-RfBT3HMnYs" href="#i-RfBT3HMnYs" tabindex="-1" role="presentation"></a>Aritmética</h3>

<p><a class="p_ident" id="p-PO8MaZIpG1" href="#p-PO8MaZIpG1" tabindex="-1" role="presentation"></a>La principal tarea que se hace con los números es la aritmética. Las operaciones aritméticas como la suma o la multiplicación toman dos valores numéricos y producen un nuevo número a partir de ellos. Así es cómo se ven en JavaScript:</p><pre tabindex="0" class="snippet" data-language="javascript" data-meta="expr"><a class="c_ident" id="c-bSU4Vtv/mt" href="#c-bSU4Vtv/mt" tabindex="-1" role="presentation"></a><span class="tok-number">100</span> + <span class="tok-number">4</span> * <span class="tok-number">11</span></pre>

<p><a class="p_ident" id="p-OLlk8/LnDv" href="#p-OLlk8/LnDv" tabindex="-1" role="presentation"></a>The <code>+</code> and <code>*</code> symbols are called <em>operators</em>. The first stands for addition and the second stands for multiplication. Putting an operator between two values will apply it to those values and produce a new value.</p>

<p><a class="p_ident" id="p-EY6ktK2+fi" href="#p-EY6ktK2+fi" tabindex="-1" role="presentation"></a>Does this example mean “Add 4 and 100, and multiply the result by 11”, or is the multiplication done before the adding? As you might have guessed, the multiplication happens first. As in mathematics, you can change this by wrapping the addition in parentheses:</p>

<pre tabindex="0" class="snippet" data-language="javascript" data-meta="expr"><a class="c_ident" id="c-ij6V90ZZBQ" href="#c-ij6V90ZZBQ" tabindex="-1" role="presentation"></a>(<span class="tok-number">100</span> + <span class="tok-number">4</span>) * <span class="tok-number">11</span></pre>

<p><a class="p_ident" id="p-qti+2j7Cn8" href="#p-qti+2j7Cn8" tabindex="-1" role="presentation"></a>For subtraction, there is the <code>-</code> operator. Division can be done with the <code>/</code> operator.</p>

<p><a class="p_ident" id="p-KHUto8GJVD" href="#p-KHUto8GJVD" tabindex="-1" role="presentation"></a>When operators appear together without parentheses, the order in which they are applied is determined by the <em>precedence</em> of the operators. The example shows that multiplication comes before addition. The <code>/</code> operator has the same precedence as <code>*</code>. Likewise, <code>+</code> and <code>-</code> have the same precedence. When multiple operators with the same precedence appear next to each other, as in <code>1 - 2 + 1</code>, they are applied left to right: <code>(1 - 2) + 1</code>.</p>

<p><a class="p_ident" id="p-RmRGPzYhvc" href="#p-RmRGPzYhvc" tabindex="-1" role="presentation"></a>Don’t worry too much about these precedence rules. When in doubt, just add parentheses.</p>

<p><a class="p_ident" id="p-3aZxtaabKD" href="#p-3aZxtaabKD" tabindex="-1" role="presentation"></a>There is one more arithmetic operator, which you might not immediately recognize. The <code>%</code> symbol is used to represent the <em>remainder</em> operation. <code>X % Y</code> is the remainder of dividing <code>X</code> by <code>Y</code>. For example, <code>314 % 100</code> produces <code>14</code>, and <code>144 % 12</code> gives <code>0</code>. The remainder operator’s precedence is the same as that of multiplication and division. You’ll also often see this operator referred to as <em>modulo</em>.</p>

<h3><a class="i_ident" id="i-R4eFf8w7Yz" href="#i-R4eFf8w7Yz" tabindex="-1" role="presentation"></a>Números especiales</h3><p><a class="p_ident" id="p-Bacszidv2d" href="#p-Bacszidv2d" tabindex="-1" role="presentation"></a>Existen tres valores especiales en JavaScript que se consideran números pero no se comportan como números normales. Los primeros dos son <code>Infinity</code> y <code>-Infinity</code>, que representan el infinito positivo y negativo. <code>Infinity - 1</code> sigue siendo <code>Infinity</code>, y así sucesivamente. Sin embargo, no confíes demasiado en el cálculo basado en infinitos. No es matemáticamente sólido y rápidamente te llevará al siguiente número especial: <code>NaN</code>.</p>

<p><a class="p_ident" id="p-pEEsuk9SRv" href="#p-pEEsuk9SRv" tabindex="-1" role="presentation"></a><code>NaN</code> significa "no es un número", aunque <em>sí</em> es un valor del tipo número. Obtendrás este resultado cuando, por ejemplo, intentes calcular <code>0 / 0</code> (cero dividido entre cero), <code>Infinity - Infinity</code>, o cualquier otra operación numérica que no genere un resultado significativo.</p>

<h2><a class="h_ident" id="h-OBbEvqxHHH" href="#h-OBbEvqxHHH" tabindex="-1" role="presentation"></a>Cadenas de texto</h2>

<p><a class="p_ident" id="p-JUYnmsnZEA" href="#p-JUYnmsnZEA" tabindex="-1" role="presentation"></a>El siguiente tipo de dato básico es la <em>cadena de texto</em>. Las cadenas de texto se utilizan para representar texto. Se escriben encerrando su contenido entre comillas.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-JcfC82q1V/" href="#c-JcfC82q1V/" tabindex="-1" role="presentation"></a><span class="tok-string2">`En el mar`</span>
<span class="tok-string">"Acostado en el océano"</span>
<span class="tok-string">'Flotar en el océano'</span></pre>

<p><a class="p_ident" id="p-GM9mNOoSjF" href="#p-GM9mNOoSjF" tabindex="-1" role="presentation"></a>Puedes usar comillas simples, comillas dobles o acentos graves para delimitar las cadenas de texto, siempre y cuando las comillas al inicio y al final de la cadena coincidan.</p>

<p><a class="p_ident" id="p-UmL1LLMXbi" href="#p-UmL1LLMXbi" tabindex="-1" role="presentation"></a>Puedes poner casi cualquier cosa entre comillas para que JavaScript convierta en un valor de cadena. Sin embargo, algunos caracteres son más difíciles. Puedes imaginar lo complicado que sería poner comillas entre comillas, ya que parecerían el final de la cadena. Los <em>saltos de línea</em> (los caracteres que obtienes al presionar <span class="keyname">enter</span>) solo se pueden incluir cuando la cadena está entre acentos graves (<code>`</code>).</p>

<p><a class="p_ident" id="p-Fhyuks46v3" href="#p-Fhyuks46v3" tabindex="-1" role="presentation"></a>Para poder incluir esos caracteres especiales en una cadena, se utiliza la siguiente notación: una barra invertida (<code>\</code>) dentro del texto citado indica que el carácter que le sigue tiene un significado especial. Esto se llama <em>escapar</em> el carácter. Una comilla que precede una barra invertida no terminará la cadena, sino que formará parte de ella. Cuando aparece la letra <code>n</code> después de una barra invertida, se interpreta como un salto de línea. De manera similar, una letra <code>t</code> después de una barra invertida significa un carácter de tabulación. Toma la siguiente cadena como ejemplo:</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-L1XyfWLjvh" href="#c-L1XyfWLjvh" tabindex="-1" role="presentation"></a><span class="tok-string">"Esta es la primera línea</span><span class="tok-string2">\n</span><span class="tok-string">Y esta es la segunda"</span></pre>

<p><a class="p_ident" id="p-3mOdI8rIFO" href="#p-3mOdI8rIFO" tabindex="-1" role="presentation"></a>This is the actual text is that string:</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-dbS7S3Fqly" href="#c-dbS7S3Fqly" tabindex="-1" role="presentation"></a>This is the first line
And this is the second</pre>

<p><a class="p_ident" id="p-RcQxEVsohZ" href="#p-RcQxEVsohZ" tabindex="-1" role="presentation"></a>There are, of course, situations where you want a backslash in a string to be just a backslash, not a special code. If two backslashes follow each other, they will collapse together, and only one will be left in the resulting string value. This is how the string “<em>A newline character is written like <code>"</code>\n<code>"</code>.</em>” can be expressed:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-AuMrnbfo/X" href="#c-AuMrnbfo/X" tabindex="-1" role="presentation"></a><span class="tok-string">"Un carácter de nueva línea se escribe como </span><span class="tok-string2">\"</span><span class="tok-string2">\\</span><span class="tok-string">n</span><span class="tok-string2">\"</span><span class="tok-string">."</span></pre>

<p id="unicode"><a class="p_ident" id="p-OPaEHGZKME" href="#p-OPaEHGZKME" tabindex="-1" role="presentation"></a>Strings, too, have to be modeled as a series of bits to be able to exist inside the computer. The way JavaScript does this is based on the <em>Unicode</em> standard. This standard assigns a number to virtually every character you would ever need, including characters from Greek, Arabic, Japanese, Armenian, and so on. If we have a number for every character, a string can be described by a sequence of numbers. And that’s what JavaScript does.</p>

<p><a class="p_ident" id="p-R0NFw5Jly5" href="#p-R0NFw5Jly5" tabindex="-1" role="presentation"></a>There’s a complication though: JavaScript’s representation uses 16 bits per string element, which can describe up to 2<sup>16</sup> different characters. However, Unicode defines more characters than that—about twice as many, at this point. So some characters, such as many emoji, take up two “character positions” in JavaScript strings. We’ll come back to this in <a href="05_higher_order.html#code_units">Chapter 5</a>.</p>

<p><a class="p_ident" id="p-bmbZetnxDH" href="#p-bmbZetnxDH" tabindex="-1" role="presentation"></a>Strings cannot be divided, multiplied, or subtracted. The <code>+</code> operator <em>can</em> be used on them, not to add, but to <em>concatenate</em>—to glue two strings together. The following line will produce the string <code>"concatenate"</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript" data-meta="expr"><a class="c_ident" id="c-eCO7oekmP9" href="#c-eCO7oekmP9" tabindex="-1" role="presentation"></a><span class="tok-string">"con"</span> + <span class="tok-string">"cat"</span> + <span class="tok-string">"e"</span> + <span class="tok-string">"nate"</span></pre><p><a class="p_ident" id="p-1+aqkpsjX3" href="#p-1+aqkpsjX3" tabindex="-1" role="presentation"></a>Los valores de cadenas tienen una serie de funciones asociadas (<em>métodos</em>) que se pueden utilizar para realizar otras operaciones con ellas. Hablaré más sobre esto en <a href="04_data.html#methods">Capítulo 4</a>.</p>

<p><a class="p_ident" id="p-3NJXrCLWRR" href="#p-3NJXrCLWRR" tabindex="-1" role="presentation"></a>Las cadenas escritas con comillas simples o dobles se comportan de manera muy similar; la única diferencia radica en qué tipo de comilla necesitas escapar dentro de ellas. Las cadenas entre acentos graves, generalmente llamadas <em>template literals</em>, pueden hacer algunas trucos adicionales. Además de poder abarcar varias líneas, también pueden incrustar otros valores.</p>

<pre tabindex="0" class="snippet" data-language="javascript" data-meta="expr"><a class="c_ident" id="c-1ObyeNEDOw" href="#c-1ObyeNEDOw" tabindex="-1" role="presentation"></a><span class="tok-string2">`la mitad de 100 es </span>${<span class="tok-number">100</span> / <span class="tok-number">2</span>}<span class="tok-string2">`</span></pre>

<p><a class="p_ident" id="p-ogkFBzzZhi" href="#p-ogkFBzzZhi" tabindex="-1" role="presentation"></a>Cuando escribes algo dentro de <code>${}</code> en un template literal, su resultado será calculado, convertido a cadena e incluido en esa posición. Este ejemplo produce "<em>la mitad de 100 es 50</em>".</p>

<h2><a class="h_ident" id="h-ygn12/ieo+" href="#h-ygn12/ieo+" tabindex="-1" role="presentation"></a>Operadores unarios</h2>

<p><a class="p_ident" id="p-GyQlmgK5IK" href="#p-GyQlmgK5IK" tabindex="-1" role="presentation"></a>No todos los operadores son símbolos. Algunos se escriben como palabras. Un ejemplo es el operador <code>typeof</code>, que produce un valor de cadena que nombra el tipo del valor que le das.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-iWT//VyY7j" href="#c-iWT//VyY7j" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">typeof</span> <span class="tok-number">4.5</span>)
<span class="tok-comment">// → number</span>
console.log(<span class="tok-keyword">typeof</span> <span class="tok-string">"x"</span>)
<span class="tok-comment">// → string</span></pre>

<p id="console.log"><a class="p_ident" id="p-Jo1uVMEBho" href="#p-Jo1uVMEBho" tabindex="-1" role="presentation"></a>Usaremos <code>console.log</code> en ejemplos de código para indicar que queremos ver el resultado de evaluar algo. Más sobre esto en el <a href="02_program_structure.html">próximo capítulo</a>.</p>

<p><a class="p_ident" id="p-j8F6SrKjF/" href="#p-j8F6SrKjF/" tabindex="-1" role="presentation"></a>Los otros operadores mostrados hasta ahora en este capítulo han operado en dos valores, pero <code>typeof</code> toma solo uno. Los operadores que usan dos valores se llaman operadores <em>binarios</em>, mientras que los que toman uno se llaman operadores <em>unarios</em>. El operador menos se puede usar tanto como un operador binario como un operador unario.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-VpL89RFAPj" href="#c-VpL89RFAPj" tabindex="-1" role="presentation"></a>console.log(- (<span class="tok-number">10</span> - <span class="tok-number">2</span>))
<span class="tok-comment">// → -8</span></pre><h2><a class="h_ident" id="h-cTPxJxlmFR" href="#h-cTPxJxlmFR" tabindex="-1" role="presentation"></a>Valores booleanos</h2>

<p><a class="p_ident" id="p-OL3ZufvGRE" href="#p-OL3ZufvGRE" tabindex="-1" role="presentation"></a>A menudo es útil tener un valor que distinga sólo entre dos posibilidades, como "sí" y "no" o "encendido" y "apagado". Para este propósito, JavaScript tiene un tipo <em>Booleano</em>, que tiene solo dos valores, true y false, escritos como esas palabras.</p>

<h3><a class="i_ident" id="i-Lfz4mKO9Tg" href="#i-Lfz4mKO9Tg" tabindex="-1" role="presentation"></a>Comparación</h3>

<p><a class="p_ident" id="p-T4yLn4fXDH" href="#p-T4yLn4fXDH" tabindex="-1" role="presentation"></a>Aquí hay una forma de producir valores booleanos:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-GaxnXrIPwC" href="#c-GaxnXrIPwC" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">3</span> &gt; <span class="tok-number">2</span>)
<span class="tok-comment">// → true</span>
console.log(<span class="tok-number">3</span> &lt; <span class="tok-number">2</span>)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-j0tOwzfb6M" href="#p-j0tOwzfb6M" tabindex="-1" role="presentation"></a>Los signos <code>&gt;</code> y <code>&lt;</code> son los símbolos tradicionales para "es mayor que" y "es menor que", respectivamente. Son operadores binarios. Aplicarlos resulta en un valor booleano que indica si son verdaderos en este caso.</p>

<p><a class="p_ident" id="p-NxTGvCsM4s" href="#p-NxTGvCsM4s" tabindex="-1" role="presentation"></a>Las cadenas se pueden comparar de la misma manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Qud5plnVuV" href="#c-Qud5plnVuV" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"Aardvark"</span> &lt; <span class="tok-string">"Zoroaster"</span>)
<span class="tok-comment">// → true</span></pre>

<p><a class="p_ident" id="p-No3uOP/bY2" href="#p-No3uOP/bY2" tabindex="-1" role="presentation"></a>La forma en que se ordenan las cadenas es aproximadamente alfabética pero no es realmente lo que uno esperaría ver en un diccionario: las letras mayúsculas son siempre "menos" que las minúsculas, por lo que <code>"Z" &lt; "a"</code>, y los caracteres no alfabéticos (!, -, y así sucesivamente) también se incluyen en el orden. Al comparar cadenas, JavaScript recorre los caracteres de izquierda a derecha, comparando los códigos Unicode uno por uno.</p>

<p><a class="p_ident" id="p-fGKTuK5BBc" href="#p-fGKTuK5BBc" tabindex="-1" role="presentation"></a>Otros operadores similares son <code>&gt;=</code> (mayor o igual que), <code>&lt;=</code> (menor o igual que), <code>==</code> (igual que), y <code>!=</code> (no igual que).</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-v1IZKKCCaz" href="#c-v1IZKKCCaz" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"Garnet"</span> != <span class="tok-string">"Ruby"</span>)
<span class="tok-comment">// → true</span>
console.log(<span class="tok-string">"Pearl"</span> == <span class="tok-string">"Amethyst"</span>)
<span class="tok-comment">// → false</span></pre><p><a class="p_ident" id="p-tLooHn2QPj" href="#p-tLooHn2QPj" tabindex="-1" role="presentation"></a>En JavaScript, solo hay un valor que no es igual a sí mismo, y ese es <code>NaN</code> (“no es un número”).</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Vhz09Rgw3h" href="#c-Vhz09Rgw3h" tabindex="-1" role="presentation"></a>console.log(NaN == NaN)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-AllzHp+z6n" href="#p-AllzHp+z6n" tabindex="-1" role="presentation"></a><code>NaN</code> se supone que denota el resultado de un cálculo sin sentido, y como tal, no es igual al resultado de ningún otro cálculo sin sentido.</p>

<h3><a class="i_ident" id="i-pdqDW7Pebo" href="#i-pdqDW7Pebo" tabindex="-1" role="presentation"></a>Operadores lógicos</h3>

<p><a class="p_ident" id="p-nRCLrGwcCn" href="#p-nRCLrGwcCn" tabindex="-1" role="presentation"></a>También hay algunas operaciones que se pueden aplicar a los valores booleanos mismos. JavaScript soporta tres operadores lógicos: <em>and</em> (y), <em>or</em> (o) y <em>not</em> (no). Estos se pueden usar para "razonar" sobre los booleanos.</p>

<p><a class="p_ident" id="p-h6pEyNS4IJ" href="#p-h6pEyNS4IJ" tabindex="-1" role="presentation"></a>El operador <code>&amp;&amp;</code> representa el <em>and</em> lógico. Es un operador binario, y su resultado es verdadero solo si ambos valores dados son verdaderos.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-SHi38sNkwM" href="#c-SHi38sNkwM" tabindex="-1" role="presentation"></a>console.log(true &amp;&amp; false)
<span class="tok-comment">// → false</span>
console.log(true &amp;&amp; true)
<span class="tok-comment">// → true</span></pre>

<p><a class="p_ident" id="p-T/V30CHY82" href="#p-T/V30CHY82" tabindex="-1" role="presentation"></a>El operador <code>||</code> denota el <em>or</em> lógico. Produce verdadero si alguno de los valores dados es verdadero.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-diXyv7iPd1" href="#c-diXyv7iPd1" tabindex="-1" role="presentation"></a>console.log(false || true)
<span class="tok-comment">// → true</span>
console.log(false || false)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-OxH3G7iBRz" href="#p-OxH3G7iBRz" tabindex="-1" role="presentation"></a><em>Not</em> se escribe como un signo de exclamación (<code>!</code>). Es un operador unario que invierte el valor dado, <code>!true</code> produce <code>false</code> y <code>!false</code> da <code>true</code>.</p>

<p><a class="p_ident" id="p-qSXjNNI5/y" href="#p-qSXjNNI5/y" tabindex="-1" role="presentation"></a>Cuando se mezclan estos operadores booleanos con operadores aritméticos y otros, no siempre es obvio cuándo se necesitan paréntesis. En la práctica, generalmente puedes saber que de los operadores que hemos visto hasta ahora, <code>||</code> tiene la menor precedencia, luego viene <code>&amp;&amp;</code>, luego los operadores de comparación (<code>&gt;</code>, <code>==</code>, y así sucesivamente), y luego el resto. Este orden ha sido elegido de tal manera que, en expresiones típicas como la siguiente, se necesiten la menor cantidad de paréntesis posible:</p><pre tabindex="0" class="snippet" data-language="javascript" data-meta="expr"><a class="c_ident" id="c-6eZ07bDo11" href="#c-6eZ07bDo11" tabindex="-1" role="presentation"></a><span class="tok-number">1</span> + <span class="tok-number">1</span> == <span class="tok-number">2</span> &amp;&amp; <span class="tok-number">10</span> * <span class="tok-number">10</span> &gt; <span class="tok-number">50</span></pre>

<p><a class="p_ident" id="p-EWJu4coIAh" href="#p-EWJu4coIAh" tabindex="-1" role="presentation"></a>El último operador lógico que veremos no es unario, no es binario, sino <em>ternario</em>, operando en tres valores. Se escribe con un signo de interrogación y dos puntos, así:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-G7eVm8ilWm" href="#c-G7eVm8ilWm" tabindex="-1" role="presentation"></a>console.log(true ? <span class="tok-number">1</span> : <span class="tok-number">2</span>);
<span class="tok-comment">// → 1</span>
console.log(false ? <span class="tok-number">1</span> : <span class="tok-number">2</span>);
<span class="tok-comment">// → 2</span></pre>

<p><a class="p_ident" id="p-RoDBOvicaj" href="#p-RoDBOvicaj" tabindex="-1" role="presentation"></a>A este se le llama el operador <em>condicional</em> (o a veces solo <em>el operador ternario</em> ya que es el único operador de este tipo en el lenguaje). El operador utiliza el valor a la izquierda del signo de interrogación para decidir entre los otros dos valores a "seleccionar". Si escribes <code>a ? b : c</code>, el resultado será <code>b</code> cuando <code>a</code> es verdadero y <code>c</code> de lo contrario.</p>

<h2><a class="h_ident" id="h-FewqJ8K2E+" href="#h-FewqJ8K2E+" tabindex="-1" role="presentation"></a>Valores vacíos</h2>

<p><a class="p_ident" id="p-Q/OIPtr8xY" href="#p-Q/OIPtr8xY" tabindex="-1" role="presentation"></a>Existen dos valores especiales, escritos <code>null</code> y <code>undefined</code>, que se utilizan para denotar la ausencia de un valor <em>significativo</em>. Ellos mismos son valores, pero no llevan información.</p>

<p><a class="p_ident" id="p-HKYk2Oxaf6" href="#p-HKYk2Oxaf6" tabindex="-1" role="presentation"></a>Muchas operaciones en el lenguaje que no producen un valor significativo devuelven <code>undefined</code> simplemente porque tienen que devolver <em>algún</em> valor.</p>

<p><a class="p_ident" id="p-43ZLcQuUDk" href="#p-43ZLcQuUDk" tabindex="-1" role="presentation"></a>La diferencia en el significado entre <code>undefined</code> y <code>null</code> es un accidente del diseño de JavaScript, y la mayoría del tiempo no importa. En casos donde realmente tienes que preocuparte por estos valores, recomiendo tratarlos como casi intercambiables.</p>

<h2><a class="h_ident" id="h-AY+YGu6qyM" href="#h-AY+YGu6qyM" tabindex="-1" role="presentation"></a>Conversión automática de tipos</h2>

<p><a class="p_ident" id="p-I6CpHrk6+W" href="#p-I6CpHrk6+W" tabindex="-1" role="presentation"></a>En la Introducción, mencioné que JavaScript se esfuerza por aceptar casi cualquier programa que le des, incluso programas que hacen cosas extrañas. Esto se demuestra claramente con las siguientes expresiones:</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-QqYG9KqZ2/" href="#c-QqYG9KqZ2/" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">8</span> * <span class="tok-keyword">null</span>)
<span class="tok-comment">// → 0</span>
console.log(<span class="tok-string">"5"</span> - <span class="tok-number">1</span>)
<span class="tok-comment">// → 4</span>
console.log(<span class="tok-string">"5"</span> + <span class="tok-number">1</span>)
<span class="tok-comment">// → 51</span>
console.log(<span class="tok-string">"five"</span> * <span class="tok-number">2</span>)
<span class="tok-comment">// → NaN</span>
console.log(false == <span class="tok-number">0</span>)
<span class="tok-comment">// → true</span></pre>

<p><a class="p_ident" id="p-kjH0rNN5jK" href="#p-kjH0rNN5jK" tabindex="-1" role="presentation"></a>When an operator is appliquée to the "wrong" de valuación, JavaScript volontiers convertissez that de valuación to the tipo it nécessite, using a set of règles that souvent aren't what you deseo or esperar. This is llamado type coercion. The <code>null</code> in the first expresión de valuación becomes <code>0</code> and el <code>"5"</code> in the second expresión de valuación becomes <code>5</code> (from string to number). Yet in the third expresión de valuación, <code>+</code> essais string concaténation before numeric addition, so the <code>1</code> is convertido to <code>"1"</code> (from number to string).</p>

<p><a class="p_ident" id="p-mw5To5JJ6Q" href="#p-mw5To5JJ6Q" tabindex="-1" role="presentation"></a>When something that doesn't mapear to a número in an evidente way (such as <code>"five"</code> or <code>undefined</code>) is convertido to a número, you obtiene the valor <code>NaN</code>. Further operaciones aritméticas on <code>NaN</code> keep producing <code>NaN</code>, so if you find yourself obtener one of those in an inesperado lugar, look for accidental type conversions.</p>

<p><a class="p_ident" id="p-XbK88HE+DJ" href="#p-XbK88HE+DJ" tabindex="-1" role="presentation"></a>When comparando valores of the mismo tipo using the <code>==</code> operator, the resultado is fácil to prever: you should get true when both valores are the mismo, except en the caso de <code>NaN</code>. But when the tipos diffieren, JavaScript uses a complicado and confuso set of règles to determinar what to do. In la mayoría de los casos, it juste try to convertir one of the valores to the otro valor's tipo. However, when <code>null</code> or <code>undefined</code> occurs on either lado of the operator, it produces true only if both lados son one of <code>null</code> or <code>undefined</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-qmGDPdETlf" href="#c-qmGDPdETlf" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">null</span> == undefined);
<span class="tok-comment">// → true</span>
console.log(<span class="tok-keyword">null</span> == <span class="tok-number">0</span>);
<span class="tok-comment">// → false</span></pre><p><a class="p_ident" id="p-hu+ZqjMro3" href="#p-hu+ZqjMro3" tabindex="-1" role="presentation"></a>Ese comportamiento suele ser útil. Cuando deseas probar si un valor tiene un valor real en lugar de <code>null</code> o <code>undefined</code>, puedes compararlo con <code>null</code> usando los operadores <code>==</code> o <code>!=</code>.</p>

<p><a class="p_ident" id="p-GBtHgkKgjk" href="#p-GBtHgkKgjk" tabindex="-1" role="presentation"></a>¿Qué sucede si deseas probar si algo se refiere al valor preciso <code>false</code>? Expresiones como <code>0 == false</code> y <code>"" == false</code> también son verdaderas debido a la conversión automática de tipos. Cuando no deseas que ocurran conversiones de tipos, existen dos operadores adicionales: <code>===</code> y <code>!==</code>. El primero prueba si un valor es <em>precisamente</em> igual al otro, y el segundo prueba si no es precisamente igual. Así que <code>"" === false</code> es falso como se esperaba.</p>

<p><a class="p_ident" id="p-S/opLpHJcU" href="#p-S/opLpHJcU" tabindex="-1" role="presentation"></a>Recomiendo usar los operadores de comparación de tres caracteres defensivamente para prevenir conversiones de tipos inesperadas que puedan confundirte. Pero cuando estás seguro de que los tipos en ambos lados serán los mismos, no hay problema en usar los operadores más cortos.</p>

<h3><a class="i_ident" id="i-3jN0iK4yKW" href="#i-3jN0iK4yKW" tabindex="-1" role="presentation"></a>Cortocircuito de operadores lógicos</h3>

<p><a class="p_ident" id="p-CFbagJsQYK" href="#p-CFbagJsQYK" tabindex="-1" role="presentation"></a>Los operadores lógicos <code>&amp;&amp;</code> y <code>||</code> manejan valores de diferentes tipos de una manera peculiar. Convertirán el valor de su lado izquierdo a tipo booleano para decidir qué hacer, pero dependiendo del operador y el resultado de esa conversión, devolverán ya sea el valor original del lado izquierdo o el valor del lado derecho.</p>

<p><a class="p_ident" id="p-BFq+/JeBH9" href="#p-BFq+/JeBH9" tabindex="-1" role="presentation"></a>El operador <code>||</code>, por ejemplo, devolverá el valor a su izquierda cuando ese valor pueda ser convertido a verdadero y devolverá el valor a su derecha de lo contrario. Esto tiene el efecto esperado cuando los valores son booleanos y hace algo análogo para valores de otros tipos.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-ENjxHGMklb" href="#c-ENjxHGMklb" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">null</span> || <span class="tok-string">"usuario"</span>)
<span class="tok-comment">// → usuario</span>
console.log(<span class="tok-string">"Agnes"</span> || <span class="tok-string">"usuario"</span>)
<span class="tok-comment">// → Agnes</span></pre>

<p><a class="p_ident" id="p-+E3wg/b+ti" href="#p-+E3wg/b+ti" tabindex="-1" role="presentation"></a>Podemos usar esta funcionalidad como una forma de recurrir a un valor predeterminado. Si tienes un valor que podría estar vacío, puedes colocar <code>||</code> después de él con un valor de reemplazo. Si el valor inicial se puede convertir a falso, obtendrás el reemplazo en su lugar. Las reglas para convertir cadenas y números en valores booleanos indican que <code>0</code>, <code>NaN</code> y la cadena vacía (<code>""</code>) cuentan como <code>false</code>, mientras que todos los demás valores cuentan como <code>true</code>. Eso significa que <code>0 || -1</code> produce <code>-1</code>, y <code>"" || "!?"</code> produce <code>"!?"</code>.</p><p><a class="p_ident" id="p-PFWfVIoFiH" href="#p-PFWfVIoFiH" tabindex="-1" role="presentation"></a>El operador <code>??</code> se parece a <code>||</code>, pero devuelve el valor a la derecha sólo si el de la izquierda es nulo o indefinido, y no si es algún otro valor que pueda convertirse a <code>false</code>. A menudo, este comportamiento es preferible al de <code>||</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-UVdLwFRz8U" href="#c-UVdLwFRz8U" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">0</span> || <span class="tok-number">100</span>);
<span class="tok-comment">// → 100</span>
console.log(<span class="tok-number">0</span> ?? <span class="tok-number">100</span>);
<span class="tok-comment">// → 0</span>
console.log(<span class="tok-keyword">null</span> ?? <span class="tok-number">100</span>);
<span class="tok-comment">// → 100</span></pre>

<p><a class="p_ident" id="p-LlkwKHpB6u" href="#p-LlkwKHpB6u" tabindex="-1" role="presentation"></a>El operador <code>&amp;&amp;</code> funciona de manera similar pero a la inversa. Cuando el valor a su izquierda es algo que se convierte en falso, devuelve ese valor; de lo contrario, devuelve el valor a su derecha.</p>

<p><a class="p_ident" id="p-IW4V8ztNjs" href="#p-IW4V8ztNjs" tabindex="-1" role="presentation"></a>Otra propiedad importante de estos dos operadores es que la parte a su derecha se evalúa solo cuando es necesario. En el caso de <code>true || X</code>, no importa lo que sea <code>X</code>, incluso si es un trozo de programa que hace algo <em>terrible</em>, el resultado será verdadero y <code>X</code> nunca se evaluará. Lo mismo sucede con <code>false &amp;&amp; X</code>, que es falso e ignorará <code>X</code>. Esto se llama <em>evaluación de cortocircuito</em>.</p>

<p><a class="p_ident" id="p-WW6GFa4Qbm" href="#p-WW6GFa4Qbm" tabindex="-1" role="presentation"></a>El operador condicional funciona de manera similar. De los dos valores segundo y tercero, solo se evalúa el que es seleccionado.</p>

<h2><a class="h_ident" id="h-ErccPg/l98" href="#h-ErccPg/l98" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-+X/MKfUuhz" href="#p-+X/MKfUuhz" tabindex="-1" role="presentation"></a>En este capítulo vimos cuatro tipos de valores en JavaScript: números, cadenas de texto, booleanos y valores indefinidos. Estos valores se crean escribiendo su nombre (<code>true</code>, <code>null</code>) o valor (<code>13</code>, <code>"abc"</code>).</p>

<p><a class="p_ident" id="p-GblDDYUSHr" href="#p-GblDDYUSHr" tabindex="-1" role="presentation"></a>Puedes combinar y transformar valores con operadores. Vimos operadores binarios para aritmética (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, y <code>%</code>), concatenación de cadenas (<code>+</code>), comparación (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>), y lógicos (<code>&amp;&amp;</code>, <code>||</code>, <code>??</code>), así como varios operadores unarios (<code>-</code> para negar un número, <code>!</code> para negar lógicamente y <code>typeof</code> para encontrar el tipo de un valor) y un operador ternario (<code>?:</code>) para elegir uno de dos valores basado en un tercer valor.</p><p><a class="p_ident" id="p-WHkzsJyNsJ" href="#p-WHkzsJyNsJ" tabindex="-1" role="presentation"></a>Esto te proporciona suficiente información para usar JavaScript como una calculadora de bolsillo, pero no mucho más. El <a href="02_program_structure.html">próximo capítulo</a> comenzará a unir estas expresiones en programas básicos.</p><nav><a href="00_intro.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="02_program_structure.html" title="próximo capítulo" aria-label="próximo capítulo">▸</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>
</article>

<script src="js/ejs.js"></script>
</body></html>
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Valores, Tipos y Operadores :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="css/ejs.css">
  <script>
    var page = { "type": "chapter", "number": 1 }</script>
</head>

<body>
  <article>
    <nav><a href="00_intro.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a
        href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="02_program_structure.html"
        title="próximo capítulo" aria-label="próximo capítulo">▸</a>&nbsp;<button class="help" title="ayuda"
        aria-label="ayuda"><strong>?</strong></button>
    </nav>

    <h1>Valores, Tipos y Operadores</h1>

    <blockquote>

      <p><a class="p_ident" id="p-93S4YBaGUf" href="#p-93S4YBaGUf" tabindex="-1" role="presentation"></a>Debajo de la
        superficie de la máquina, el programa se mueve. Sin esfuerzo, se expande y contrae. En gran armonía, los
        electrones se dispersan y se reagrupan. Las formas en el monitor son solo ondulaciones sobre el agua. La esencia
        permanece invisiblemente abajo.</p>

      <footer>Maestro Yuan-Ma, <cite>El Libro de la Programación</cite></footer>

    </blockquote>
    <figure class="chapter framed"><img src="images/chapter_picture_1.jpg"
        alt="Ilustración de un mar de puntos oscuros y brillantes (bits) con islas en él"></figure>

    <p><a class="p_ident" id="p-zX5VpoZKoK" href="#p-zX5VpoZKoK" tabindex="-1" role="presentation"></a>En el mundo de la
      computadora, solo existen datos. Puedes leer datos, modificar datos, crear nuevos datos, pero aquello que no es
      dato no puede ser mencionado. Todos estos datos se almacenan como largas secuencias de bits y, por lo tanto, son
      fundamentalmente iguales.</p>

    <p><a class="p_ident" id="p-W1gJpe5a7/" href="#p-W1gJpe5a7/" tabindex="-1" role="presentation"></a><em>Bits</em> son
      cualquier tipo de cosas de dos valores, generalmente descritas como ceros y unos. Dentro de la computadora, toman
      formas como una carga eléctrica alta o baja, una señal fuerte o débil, o un punto brillante o opaco en la
      superficie de un CD. Cualquier pieza de información discreta puede reducirse a una secuencia de ceros y unos y,
      por lo tanto, representarse en bits.</p>

    <p><a class="p_ident" id="p-PDoqiRoGSa" href="#p-PDoqiRoGSa" tabindex="-1" role="presentation"></a>Por ejemplo,
      podemos expresar el número 13 en bits. Esto funciona de la misma manera que un número decimal, pero en lugar de 10
      dígitos diferentes, solo tenemos 2, y el peso de cada uno aumenta por un factor de 2 de derecha a izquierda. Aquí
      están los bits que componen el número 13, con los pesos de los dígitos mostrados debajo de ellos:</p>

    <pre class="snippet" data-language="null"><a class="c_ident" id="c-+fMMNc3yUt" href="#c-+fMMNc3yUt" tabindex="-1" role="presentation"></a>   0   0   0   0   1   1   0   1
 128  64  32  16   8   4   2   1</pre>

    <p><a class="p_ident" id="p-ZHgrWKXJ6A" href="#p-ZHgrWKXJ6A" tabindex="-1" role="presentation"></a>Ese es el número
      binario 00001101. Sus dígitos no nulos representan 8, 4 y 1, y suman 13.</p>

    <h2><a class="h_ident" id="h-sVZPaxUSy/" href="#h-sVZPaxUSy/" tabindex="-1" role="presentation"></a>Valores</h2>
    <p><a class="p_ident" id="p-ySnc2wG5kf" href="#p-ySnc2wG5kf" tabindex="-1" role="presentation"></a>Imagina un mar de
      bits, un océano de ellos. Un computador moderno típico tiene más de 100 mil millones de bits en su almacenamiento
      de datos volátil (memoria de trabajo). El almacenamiento no volátil (el disco duro o equivalente) tiende a tener
      unas cuantas órdenes de magnitud más.</p>

    <p><a class="p_ident" id="p-JRdY+sw4TV" href="#p-JRdY+sw4TV" tabindex="-1" role="presentation"></a>Para poder
      trabajar con tales cantidades de bits sin perderse, los separamos en fragmentos que representan piezas de
      información. En un entorno de JavaScript, esos fragmentos se llaman <em>valores</em>. Aunque todos los valores
      están hechos de bits, desempeñan roles diferentes. Cada valor tiene un tipo que determina su función. Algunos
      valores son números, algunos valores son fragmentos de texto, algunos valores son funciones, y así sucesivamente.
    </p>

    <p><a class="p_ident" id="p-+ayfFmFdze" href="#p-+ayfFmFdze" tabindex="-1" role="presentation"></a>Para crear un
      valor, simplemente debes invocar su nombre. Esto es conveniente. No tienes que reunir materiales de construcción
      para tus valores ni pagar por ellos. Solo llamas a uno, y <em>zas</em>, lo tienes. Por supuesto, los valores no se
      crean realmente de la nada. Cada uno debe almacenarse en algún lugar, y si quieres usar una cantidad gigantesca de
      ellos al mismo tiempo, podrías quedarte sin memoria de computador. Afortunadamente, este es un problema solo si
      los necesitas todos simultáneamente. Tan pronto como dejes de usar un valor, se disipará, dejando sus bits atrás
      para ser reciclados como material de construcción para la próxima generación de valores.</p>

    <p><a class="p_ident" id="p-wayGTXjTs5" href="#p-wayGTXjTs5" tabindex="-1" role="presentation"></a>El resto de este
      capítulo introduce los elementos atómicos de los programas de JavaScript, es decir, los tipos de valores simples y
      los operadores que pueden actuar sobre dichos valores.</p>

    <h2><a class="h_ident" id="h-flOCH3CuFg" href="#h-flOCH3CuFg" tabindex="-1" role="presentation"></a>Números</h2>

    <p><a class="p_ident" id="p-lB/BspzEbz" href="#p-lB/BspzEbz" tabindex="-1" role="presentation"></a>Los valores del
      tipo <em>número</em> son, como era de esperar, valores numéricos. En un programa de JavaScript, se escriben de la
      siguiente manera:</p>

    <pre tabindex="0" class="snippet"
      data-language="javascript"><a class="c_ident" id="c-/u5ErTZbax" href="#c-/u5ErTZbax" tabindex="-1" role="presentation"></a><span class="tok-number">13</span></pre>

    <p><a class="p_ident" id="p-FfoImV0xfL" href="#p-FfoImV0xfL" tabindex="-1" role="presentation"></a>Usar eso en un
      programa hará que el patrón de bits del número 13 cobre vida dentro de la memoria de la computadora.</p>

    <p><a class="p_ident" id="p-TBpgYLjzVr" href="#p-TBpgYLjzVr" tabindex="-1" role="presentation"></a>JavaScript
      utiliza un número fijo de bits, 64 de ellos, para almacenar un único valor numérico. Solo hay tantos patrones que
      puedes crear con 64 bits, lo que limita la cantidad de números diferentes que se pueden representar. Con
      <em>N</em> dígitos decimales, puedes representar 10<sup>N</sup> números. De manera similar, dado 64 dígitos
      binarios, puedes representar 2<sup>64</sup> números diferentes, que son alrededor de 18 trillones (un 18 seguido
      de 18 ceros). Eso es mucho.
    </p>
    <p><a class="p_ident" id="p-WcfWpTcQB6" href="#p-WcfWpTcQB6" tabindex="-1" role="presentation"></a>La memoria de las
      computadoras solía ser mucho más pequeña, y la gente solía usar grupos de 8 o 16 bits para representar sus
      números. Era fácil desbordar accidentalmente estos pequeños números, llegar a un número que no cabía en la
      cantidad de bits dada. Hoy en día, incluso las computadoras que caben en tu bolsillo tienen mucha memoria, por lo
      que puedes utilizar trozos de 64 bits, y solo necesitas preocuparte por el desbordamiento cuando lidias con
      números verdaderamente astronómicos.</p>

    <p><a class="p_ident" id="p-qgS+bpqvEk" href="#p-qgS+bpqvEk" tabindex="-1" role="presentation"></a>No todos los
      números enteros inferiores a 18 cuatrillones caben en un número de JavaScript. Esos bits también almacenan números
      negativos, por lo que un bit indica el signo del número. Un problema mayor es representar números no enteros. Para
      hacer esto, algunos de los bits se utilizan para almacenar la posición del punto decimal. El máximo número entero
      real que se puede almacenar está más en el rango de 9 cuatrillones (15 ceros), lo cual sigue siendo
      sorprendentemente enorme.</p>

    <p><a class="p_ident" id="p-+wzyK91zcb" href="#p-+wzyK91zcb" tabindex="-1" role="presentation"></a>Los números
      fraccionarios se escriben usando un punto:</p>

    <pre tabindex="0" class="snippet"
      data-language="javascript"><a class="c_ident" id="c-tM8nqv41Gp" href="#c-tM8nqv41Gp" tabindex="-1" role="presentation"></a><span class="tok-number">9.81</span></pre>

    <p><a class="p_ident" id="p-j34c/ZU9g4" href="#p-j34c/ZU9g4" tabindex="-1" role="presentation"></a>Para números muy
      grandes o muy pequeños, también puedes usar la notación científica agregando una <em>e</em> (de
      <em>exponente</em>), seguido por el exponente del número:
    </p>

    <pre tabindex="0" class="snippet"
      data-language="javascript"><a class="c_ident" id="c-6ew5w+VhSM" href="#c-6ew5w+VhSM" tabindex="-1" role="presentation"></a><span class="tok-number">2.998e8</span></pre>

    <p><a class="p_ident" id="p-X49AdXyL/c" href="#p-X49AdXyL/c" tabindex="-1" role="presentation"></a>Eso es 2.998 ×
      10<sup>8</sup> = 299,800,000.</p>

    <p><a class="p_ident" id="p-8KgYC0F1fX" href="#p-8KgYC0F1fX" tabindex="-1" role="presentation"></a>Los cálculos con
      números enteros (también llamados <em>enteros</em>) que son más pequeños que los mencionados 9 cuatrillones están
      garantizados de ser siempre precisos. Desafortunadamente, los cálculos con números fraccionarios generalmente no
      lo son. Así como π (pi) no puede ser expresado con precisión por un número finito de dígitos decimales, muchos
      números pierden algo de precisión cuando solo se dispone de 64 bits para almacenarlos. Esto es una lástima, pero
      solo causa problemas prácticos en situaciones específicas. Lo importante es ser consciente de ello y tratar los
      números digitales fraccionarios como aproximaciones, no como valores precisos.</p>

    <h3><a class="i_ident" id="i-RfBT3HMnYs" href="#i-RfBT3HMnYs" tabindex="-1" role="presentation"></a>Aritmética</h3>

    <p><a class="p_ident" id="p-PO8MaZIpG1" href="#p-PO8MaZIpG1" tabindex="-1" role="presentation"></a>La principal
      tarea que se hace con los números es la aritmética. Las operaciones aritméticas como la suma o la multiplicación
      toman dos valores numéricos y producen un nuevo número a partir de ellos. Así es cómo se ven en JavaScript:</p>
    <pre tabindex="0" class="snippet" data-language="javascript"
      data-meta="expr"><a class="c_ident" id="c-bSU4Vtv/mt" href="#c-bSU4Vtv/mt" tabindex="-1" role="presentation"></a><span class="tok-number">100</span> + <span class="tok-number">4</span> * <span class="tok-number">11</span></pre>

    <p><a class="p_ident" id="p-OLlk8/LnDv" href="#p-OLlk8/LnDv" tabindex="-1" role="presentation"></a>Los símbolos
      <code>+</code> y <code>*</code> se llaman <em>operadores</em>. El primero representa la adición y el segundo la
      multiplicación. Poner un operador entre dos valores los aplicará a esos valores y producirá un nuevo valor.
    </p>

    <p><a class="p_ident" id="p-EY6ktK2+fi" href="#p-EY6ktK2+fi" tabindex="-1" role="presentation"></a>¿Significa este
      ejemplo "Sumar 4 y 100, y multiplicar el resultado por 11", o se realiza la multiplicación antes que la suma? Como
      podrías haber adivinado, la multiplicación ocurre primero. Como en matemáticas, puedes cambiar esto envolviendo la
      suma en paréntesis:</p>

    <pre tabindex="0" class="snippet" data-language="javascript"
      data-meta="expr"><a class="c_ident" id="c-ij6V90ZZBQ" href="#c-ij6V90ZZBQ" tabindex="-1" role="presentation"></a>(<span class="tok-number">100</span> + <span class="tok-number">4</span>) * <span class="tok-number">11</span></pre>

    <p><a class="p_ident" id="p-qti+2j7Cn8" href="#p-qti+2j7Cn8" tabindex="-1" role="presentation"></a>Para la
      sustracción, está el operador <code>-</code>. La división se puede realizar con el operador <code>/</code>.</p>

    <p><a class="p_ident" id="p-KHUto8GJVD" href="#p-KHUto8GJVD" tabindex="-1" role="presentation"></a>Cuando los
      operadores aparecen juntos sin paréntesis, el orden en que se aplican está determinado por la <em>precedencia</em>
      de los operadores. El ejemplo muestra que la multiplicación viene antes que la adición. El operador <code>/</code>
      tiene la misma precedencia que <code>*</code>. Del mismo modo, <code>+</code> y <code>-</code> tienen la misma
      precedencia. Cuando varios operadores con la misma precedencia aparecen uno al lado del otro, como en
      <code>1 - 2 + 1</code>, se aplican de izquierda a derecha: <code>(1 - 2) + 1</code>.
    </p>

    <p><a class="p_ident" id="p-RmRGPzYhvc" href="#p-RmRGPzYhvc" tabindex="-1" role="presentation"></a>No te preocupes
      demasiado por estas reglas de precedencia. Cuando tengas dudas, simplemente agrega paréntesis.</p>

    <p><a class="p_ident" id="p-3aZxtaabKD" href="#p-3aZxtaabKD" tabindex="-1" role="presentation"></a>Hay un operador
      aritmético más, que quizás no reconozcas inmediatamente. El símbolo <code>%</code> se utiliza para representar la
      operación de <em>resto</em>. <code>X % Y</code> es el resto de dividir <code>X</code> por <code>Y</code>. Por
      ejemplo, <code>314 % 100</code> produce <code>14</code>, y <code>144 % 12</code> da <code>0</code>. La precedencia
      del operador de resto es la misma que la de la multiplicación y división. A menudo verás este operador referido
      como <em>módulo</em>.</p>


    <h3><a class="i_ident" id="i-R4eFf8w7Yz" href="#i-R4eFf8w7Yz" tabindex="-1" role="presentation"></a>Números
      especiales</h3>
    <p><a class="p_ident" id="p-Bacszidv2d" href="#p-Bacszidv2d" tabindex="-1" role="presentation"></a>Existen tres
      valores especiales en JavaScript que se consideran números pero no se comportan como números normales. Los
      primeros dos son <code>Infinity</code> y <code>-Infinity</code>, que representan el infinito positivo y negativo.
      <code>Infinity - 1</code> sigue siendo <code>Infinity</code>, y así sucesivamente. Sin embargo, no confíes
      demasiado en el cálculo basado en infinitos. No es matemáticamente sólido y rápidamente te llevará al siguiente
      número especial: <code>NaN</code>.
    </p>

    <p><a class="p_ident" id="p-pEEsuk9SRv" href="#p-pEEsuk9SRv" tabindex="-1" role="presentation"></a><code>NaN</code>
      significa "no es un número", aunque <em>sí</em> es un valor del tipo número. Obtendrás este resultado cuando, por
      ejemplo, intentes calcular <code>0 / 0</code> (cero dividido entre cero), <code>Infinity - Infinity</code>, o
      cualquier otra operación numérica que no genere un resultado significativo.</p>

    <h2><a class="h_ident" id="h-OBbEvqxHHH" href="#h-OBbEvqxHHH" tabindex="-1" role="presentation"></a>Cadenas de texto
    </h2>

    <p><a class="p_ident" id="p-JUYnmsnZEA" href="#p-JUYnmsnZEA" tabindex="-1" role="presentation"></a>El siguiente tipo
      de dato básico es la <em>cadena de texto</em>. Las cadenas de texto se utilizan para representar texto. Se
      escriben encerrando su contenido entre comillas.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-JcfC82q1V/" href="#c-JcfC82q1V/" tabindex="-1" role="presentation"></a><span class="tok-string2">`En el mar`</span>
<span class="tok-string">"Acostado en el océano"</span>
<span class="tok-string">'Flotar en el océano'</span></pre>

    <p><a class="p_ident" id="p-GM9mNOoSjF" href="#p-GM9mNOoSjF" tabindex="-1" role="presentation"></a>Puedes usar
      comillas simples, comillas dobles o acentos graves para delimitar las cadenas de texto, siempre y cuando las
      comillas al inicio y al final de la cadena coincidan.</p>

    <p><a class="p_ident" id="p-UmL1LLMXbi" href="#p-UmL1LLMXbi" tabindex="-1" role="presentation"></a>Puedes poner casi
      cualquier cosa entre comillas para que JavaScript convierta en un valor de cadena. Sin embargo, algunos caracteres
      son más difíciles. Puedes imaginar lo complicado que sería poner comillas entre comillas, ya que parecerían el
      final de la cadena. Los <em>saltos de línea</em> (los caracteres que obtienes al presionar <span
        class="keyname">enter</span>) solo se pueden incluir cuando la cadena está entre acentos graves
      (<code>`</code>).</p>

    <p><a class="p_ident" id="p-Fhyuks46v3" href="#p-Fhyuks46v3" tabindex="-1" role="presentation"></a>Para poder
      incluir esos caracteres especiales en una cadena, se utiliza la siguiente notación: una barra invertida
      (<code>\</code>) dentro del texto citado indica que el carácter que le sigue tiene un significado especial. Esto
      se llama <em>escapar</em> el carácter. Una comilla que precede una barra invertida no terminará la cadena, sino
      que formará parte de ella. Cuando aparece la letra <code>n</code> después de una barra invertida, se interpreta
      como un salto de línea. De manera similar, una letra <code>t</code> después de una barra invertida significa un
      carácter de tabulación. Toma la siguiente cadena como ejemplo:</p>
    <pre tabindex="0" class="snippet"
      data-language="javascript"><a class="c_ident" id="c-L1XyfWLjvh" href="#c-L1XyfWLjvh" tabindex="-1" role="presentation"></a><span class="tok-string">"Esta es la primera línea</span><span class="tok-string2">\n</span><span class="tok-string">Y esta es la segunda"</span></pre>

    <p><a class="p_ident" id="p-3mOdI8rIFO" href="#p-3mOdI8rIFO" tabindex="-1" role="presentation"></a>Este es el texto
      real de esa cadena:</p>

    <pre class="snippet" data-language="null"><a class="c_ident" id="c-dbS7S3Fqly" href="#c-dbS7S3Fqly" tabindex="-1" role="presentation"></a>This is the first line
And this is the second</pre>

    <p><a class="p_ident" id="p-RcQxEVsohZ" href="#p-RcQxEVsohZ" tabindex="-1" role="presentation"></a>Existen, por
      supuesto, situaciones donde quieres que una barra invertida en una cadena sea simplemente una barra invertida, y
      no un código especial. Si dos barras invertidas se siguen una a otra, se colapsarán juntas, y solo una quedará en
      el valor de la cadena resultante. Así es como se puede expresar la cadena “<em>Un carácter de nueva línea se
        escribe como <code>"</code>\n<code>"</code>.</em>”:</p>

    <pre tabindex="0" class="snippet"
      data-language="javascript"><a class="c_ident" id="c-AuMrnbfo/X" href="#c-AuMrnbfo/X" tabindex="-1" role="presentation"></a><span class="tok-string">"Un carácter de nueva línea se escribe como </span><span class="tok-string2">\"</span><span class="tok-string2">\\</span><span class="tok-string">n</span><span class="tok-string2">\"</span><span class="tok-string">."</span></pre>

    <p id="unicode"><a class="p_ident" id="p-OPaEHGZKME" href="#p-OPaEHGZKME" tabindex="-1" role="presentation"></a>Las
      cadenas también deben modelarse como una serie de bits para poder existir dentro de la computadora. La forma en
      que JavaScript hace esto se basa en el estándar <em>Unicode</em>. Este estándar asigna un número a prácticamente
      cada carácter que necesitarías, incluidos caracteres del griego, árabe, japonés, armenio, y así sucesivamente. Si
      tenemos un número para cada carácter, una cadena puede describirse mediante una secuencia de números. Y eso es lo
      que hace JavaScript.</p>

    <p><a class="p_ident" id="p-R0NFw5Jly5" href="#p-R0NFw5Jly5" tabindex="-1" role="presentation"></a>Hay una
      complicación, sin embargo: la representación de JavaScript usa 16 bits por elemento de cadena, lo que puede
      describir hasta 2<sup>16</sup> caracteres diferentes. Sin embargo, Unicode define más caracteres que
      esos—alrededor del doble, en este punto. Así que algunos caracteres, como muchos emoji, ocupan dos “posiciones de
      carácter” en las cadenas de JavaScript. Volveremos a esto en <a href="05_higher_order.html#code_units">Capítulo
        5</a>.</p>

    <p><a class="p_ident" id="p-bmbZetnxDH" href="#p-bmbZetnxDH" tabindex="-1" role="presentation"></a>Las cadenas no
      pueden dividirse, multiplicarse o restarse. El operador <code>+</code> <em>puede</em> usarse con ellas, no para
      sumar, sino para <em>concatenar</em>—para unir dos cadenas juntas. La siguiente línea producirá la cadena
      <code>"concatenar"</code>:
    </p>


    <pre tabindex="0" class="snippet" data-language="javascript"
      data-meta="expr"><a class="c_ident" id="c-eCO7oekmP9" href="#c-eCO7oekmP9" tabindex="-1" role="presentation"></a><span class="tok-string">"con"</span> + <span class="tok-string">"cat"</span> + <span class="tok-string">"e"</span> + <span class="tok-string">"nate"</span></pre>
    <p><a class="p_ident" id="p-1+aqkpsjX3" href="#p-1+aqkpsjX3" tabindex="-1" role="presentation"></a>Los valores de
      cadenas tienen una serie de funciones asociadas (<em>métodos</em>) que se pueden utilizar para realizar otras
      operaciones con ellas. Hablaré más sobre esto en <a href="04_data.html#methods">Capítulo 4</a>.</p>

    <p><a class="p_ident" id="p-3NJXrCLWRR" href="#p-3NJXrCLWRR" tabindex="-1" role="presentation"></a>Las cadenas
      escritas con comillas simples o dobles se comportan de manera muy similar; la única diferencia radica en qué tipo
      de comilla necesitas escapar dentro de ellas. Las cadenas entre acentos graves, generalmente llamadas <em>template
        literals</em>, pueden hacer algunas trucos adicionales. Además de poder abarcar varias líneas, también pueden
      incrustar otros valores.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"
      data-meta="expr"><a class="c_ident" id="c-1ObyeNEDOw" href="#c-1ObyeNEDOw" tabindex="-1" role="presentation"></a><span class="tok-string2">`la mitad de 100 es </span>${<span class="tok-number">100</span> / <span class="tok-number">2</span>}<span class="tok-string2">`</span></pre>

    <p><a class="p_ident" id="p-ogkFBzzZhi" href="#p-ogkFBzzZhi" tabindex="-1" role="presentation"></a>Cuando escribes
      algo dentro de <code>${}</code> en un template literal, su resultado será calculado, convertido a cadena e
      incluido en esa posición. Este ejemplo produce "<em>la mitad de 100 es 50</em>".</p>

    <h2><a class="h_ident" id="h-ygn12/ieo+" href="#h-ygn12/ieo+" tabindex="-1" role="presentation"></a>Operadores
      unarios</h2>

    <p><a class="p_ident" id="p-GyQlmgK5IK" href="#p-GyQlmgK5IK" tabindex="-1" role="presentation"></a>No todos los
      operadores son símbolos. Algunos se escriben como palabras. Un ejemplo es el operador <code>typeof</code>, que
      produce un valor de cadena que nombra el tipo del valor que le das.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-iWT//VyY7j" href="#c-iWT//VyY7j" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">typeof</span> <span class="tok-number">4.5</span>)
<span class="tok-comment">// → number</span>
console.log(<span class="tok-keyword">typeof</span> <span class="tok-string">"x"</span>)
<span class="tok-comment">// → string</span></pre>

    <p id="console.log"><a class="p_ident" id="p-Jo1uVMEBho" href="#p-Jo1uVMEBho" tabindex="-1"
        role="presentation"></a>Usaremos <code>console.log</code> en ejemplos de código para indicar que queremos ver el
      resultado de evaluar algo. Más sobre esto en el <a href="02_program_structure.html">próximo capítulo</a>.</p>

    <p><a class="p_ident" id="p-j8F6SrKjF/" href="#p-j8F6SrKjF/" tabindex="-1" role="presentation"></a>Los otros
      operadores mostrados hasta ahora en este capítulo han operado en dos valores, pero <code>typeof</code> toma solo
      uno. Los operadores que usan dos valores se llaman operadores <em>binarios</em>, mientras que los que toman uno se
      llaman operadores <em>unarios</em>. El operador menos se puede usar tanto como un operador binario como un
      operador unario.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-VpL89RFAPj" href="#c-VpL89RFAPj" tabindex="-1" role="presentation"></a>console.log(- (<span class="tok-number">10</span> - <span class="tok-number">2</span>))
<span class="tok-comment">// → -8</span></pre>
    <h2><a class="h_ident" id="h-cTPxJxlmFR" href="#h-cTPxJxlmFR" tabindex="-1" role="presentation"></a>Valores
      booleanos</h2>

    <p><a class="p_ident" id="p-OL3ZufvGRE" href="#p-OL3ZufvGRE" tabindex="-1" role="presentation"></a>A menudo es útil
      tener un valor que distinga sólo entre dos posibilidades, como "sí" y "no" o "encendido" y "apagado". Para este
      propósito, JavaScript tiene un tipo <em>Booleano</em>, que tiene solo dos valores, true y false, escritos como
      esas palabras.</p>

    <h3><a class="i_ident" id="i-Lfz4mKO9Tg" href="#i-Lfz4mKO9Tg" tabindex="-1" role="presentation"></a>Comparación</h3>

    <p><a class="p_ident" id="p-T4yLn4fXDH" href="#p-T4yLn4fXDH" tabindex="-1" role="presentation"></a>Aquí hay una
      forma de producir valores booleanos:</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-GaxnXrIPwC" href="#c-GaxnXrIPwC" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">3</span> &gt; <span class="tok-number">2</span>)
<span class="tok-comment">// → true</span>
console.log(<span class="tok-number">3</span> &lt; <span class="tok-number">2</span>)
<span class="tok-comment">// → false</span></pre>

    <p><a class="p_ident" id="p-j0tOwzfb6M" href="#p-j0tOwzfb6M" tabindex="-1" role="presentation"></a>Los signos
      <code>&gt;</code> y <code>&lt;</code> son los símbolos tradicionales para "es mayor que" y "es menor que",
      respectivamente. Son operadores binarios. Aplicarlos resulta en un valor booleano que indica si son verdaderos en
      este caso.
    </p>

    <p><a class="p_ident" id="p-NxTGvCsM4s" href="#p-NxTGvCsM4s" tabindex="-1" role="presentation"></a>Las cadenas se
      pueden comparar de la misma manera:</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Qud5plnVuV" href="#c-Qud5plnVuV" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"Aardvark"</span> &lt; <span class="tok-string">"Zoroaster"</span>)
<span class="tok-comment">// → true</span></pre>

    <p><a class="p_ident" id="p-No3uOP/bY2" href="#p-No3uOP/bY2" tabindex="-1" role="presentation"></a>La forma en que
      se ordenan las cadenas es aproximadamente alfabética pero no es realmente lo que uno esperaría ver en un
      diccionario: las letras mayúsculas son siempre "menos" que las minúsculas, por lo que <code>"Z" &lt; "a"</code>, y
      los caracteres no alfabéticos (!, -, y así sucesivamente) también se incluyen en el orden. Al comparar cadenas,
      JavaScript recorre los caracteres de izquierda a derecha, comparando los códigos Unicode uno por uno.</p>

    <p><a class="p_ident" id="p-fGKTuK5BBc" href="#p-fGKTuK5BBc" tabindex="-1" role="presentation"></a>Otros operadores
      similares son <code>&gt;=</code> (mayor o igual que), <code>&lt;=</code> (menor o igual que), <code>==</code>
      (igual que), y <code>!=</code> (no igual que).</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-v1IZKKCCaz" href="#c-v1IZKKCCaz" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"Garnet"</span> != <span class="tok-string">"Ruby"</span>)
<span class="tok-comment">// → true</span>
console.log(<span class="tok-string">"Pearl"</span> == <span class="tok-string">"Amethyst"</span>)
<span class="tok-comment">// → false</span></pre>
    <p><a class="p_ident" id="p-tLooHn2QPj" href="#p-tLooHn2QPj" tabindex="-1" role="presentation"></a>En JavaScript,
      solo hay un valor que no es igual a sí mismo, y ese es <code>NaN</code> (“no es un número”).</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Vhz09Rgw3h" href="#c-Vhz09Rgw3h" tabindex="-1" role="presentation"></a>console.log(NaN == NaN)
<span class="tok-comment">// → false</span></pre>

    <p><a class="p_ident" id="p-AllzHp+z6n" href="#p-AllzHp+z6n" tabindex="-1" role="presentation"></a><code>NaN</code>
      se supone que denota el resultado de un cálculo sin sentido, y como tal, no es igual al resultado de ningún otro
      cálculo sin sentido.</p>

    <h3><a class="i_ident" id="i-pdqDW7Pebo" href="#i-pdqDW7Pebo" tabindex="-1" role="presentation"></a>Operadores
      lógicos</h3>

    <p><a class="p_ident" id="p-nRCLrGwcCn" href="#p-nRCLrGwcCn" tabindex="-1" role="presentation"></a>También hay
      algunas operaciones que se pueden aplicar a los valores booleanos mismos. JavaScript soporta tres operadores
      lógicos: <em>and</em> (y), <em>or</em> (o) y <em>not</em> (no). Estos se pueden usar para "razonar" sobre los
      booleanos.</p>

    <p><a class="p_ident" id="p-h6pEyNS4IJ" href="#p-h6pEyNS4IJ" tabindex="-1" role="presentation"></a>El operador
      <code>&amp;&amp;</code> representa el <em>and</em> lógico. Es un operador binario, y su resultado es verdadero
      solo si ambos valores dados son verdaderos.
    </p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-SHi38sNkwM" href="#c-SHi38sNkwM" tabindex="-1" role="presentation"></a>console.log(true &amp;&amp; false)
<span class="tok-comment">// → false</span>
console.log(true &amp;&amp; true)
<span class="tok-comment">// → true</span></pre>

    <p><a class="p_ident" id="p-T/V30CHY82" href="#p-T/V30CHY82" tabindex="-1" role="presentation"></a>El operador
      <code>||</code> denota el <em>or</em> lógico. Produce verdadero si alguno de los valores dados es verdadero.
    </p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-diXyv7iPd1" href="#c-diXyv7iPd1" tabindex="-1" role="presentation"></a>console.log(false || true)
<span class="tok-comment">// → true</span>
console.log(false || false)
<span class="tok-comment">// → false</span></pre>

    <p><a class="p_ident" id="p-OxH3G7iBRz" href="#p-OxH3G7iBRz" tabindex="-1" role="presentation"></a><em>Not</em> se
      escribe como un signo de exclamación (<code>!</code>). Es un operador unario que invierte el valor dado,
      <code>!true</code> produce <code>false</code> y <code>!false</code> da <code>true</code>.
    </p>

    <p><a class="p_ident" id="p-qSXjNNI5/y" href="#p-qSXjNNI5/y" tabindex="-1" role="presentation"></a>Cuando se mezclan
      estos operadores booleanos con operadores aritméticos y otros, no siempre es obvio cuándo se necesitan paréntesis.
      En la práctica, generalmente puedes saber que de los operadores que hemos visto hasta ahora, <code>||</code> tiene
      la menor precedencia, luego viene <code>&amp;&amp;</code>, luego los operadores de comparación (<code>&gt;</code>,
      <code>==</code>, y así sucesivamente), y luego el resto. Este orden ha sido elegido de tal manera que, en
      expresiones típicas como la siguiente, se necesiten la menor cantidad de paréntesis posible:
    </p>
    <pre tabindex="0" class="snippet" data-language="javascript"
      data-meta="expr"><a class="c_ident" id="c-6eZ07bDo11" href="#c-6eZ07bDo11" tabindex="-1" role="presentation"></a><span class="tok-number">1</span> + <span class="tok-number">1</span> == <span class="tok-number">2</span> &amp;&amp; <span class="tok-number">10</span> * <span class="tok-number">10</span> &gt; <span class="tok-number">50</span></pre>

    <p><a class="p_ident" id="p-EWJu4coIAh" href="#p-EWJu4coIAh" tabindex="-1" role="presentation"></a>El último
      operador lógico que veremos no es unario, no es binario, sino <em>ternario</em>, operando en tres valores. Se
      escribe con un signo de interrogación y dos puntos, así:</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-G7eVm8ilWm" href="#c-G7eVm8ilWm" tabindex="-1" role="presentation"></a>console.log(true ? <span class="tok-number">1</span> : <span class="tok-number">2</span>);
<span class="tok-comment">// → 1</span>
console.log(false ? <span class="tok-number">1</span> : <span class="tok-number">2</span>);
<span class="tok-comment">// → 2</span></pre>

    <p><a class="p_ident" id="p-RoDBOvicaj" href="#p-RoDBOvicaj" tabindex="-1" role="presentation"></a>A este se le
      llama el operador <em>condicional</em> (o a veces solo <em>el operador ternario</em> ya que es el único operador
      de este tipo en el lenguaje). El operador utiliza el valor a la izquierda del signo de interrogación para decidir
      entre los otros dos valores a "seleccionar". Si escribes <code>a ? b : c</code>, el resultado será <code>b</code>
      cuando <code>a</code> es verdadero y <code>c</code> de lo contrario.</p>

    <h2><a class="h_ident" id="h-FewqJ8K2E+" href="#h-FewqJ8K2E+" tabindex="-1" role="presentation"></a>Valores vacíos
    </h2>

    <p><a class="p_ident" id="p-Q/OIPtr8xY" href="#p-Q/OIPtr8xY" tabindex="-1" role="presentation"></a>Existen dos
      valores especiales, escritos <code>null</code> y <code>undefined</code>, que se utilizan para denotar la ausencia
      de un valor <em>significativo</em>. Ellos mismos son valores, pero no llevan información.</p>

    <p><a class="p_ident" id="p-HKYk2Oxaf6" href="#p-HKYk2Oxaf6" tabindex="-1" role="presentation"></a>Muchas
      operaciones en el lenguaje que no producen un valor significativo devuelven <code>undefined</code> simplemente
      porque tienen que devolver <em>algún</em> valor.</p>

    <p><a class="p_ident" id="p-43ZLcQuUDk" href="#p-43ZLcQuUDk" tabindex="-1" role="presentation"></a>La diferencia en
      el significado entre <code>undefined</code> y <code>null</code> es un accidente del diseño de JavaScript, y la
      mayoría del tiempo no importa. En casos donde realmente tienes que preocuparte por estos valores, recomiendo
      tratarlos como casi intercambiables.</p>

    <h2><a class="h_ident" id="h-AY+YGu6qyM" href="#h-AY+YGu6qyM" tabindex="-1" role="presentation"></a>Conversión
      automática de tipos</h2>

    <p><a class="p_ident" id="p-I6CpHrk6+W" href="#p-I6CpHrk6+W" tabindex="-1" role="presentation"></a>En la
      Introducción, mencioné que JavaScript se esfuerza por aceptar casi cualquier programa que le des, incluso
      programas que hacen cosas extrañas. Esto se demuestra claramente con las siguientes expresiones:</p>
    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-QqYG9KqZ2/" href="#c-QqYG9KqZ2/" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">8</span> * <span class="tok-keyword">null</span>)
<span class="tok-comment">// → 0</span>
console.log(<span class="tok-string">"5"</span> - <span class="tok-number">1</span>)
<span class="tok-comment">// → 4</span>
console.log(<span class="tok-string">"5"</span> + <span class="tok-number">1</span>)
<span class="tok-comment">// → 51</span>
console.log(<span class="tok-string">"five"</span> * <span class="tok-number">2</span>)
<span class="tok-comment">// → NaN</span>
console.log(false == <span class="tok-number">0</span>)
<span class="tok-comment">// → true</span></pre>

    <p><a class="p_ident" id="p-kjH0rNN5jK" href="#p-kjH0rNN5jK" tabindex="-1" role="presentation"></a>Cuando un
      operador se aplica al tipo “equivocado” de valor, JavaScript convertirá silenciosamente ese valor al tipo que
      necesita, utilizando un conjunto de reglas que a menudo no son lo que quieres o esperas. Esto se llama
      <em>coerción de tipo</em>. El <code>null</code> en la primera expresión se convierte en <code>0</code> y el
      <code>"5"</code> en la segunda expresión se convierte en <code>5</code> (de cadena a número). Sin embargo, en la
      tercera expresión, <code>+</code> intenta la concatenación de cadenas antes de la adición numérica, por lo que el
      <code>1</code> se convierte en <code>"1"</code> (de número a cadena).</p>

    <p><a class="p_ident" id="p-mw5To5JJ6Q" href="#p-mw5To5JJ6Q" tabindex="-1" role="presentation"></a>Cuando algo que
      no se convierte en un número de manera obvia (como <code>"cinco"</code> o <code>undefined</code>) se convierte a
      número, obtienes el valor <code>NaN</code>. Operaciones aritméticas adicionales sobre <code>NaN</code> siguen
      produciendo <code>NaN</code>, así que si te encuentras obteniendo uno de esos en un lugar inesperado, busca
      conversiones de tipo accidentales.</p>

    <p><a class="p_ident" id="p-XbK88HE+DJ" href="#p-XbK88HE+DJ" tabindex="-1" role="presentation"></a>Cuando se
      comparan valores del mismo tipo utilizando el operador <code>==</code>, el resultado es fácil de predecir:
      deberías obtener true cuando ambos valores son los mismos, excepto en el caso de <code>NaN</code>. Pero cuando los
      tipos difieren, JavaScript utiliza un conjunto complicado y confuso de reglas para determinar qué hacer. En la
      mayoría de los casos, simplemente intenta convertir uno de los valores al tipo del otro valor. Sin embargo, cuando
      <code>null</code> o <code>undefined</code> ocurren en cualquiera de los lados del operador, produce true solo si
      ambos lados son uno de <code>null</code> o <code>undefined</code>.</p>


    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-qmGDPdETlf" href="#c-qmGDPdETlf" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">null</span> == undefined);
<span class="tok-comment">// → true</span>
console.log(<span class="tok-keyword">null</span> == <span class="tok-number">0</span>);
<span class="tok-comment">// → false</span></pre>
    <p><a class="p_ident" id="p-hu+ZqjMro3" href="#p-hu+ZqjMro3" tabindex="-1" role="presentation"></a>Ese
      comportamiento suele ser útil. Cuando deseas probar si un valor tiene un valor real en lugar de <code>null</code>
      o <code>undefined</code>, puedes compararlo con <code>null</code> usando los operadores <code>==</code> o
      <code>!=</code>.
    </p>

    <p><a class="p_ident" id="p-GBtHgkKgjk" href="#p-GBtHgkKgjk" tabindex="-1" role="presentation"></a>¿Qué sucede si
      deseas probar si algo se refiere al valor preciso <code>false</code>? Expresiones como <code>0 == false</code> y
      <code>"" == false</code> también son verdaderas debido a la conversión automática de tipos. Cuando no deseas que
      ocurran conversiones de tipos, existen dos operadores adicionales: <code>===</code> y <code>!==</code>. El primero
      prueba si un valor es <em>precisamente</em> igual al otro, y el segundo prueba si no es precisamente igual. Así
      que <code>"" === false</code> es falso como se esperaba.
    </p>

    <p><a class="p_ident" id="p-S/opLpHJcU" href="#p-S/opLpHJcU" tabindex="-1" role="presentation"></a>Recomiendo usar
      los operadores de comparación de tres caracteres defensivamente para prevenir conversiones de tipos inesperadas
      que puedan confundirte. Pero cuando estás seguro de que los tipos en ambos lados serán los mismos, no hay problema
      en usar los operadores más cortos.</p>

    <h3><a class="i_ident" id="i-3jN0iK4yKW" href="#i-3jN0iK4yKW" tabindex="-1" role="presentation"></a>Cortocircuito de
      operadores lógicos</h3>

    <p><a class="p_ident" id="p-CFbagJsQYK" href="#p-CFbagJsQYK" tabindex="-1" role="presentation"></a>Los operadores
      lógicos <code>&amp;&amp;</code> y <code>||</code> manejan valores de diferentes tipos de una manera peculiar.
      Convertirán el valor de su lado izquierdo a tipo booleano para decidir qué hacer, pero dependiendo del operador y
      el resultado de esa conversión, devolverán ya sea el valor original del lado izquierdo o el valor del lado
      derecho.</p>

    <p><a class="p_ident" id="p-BFq+/JeBH9" href="#p-BFq+/JeBH9" tabindex="-1" role="presentation"></a>El operador
      <code>||</code>, por ejemplo, devolverá el valor a su izquierda cuando ese valor pueda ser convertido a verdadero
      y devolverá el valor a su derecha de lo contrario. Esto tiene el efecto esperado cuando los valores son booleanos
      y hace algo análogo para valores de otros tipos.
    </p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-ENjxHGMklb" href="#c-ENjxHGMklb" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">null</span> || <span class="tok-string">"usuario"</span>)
<span class="tok-comment">// → usuario</span>
console.log(<span class="tok-string">"Agnes"</span> || <span class="tok-string">"usuario"</span>)
<span class="tok-comment">// → Agnes</span></pre>

    <p><a class="p_ident" id="p-+E3wg/b+ti" href="#p-+E3wg/b+ti" tabindex="-1" role="presentation"></a>Podemos usar esta
      funcionalidad como una forma de recurrir a un valor predeterminado. Si tienes un valor que podría estar vacío,
      puedes colocar <code>||</code> después de él con un valor de reemplazo. Si el valor inicial se puede convertir a
      falso, obtendrás el reemplazo en su lugar. Las reglas para convertir cadenas y números en valores booleanos
      indican que <code>0</code>, <code>NaN</code> y la cadena vacía (<code>""</code>) cuentan como <code>false</code>,
      mientras que todos los demás valores cuentan como <code>true</code>. Eso significa que <code>0 || -1</code>
      produce <code>-1</code>, y <code>"" || "!?"</code> produce <code>"!?"</code>.</p>
    <p><a class="p_ident" id="p-PFWfVIoFiH" href="#p-PFWfVIoFiH" tabindex="-1" role="presentation"></a>El operador
      <code>??</code> se parece a <code>||</code>, pero devuelve el valor a la derecha sólo si el de la izquierda es
      nulo o indefinido, y no si es algún otro valor que pueda convertirse a <code>false</code>. A menudo, este
      comportamiento es preferible al de <code>||</code>.
    </p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-UVdLwFRz8U" href="#c-UVdLwFRz8U" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">0</span> || <span class="tok-number">100</span>);
<span class="tok-comment">// → 100</span>
console.log(<span class="tok-number">0</span> ?? <span class="tok-number">100</span>);
<span class="tok-comment">// → 0</span>
console.log(<span class="tok-keyword">null</span> ?? <span class="tok-number">100</span>);
<span class="tok-comment">// → 100</span></pre>

    <p><a class="p_ident" id="p-LlkwKHpB6u" href="#p-LlkwKHpB6u" tabindex="-1" role="presentation"></a>El operador
      <code>&amp;&amp;</code> funciona de manera similar pero a la inversa. Cuando el valor a su izquierda es algo que
      se convierte en falso, devuelve ese valor; de lo contrario, devuelve el valor a su derecha.
    </p>

    <p><a class="p_ident" id="p-IW4V8ztNjs" href="#p-IW4V8ztNjs" tabindex="-1" role="presentation"></a>Otra propiedad
      importante de estos dos operadores es que la parte a su derecha se evalúa solo cuando es necesario. En el caso de
      <code>true || X</code>, no importa lo que sea <code>X</code>, incluso si es un trozo de programa que hace algo
      <em>terrible</em>, el resultado será verdadero y <code>X</code> nunca se evaluará. Lo mismo sucede con
      <code>false &amp;&amp; X</code>, que es falso e ignorará <code>X</code>. Esto se llama <em>evaluación de
        cortocircuito</em>.
    </p>

    <p><a class="p_ident" id="p-WW6GFa4Qbm" href="#p-WW6GFa4Qbm" tabindex="-1" role="presentation"></a>El operador
      condicional funciona de manera similar. De los dos valores segundo y tercero, solo se evalúa el que es
      seleccionado.</p>

    <h2><a class="h_ident" id="h-ErccPg/l98" href="#h-ErccPg/l98" tabindex="-1" role="presentation"></a>Resumen</h2>

    <p><a class="p_ident" id="p-+X/MKfUuhz" href="#p-+X/MKfUuhz" tabindex="-1" role="presentation"></a>En este capítulo
      vimos cuatro tipos de valores en JavaScript: números, cadenas de texto, booleanos y valores indefinidos. Estos
      valores se crean escribiendo su nombre (<code>true</code>, <code>null</code>) o valor (<code>13</code>,
      <code>"abc"</code>).
    </p>

    <p><a class="p_ident" id="p-GblDDYUSHr" href="#p-GblDDYUSHr" tabindex="-1" role="presentation"></a>Puedes combinar y
      transformar valores con operadores. Vimos operadores binarios para aritmética (<code>+</code>, <code>-</code>,
      <code>*</code>, <code>/</code>, y <code>%</code>), concatenación de cadenas (<code>+</code>), comparación
      (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&lt;</code>, <code>&gt;</code>,
      <code>&lt;=</code>, <code>&gt;=</code>), y lógicos (<code>&amp;&amp;</code>, <code>||</code>, <code>??</code>),
      así como varios operadores unarios (<code>-</code> para negar un número, <code>!</code> para negar lógicamente y
      <code>typeof</code> para encontrar el tipo de un valor) y un operador ternario (<code>?:</code>) para elegir uno
      de dos valores basado en un tercer valor.
    </p>
    <p><a class="p_ident" id="p-WHkzsJyNsJ" href="#p-WHkzsJyNsJ" tabindex="-1" role="presentation"></a>Esto te
      proporciona suficiente información para usar JavaScript como una calculadora de bolsillo, pero no mucho más. El <a
        href="02_program_structure.html">próximo capítulo</a> comenzará a unir estas expresiones en programas básicos.
    </p>
    <nav><a href="00_intro.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a
        href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="02_program_structure.html"
        title="próximo capítulo" aria-label="próximo capítulo">▸</a>&nbsp;<button class="help" title="ayuda"
        aria-label="ayuda"><strong>?</strong></button>
    </nav>
  </article>

  <script src="js/ejs.js"></script>
</body>

</html>
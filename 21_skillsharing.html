<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Proyecto: Sitio web de intercambio de habilidades :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="css/ejs.css">
  <script>
    var page = { "type": "chapter", "number": 21 }</script>
</head>

<body>
  <article>
    <nav><a href="20_node.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html"
        title="portada" aria-label="portada">●</a>&nbsp;<button class="help" title="ayuda"
        aria-label="ayuda"><strong>?</strong></button>
    </nav>

    <h1>Proyecto: Sitio web de intercambio de habilidades</h1>

    <blockquote>

      <p><a class="p_ident" id="p-ektEqTmX2a" href="#p-ektEqTmX2a" tabindex="-1" role="presentation"></a>Si tienes
        conocimiento, permite que otros enciendan sus velas en él.</p>

      <footer>Margaret Fuller</footer>

    </blockquote>
    <figure class="chapter framed"><img src="images/chapter_picture_21.jpg"
        alt="Ilustración que muestra dos monociclos apoyados en un buzón"></figure>

    <p><a class="p_ident" id="p-lJLUX5aYTh" href="#p-lJLUX5aYTh" tabindex="-1" role="presentation"></a>Una reunión de
      <em>intercambio de habilidades</em> es un evento donde personas con un interés compartido se reúnen y hacen
      pequeñas presentaciones informales sobre cosas que saben. En una reunión de intercambio de habilidades de
      jardinería, alguien podría explicar cómo cultivar apio. O en un grupo de intercambio de habilidades de
      programación, podrías pasar y contarles a la gente sobre Node.js.</p>

    <p><a class="p_ident" id="p-CXpJEJrFaX" href="#p-CXpJEJrFaX" tabindex="-1" role="presentation"></a>En este último
      capítulo del proyecto, nuestro objetivo es configurar un sitio web para gestionar charlas dadas en una reunión de
      intercambio de habilidades. Imagina un pequeño grupo de personas que se reúnen regularmente en la oficina de uno
      de los miembros para hablar sobre monociclismo. El organizador anterior de las reuniones se mudó a otra ciudad, y
      nadie se ofreció a hacerse cargo de esta tarea. Queremos un sistema que permita a los participantes proponer y
      discutir charlas entre ellos, sin un organizador activo.</p>

    <p><a class="p_ident" id="p-We9gc8FghX" href="#p-We9gc8FghX" tabindex="-1" role="presentation"></a>Al igual que en
      el <a href="20_node.html">capítulo anterior</a>, parte del código en este capítulo está escrito para Node.js, y
      ejecutarlo directamente en la página HTML que estás viendo es poco probable que funcione. Todo el código del
      proyecto se puede descargar desde <a
        href="https://eloquentjavascript.net/code/skillsharing.zip"><em>https://eloquentjavascript.net/code/skillsharing.zip</em></a>.
    </p>

    <h2><a class="h_ident" id="h-WbA1NnIRqT" href="#h-WbA1NnIRqT" tabindex="-1" role="presentation"></a>Diseño</h2>

    <p><a class="p_ident" id="p-MplsNwNLhr" href="#p-MplsNwNLhr" tabindex="-1" role="presentation"></a>Este proyecto
      tiene una parte de <em>servidor</em>, escrita para Node.js, y una parte de <em>cliente</em>, escrita para el
      navegador. El servidor almacena los datos del sistema y los proporciona al cliente. También sirve los archivos que
      implementan el sistema del lado del cliente.</p>

    <p><a class="p_ident" id="p-jXT76qvYdx" href="#p-jXT76qvYdx" tabindex="-1" role="presentation"></a>El servidor
      mantiene la lista de charlas propuestas para la próxima reunión, y el cliente muestra esta lista. Cada charla
      tiene un nombre de presentador, un título, un resumen y un array de comentarios asociados. El cliente permite a
      los usuarios proponer nuevas charlas (agregándolas a la lista), eliminar charlas y comentar en charlas existentes.
      Cada vez que el usuario realiza un cambio de este tipo, el cliente hace una solicitud HTTP para informar al
      servidor al respecto.</p>
    <figure><img src="images/skillsharing.png" alt="Captura de pantalla del sitio web de intercambio de habilidades">
    </figure>
    <p><a class="p_ident" id="p-R3HdsDdi40" href="#p-R3HdsDdi40" tabindex="-1" role="presentation"></a>La aplicación se
      configurará para mostrar una vista <em>en vivo</em> de las charlas propuestas actuales y sus comentarios. Cada vez
      que alguien, en cualquier parte, envíe una nueva charla o agregue un comentario, todas las personas que tengan la
      página abierta en sus navegadores deberían ver el cambio de inmediato. Esto plantea un pequeño desafío, ya que no
      hay forma de que un servidor web abra una conexión a un cliente, ni tampoco hay una buena manera de saber qué
      clientes están viendo actualmente un sitio web dado.</p>

    <p><a class="p_ident" id="p-sXOeE6mAl8" href="#p-sXOeE6mAl8" tabindex="-1" role="presentation"></a>Una solución
      común a este problema se llama <em>long polling</em>, que resulta ser una de las motivaciones del diseño de Node.
    </p>

    <h2><a class="h_ident" id="h-Yxu7U155Cs" href="#h-Yxu7U155Cs" tabindex="-1" role="presentation"></a>Long polling
    </h2>

    <p><a class="p_ident" id="p-UARchLL3as" href="#p-UARchLL3as" tabindex="-1" role="presentation"></a>Para poder
      notificar de inmediato a un cliente que algo ha cambiado, necesitamos una conexión con ese cliente. Dado que los
      navegadores web no suelen aceptar conexiones y los clientes a menudo están detrás de routers que bloquearían
      dichas conexiones de todos modos, no es práctico que el servidor inicie esta conexión.</p>

    <p><a class="p_ident" id="p-0nqsjRmsQ7" href="#p-0nqsjRmsQ7" tabindex="-1" role="presentation"></a>Podemos hacer que
      el cliente abra la conexión y la mantenga activa para que el servidor pueda usarla para enviar información cuando
      sea necesario.</p>

    <p><a class="p_ident" id="p-nPHiUyGtEt" href="#p-nPHiUyGtEt" tabindex="-1" role="presentation"></a>Pero una
      solicitud HTTP permite únicamente un flujo simple de información: el cliente envía una solicitud, el servidor
      responde con una única respuesta y eso es todo. Existe una tecnología llamada <em>WebSockets</em> que permite
      abrir conexiones para intercambio de datos arbitrarios. Pero usarlos correctamente es algo complicado.</p>

    <p><a class="p_ident" id="p-h/JHQAq292" href="#p-h/JHQAq292" tabindex="-1" role="presentation"></a>En este capítulo,
      utilizamos una técnica más simple: el long polling, donde los clientes solicitan continuamente al servidor nueva
      información mediante solicitudes HTTP regulares, y el servidor retrasa su respuesta cuando no tiene nada nuevo que
      informar.</p>

    <p><a class="p_ident" id="p-jgdXNb8hyw" href="#p-jgdXNb8hyw" tabindex="-1" role="presentation"></a>Mientras el
      cliente se asegure de mantener abierta una solicitud de polling constantemente, recibirá información del servidor
      rápidamente luego de que esté disponible. Por ejemplo, si Fatma tiene nuestra aplicación de intercambio de
      habilidades abierta en su navegador, ese navegador habrá realizado una solicitud de actualizaciones y estará
      esperando una respuesta a esa solicitud. Cuando Iman envíe una charla sobre "Uniciclo Extremo en Descenso", el
      servidor notará que Fatma está esperando actualizaciones y enviará una respuesta que contiene la nueva charla a su
      solicitud pendiente. El navegador de Fatma recibirá los datos y actualizará la pantalla para mostrar la charla.
    </p>
    <p><a class="p_ident" id="p-SAbyKs9a4Y" href="#p-SAbyKs9a4Y" tabindex="-1" role="presentation"></a>Para evitar que
      las conexiones se agoten (se aborten debido a la falta de actividad), las técnicas de long polling suelen
      establecer un tiempo máximo para cada solicitud, después del cual el servidor responderá de todos modos, aunque no
      tenga nada que informar. El cliente puede comenzar entonces una nueva solicitud. Reiniciar periódicamente la
      solicitud también hace que la técnica sea más robusta, permitiendo a los clientes recuperarse de fallos de
      conexión temporales o problemas del servidor.</p>

    <p><a class="p_ident" id="p-G3JjyqG0SD" href="#p-G3JjyqG0SD" tabindex="-1" role="presentation"></a>Un servidor
      ocupado que utiliza long polling puede tener miles de solicitudes en espera, y por lo tanto, conexiones TCP
      abiertas. Node, que facilita la gestión de muchas conexiones sin crear un hilo de control separado para cada una,
      es una buena opción para dicho sistema.</p>

    <h2><a class="h_ident" id="h-a1H+QQ9w0g" href="#h-a1H+QQ9w0g" tabindex="-1" role="presentation"></a>Interfaz HTTP
    </h2>

    <p><a class="p_ident" id="p-pnq2n4wyAS" href="#p-pnq2n4wyAS" tabindex="-1" role="presentation"></a>Antes de comenzar
      a diseñar el servidor o el cliente, pensemos en el punto donde se conectan: la interfaz HTTP a través de la cual
      se comunican.</p>

    <p><a class="p_ident" id="p-DAqJk8WjH9" href="#p-DAqJk8WjH9" tabindex="-1" role="presentation"></a>Usaremos JSON
      como formato de nuestro cuerpo de solicitud y respuesta. Al igual que en el servidor de archivos de <a
        href="20_node.html#file_server">Capítulo 20</a>, intentaremos hacer un buen uso de los métodos y encabezados
      HTTP. La interfaz se centra en la ruta <code>/talks</code>. Las rutas que no comienzan con <code>/talks</code> se
      utilizarán para servir archivos estáticos: el código HTML y JavaScript para el sistema del lado del cliente.</p>

    <p><a class="p_ident" id="p-UHEQ70Qz7s" href="#p-UHEQ70Qz7s" tabindex="-1" role="presentation"></a>Una solicitud
      <code>GET</code> a <code>/talks</code> devuelve un documento JSON como este:</p>

    <pre class="snippet" data-language="json"><a class="c_ident" id="c-LnKGb3Adty" href="#c-LnKGb3Adty" tabindex="-1" role="presentation"></a>[{<span class="tok-string">"title"</span>: <span class="tok-string">"Unituning"</span>,
  <span class="tok-string">"presenter"</span>: <span class="tok-string">"Jamal"</span>,
  <span class="tok-string">"summary"</span>: <span class="tok-string">"Modificando tu ciclo para darle estilo extra"</span>,
  <span class="tok-string">"comments"</span>: []}]</pre>

    <p><a class="p_ident" id="p-aWz1ZbQjuM" href="#p-aWz1ZbQjuM" tabindex="-1" role="presentation"></a>Crear una nueva
      charla se hace haciendo una solicitud <code>PUT</code> a una URL como <code>/talks/Unituning</code>, donde la
      parte después de la segunda barra es el título de la charla. El cuerpo de la solicitud <code>PUT</code> debe
      contener un objeto JSON con las propiedades <code>presenter</code> y <code>summary</code>.</p>

    <p><a class="p_ident" id="p-KfmhZR585o" href="#p-KfmhZR585o" tabindex="-1" role="presentation"></a>Dado que los
      títulos de las charlas pueden contener espacios y otros caracteres que no aparecen normalmente en una URL, las
      cadenas de título deben codificarse con la función <code>encodeURIComponent</code> al construir dicha URL.</p>
    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-vixRLAECCO" href="#c-vixRLAECCO" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"/talks/"</span> + encodeURIComponent(<span class="tok-string">"How to Idle"</span>));
<span class="tok-comment">// → /talks/How%20to%20Idle</span></pre>

    <p><a class="p_ident" id="p-lVTXP6zy/G" href="#p-lVTXP6zy/G" tabindex="-1" role="presentation"></a>Una solicitud
      para crear una charla sobre el ocio podría lucir algo así:</p>

    <pre class="snippet" data-language="http"><a class="c_ident" id="c-G609VIyy0C" href="#c-G609VIyy0C" tabindex="-1" role="presentation"></a><span class="tok-keyword">PUT</span> <span class="tok-string2">/talks/How%20to%20Idle</span> <span class="tok-keyword">HTTP/1.1</span>
<span class="tok-atom">Content-Type:</span><span class="tok-string"> application/json</span>
<span class="tok-atom">Content-Length:</span><span class="tok-string"> 92</span>

{"presenter": "Maureen",
 "summary": "En equilibrio en un monociclo"}</pre>

    <p><a class="p_ident" id="p-MlEec58Mz7" href="#p-MlEec58Mz7" tabindex="-1" role="presentation"></a>Estas URL también
      admiten solicitudes <code>GET</code> para recuperar la representación JSON de una charla y solicitudes
      <code>DELETE</code> para borrar una charla.</p>

    <p><a class="p_ident" id="p-DdsHVoQpp3" href="#p-DdsHVoQpp3" tabindex="-1" role="presentation"></a>Agregar un
      comentario a una charla se hace con una solicitud <code>POST</code> a una URL como
      <code>/talks/Unituning/comments</code>, con un cuerpo JSON que tiene las propiedades <code>author</code> y
      <code>message</code>.</p>

    <pre class="snippet" data-language="http"><a class="c_ident" id="c-JUbwWgr3xI" href="#c-JUbwWgr3xI" tabindex="-1" role="presentation"></a><span class="tok-keyword">POST</span> <span class="tok-string2">/talks/Unituning/comments</span> <span class="tok-keyword">HTTP/1.1</span>
<span class="tok-atom">Content-Type:</span><span class="tok-string"> application/json</span>
<span class="tok-atom">Content-Length:</span><span class="tok-string"> 72</span>

{"author": "Iman",
 "message": "¿Hablarás sobre levantar un ciclista?"}</pre>

    <p><a class="p_ident" id="p-i78LNKoc4F" href="#p-i78LNKoc4F" tabindex="-1" role="presentation"></a>Para soportar la
      espera activa, las solicitudes <code>GET</code> a <code>/talks</code> pueden incluir cabeceras adicionales que
      informan al servidor para retrasar la respuesta si no hay nueva información disponible. Utilizaremos un par de
      cabeceras normalmente destinadas a gestionar el almacenamiento en caché: <code>ETag</code> y
      <code>If-None-Match</code>.</p>

    <p><a class="p_ident" id="p-aQzwhPBm+b" href="#p-aQzwhPBm+b" tabindex="-1" role="presentation"></a>Los servidores
      pueden incluir una cabecera <code>ETag</code> (etiqueta de entidad) en una respuesta. Su valor es una cadena que
      identifica la versión actual del recurso. Los clientes, al solicitar ese recurso nuevamente más adelante, pueden
      hacer una solicitud condicional incluyendo una cabecera <code>If-None-Match</code> cuyo valor contenga esa misma
      cadena. Si el recurso no ha cambiado, el servidor responderá con el código de estado 304, que significa "no
      modificado", indicando al cliente que su versión en caché sigue siendo vigente. Cuando la etiqueta no coincide, el
      servidor responde como de costumbre.</p>
    <p><a class="p_ident" id="p-1IdVaazzeZ" href="#p-1IdVaazzeZ" tabindex="-1" role="presentation"></a>Necesitamos algo
      como esto, donde el cliente puede decirle al servidor qué versión de la lista de charlas tiene, y el servidor
      responde solo cuando esa lista ha cambiado. Pero en lugar de devolver inmediatamente una respuesta 304, el
      servidor debería detener la respuesta y devolver solo cuando haya algo nuevo disponible o haya transcurrido una
      cantidad dada de tiempo. Para distinguir las solicitudes de espera larga (long polling) de las solicitudes
      condicionales normales, les damos otro encabezado, <code>Prefer: wait=90</code>, que le indica al servidor que el
      cliente está dispuesto a esperar hasta 90 segundos por la respuesta.</p>

    <p><a class="p_ident" id="p-JPz1jBPEDl" href="#p-JPz1jBPEDl" tabindex="-1" role="presentation"></a>El servidor
      mantendrá un número de versión que se actualiza cada vez que cambian las charlas y lo utilizará como el valor de
      <code>ETag</code>. Los clientes pueden hacer solicitudes como esta para ser notificados cuando las charlas
      cambien:</p>

    <pre class="snippet" data-language="null"><a class="c_ident" id="c-RikeEeOO6T" href="#c-RikeEeOO6T" tabindex="-1" role="presentation"></a>GET /charlas HTTP/1.1
If-None-Match: "4"
Prefer: wait=90

(pasa el tiempo)

HTTP/1.1 200 OK
Content-Type: application/json
ETag: "5"
Content-Length: 295

[....]</pre>

    <p><a class="p_ident" id="p-7W+awFFiIf" href="#p-7W+awFFiIf" tabindex="-1" role="presentation"></a>El protocolo
      descrito aquí no realiza ningún control de acceso. Todos pueden comentar, modificar charlas e incluso borrarlas.
      (Dado que Internet está lleno de gamberros, poner un sistema así en línea sin más protección probablemente no
      terminaría bien).</p>

    <h2><a class="h_ident" id="h-wTUn7xllPe" href="#h-wTUn7xllPe" tabindex="-1" role="presentation"></a>El servidor</h2>

    <p><a class="p_ident" id="p-AXW7RPZDuT" href="#p-AXW7RPZDuT" tabindex="-1" role="presentation"></a>Comencemos
      construyendo la parte del servidor del programa. El código en esta sección se ejecuta en Node.js.</p>

    <h3><a class="i_ident" id="i-fRXdG+wuBV" href="#i-fRXdG+wuBV" tabindex="-1" role="presentation"></a>Enrutamiento
    </h3>

    <p><a class="p_ident" id="p-YGBPHzmANZ" href="#p-YGBPHzmANZ" tabindex="-1" role="presentation"></a>Nuestro servidor
      utilizará <code>createServer</code> de Node para iniciar un servidor HTTP. En la función que maneja una nueva
      solicitud, debemos distinguir entre los diferentes tipos de solicitudes (según el método y la ruta) que admitimos.
      Esto se puede hacer con una larga cadena de declaraciones <code>if</code>, pero hay una forma más elegante.</p>

    <p><a class="p_ident" id="p-leW0rMWKfc" href="#p-leW0rMWKfc" tabindex="-1" role="presentation"></a>Un
      <em>enrutador</em> es un componente que ayuda a despachar una solicitud a la función que puede manejarla. Puedes
      indicarle al enrutador, por ejemplo, que las solicitudes <code>PUT</code> con una ruta que coincide con la
      expresión regular <code>/<wbr>^\/<wbr>charlas\/<wbr>([^\/<wbr>]+)$/<wbr></code> (<code>/charlas/</code> seguido de
      un título de charla) pueden ser manejadas por una función dada. Además, puede ayudar a extraer las partes
      significativas de la ruta (en este caso el título de la charla), envueltas entre paréntesis en la expresión
      regular, y pasarlas a la función manejadora.</p>
    <p><a class="p_ident" id="p-l/CAybKBxr" href="#p-l/CAybKBxr" tabindex="-1" role="presentation"></a>Existen varios
      paquetes de enrutadores buenos en NPM, pero aquí escribiremos uno nosotros mismos para ilustrar el principio.</p>

    <p><a class="p_ident" id="p-00rY02I/YG" href="#p-00rY02I/YG" tabindex="-1" role="presentation"></a>Este es
      <code>router.mjs</code>, el cual luego <code>importaremos</code> desde nuestro módulo de servidor:</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-DdjroKRGYC" href="#c-DdjroKRGYC" tabindex="-1" role="presentation"></a><span class="tok-keyword">export</span> <span class="tok-keyword">class</span> Router {
  <span class="tok-definition">constructor</span>() {
    <span class="tok-keyword">this</span>.routes = [];
  }
  <span class="tok-definition">add</span>(<span class="tok-definition">method</span>, <span class="tok-definition">url</span>, <span class="tok-definition">handler</span>) {
    <span class="tok-keyword">this</span>.routes.push({<span class="tok-definition">method</span>, <span class="tok-definition">url</span>, <span class="tok-definition">handler</span>});
  }
  <span class="tok-keyword">async</span> <span class="tok-definition">resolve</span>(<span class="tok-definition">request</span>, <span class="tok-definition">context</span>) {
    <span class="tok-keyword">let</span> {pathname} = <span class="tok-keyword">new</span> URL(request.url, <span class="tok-string">"http://d"</span>);
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> {method, url, handler} <span class="tok-keyword">of</span> <span class="tok-keyword">this</span>.routes) {
      <span class="tok-keyword">let</span> <span class="tok-definition">match</span> = url.exec(pathname);
      <span class="tok-keyword">if</span> (!match || request.method != method) <span class="tok-keyword">continue</span>;
      <span class="tok-keyword">let</span> <span class="tok-definition">parts</span> = match.slice(<span class="tok-number">1</span>).map(decodeURIComponent);
      <span class="tok-keyword">return</span> handler(context, ...parts, request);
    }
  }
}</pre>

    <p><a class="p_ident" id="p-MyW340wruf" href="#p-MyW340wruf" tabindex="-1" role="presentation"></a>El módulo exporta
      la clase <code>Router</code>. Un objeto de enrutador te permite registrar manejadores para métodos específicos y
      patrones de URL con su método <code>add</code>. Cuando una solicitud se resuelve con el método
      <code>resolve</code>, el enrutador llama al manejador cuyo método y URL coinciden con la solicitud y devuelve su
      resultado.</p>

    <p><a class="p_ident" id="p-Om1ZCXoDWj" href="#p-Om1ZCXoDWj" tabindex="-1" role="presentation"></a>Las funciones
      manejadoras son llamadas con el valor <code>context</code> dado a <code>resolve</code>. Usaremos esto para darles
      acceso a nuestro estado de servidor. Adicionalmente, reciben las cadenas de coincidencia para cualquier grupo que
      definieron en su expresión regular, y el objeto de solicitud. Las cadenas deben ser decodificadas de URL ya que la
      URL en bruto puede contener códigos estilo <code>%20</code>.</p>
    <h3><a class="i_ident" id="i-WmSQ4nnG8k" href="#i-WmSQ4nnG8k" tabindex="-1" role="presentation"></a>Servidor de
      archivos</h3>

    <p><a class="p_ident" id="p-G58QvpWZ3S" href="#p-G58QvpWZ3S" tabindex="-1" role="presentation"></a>Cuando una
      solicitud no coincide con ninguno de los tipos de solicitud definidos en nuestro enrutador, el servidor debe
      interpretarlo como una solicitud de un archivo en el directorio <code>public</code>. Sería posible usar el
      servidor de archivos definido en <a href="20_node.html#file_server">Capítulo 20</a> para servir dichos archivos,
      pero ni necesitamos ni queremos admitir las solicitudes <code>PUT</code> y <code>DELETE</code> en los archivos, y
      nos gustaría tener características avanzadas como el soporte para caché. Por lo tanto, usemos en su lugar un
      servidor de archivos estáticos sólido y bien probado de NPM.</p>

    <p><a class="p_ident" id="p-tOJqwN8CJl" href="#p-tOJqwN8CJl" tabindex="-1" role="presentation"></a>Opté por
      <code>serve-static</code>. Este no es el único servidor de este tipo en NPM, pero funciona bien y se ajusta a
      nuestros propósitos. El paquete <code>serve-static</code> exporta una función que puede ser llamada con un
      directorio raíz para producir una función controladora de solicitud. La función controladora acepta los argumentos
      <code>request</code> y <code>response</code> proporcionados por el servidor de <code>"node:http"</code>, y un
      tercer argumento, una función que llamará si ningún archivo coincide con la solicitud. Queremos que nuestro
      servidor primero compruebe las solicitudes que debemos manejar de manera especial, según lo definido en el
      enrutador, por lo que lo envolvemos en otra función.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-lpYEW+IClx" href="#c-lpYEW+IClx" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">createServer</span>} <span class="tok-keyword">from</span> <span class="tok-string">"node:http"</span>;
<span class="tok-keyword">import</span> <span class="tok-definition">serveStatic</span> <span class="tok-keyword">from</span> <span class="tok-string">"serve-static"</span>;

<span class="tok-keyword">function</span> <span class="tok-definition">notFound</span>(<span class="tok-definition">request</span>, <span class="tok-definition">response</span>) {
  response.writeHead(<span class="tok-number">404</span>, <span class="tok-string">"Not found"</span>);
  response.end(<span class="tok-string">"&lt;h1&gt;No encontrado&lt;/h1&gt;"</span>);
}

<span class="tok-keyword">class</span> SkillShareServer {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">talks</span>) {
    <span class="tok-keyword">this</span>.talks = talks;
    <span class="tok-keyword">this</span>.version = <span class="tok-number">0</span>;
    <span class="tok-keyword">this</span>.waiting = [];

    <span class="tok-keyword">let</span> <span class="tok-definition">fileServer</span> = serveStatic(<span class="tok-string">"./public"</span>);
    <span class="tok-keyword">this</span>.server = createServer((<span class="tok-definition">request</span>, <span class="tok-definition">response</span>) =&gt; {
      serveFromRouter(<span class="tok-keyword">this</span>, request, response, () =&gt; {
        fileServer(request, response,
                   () =&gt; notFound(request, response));
      });
    });
  }
  <span class="tok-definition">start</span>(<span class="tok-definition">port</span>) {
    <span class="tok-keyword">this</span>.server.listen(port);
  }
  <span class="tok-definition">stop</span>() {
    <span class="tok-keyword">this</span>.server.close();
  }
}</pre>
    <p><a class="p_ident" id="p-QLLHOq6xQj" href="#p-QLLHOq6xQj" tabindex="-1" role="presentation"></a>La función
      <code>serveFromRouter</code> tiene la misma interfaz que <code>fileServer</code>, tomando los argumentos
      <code>(request, response, next)</code>. Esto nos permite "encadenar" varios manejadores de solicitudes,
      permitiendo que cada uno maneje la solicitud o pase la responsabilidad de eso al siguiente manejador. El manejador
      final, <code>notFound</code>, simplemente responde con un error de "no encontrado".</p>

    <p><a class="p_ident" id="p-gzzRCoAwVN" href="#p-gzzRCoAwVN" tabindex="-1" role="presentation"></a>Nuestra función
      <code>serveFromRouter</code> utiliza una convención similar al servidor de archivos del <a
        href="20_node.html">capítulo anterior</a> para las respuestas: los manejadores en el enrutador devuelven
      promesas que se resuelven en objetos que describen la respuesta.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-IVmjRqYXq0" href="#c-IVmjRqYXq0" tabindex="-1" role="presentation"></a><span class="tok-keyword">importar</span> {<span class="tok-definition">Router</span>} <span class="tok-keyword">desde</span> <span class="tok-string">"./router.mjs"</span>;

<span class="tok-keyword">const</span> <span class="tok-definition">enrutador</span> = <span class="tok-keyword">nuevo</span> Router();
<span class="tok-keyword">const</span> <span class="tok-definition">cabecerasPorDefecto</span> = {<span class="tok-string">"Content-Type"</span>: <span class="tok-string">"text/plain"</span>};

<span class="tok-keyword">async</span> <span class="tok-keyword">function</span> <span class="tok-definition">serveFromRouter</span>(<span class="tok-definition">servidor</span>, <span class="tok-definition">solicitud</span>,
                               <span class="tok-definition">respuesta</span>, <span class="tok-definition">siguiente</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">resuelto</span> = <span class="tok-keyword">esperar</span> enrutador.resolver(solicitud, servidor)
    .capturar(<span class="tok-definition">error</span> =&gt; {
      <span class="tok-keyword">si</span> (error.estado != <span class="tok-keyword">nulo</span>) <span class="tok-keyword">return</span> error;
      <span class="tok-keyword">return</span> {<span class="tok-definition">cuerpo</span>: String(err), <span class="tok-definition">estado</span>: <span class="tok-number">500</span>};
    });
  <span class="tok-keyword">si</span> (!resuelto) <span class="tok-keyword">return</span> siguiente();
  <span class="tok-keyword">let</span> {cuerpo, estado = <span class="tok-number">200</span>, cabeceras = cabecerasPorDefecto} =
    <span class="tok-keyword">esperar</span> resuelto;
  respuesta.writeHead(estado, cabeceras);
  respuesta.end(cuerpo);
}</pre>

    <h3><a class="i_ident" id="i-soh9hQbmUg" href="#i-soh9hQbmUg" tabindex="-1" role="presentation"></a>Charlas como
      recursos</h3>

    <p><a class="p_ident" id="p-lrlXwxHVYa" href="#p-lrlXwxHVYa" tabindex="-1" role="presentation"></a>Las charlas que
      han sido propuestas están almacenadas en la propiedad <code>charlas</code> del servidor, un objeto cuyos nombres
      de propiedad son los títulos de las charlas. Agregaremos algunos manejadores a nuestro enrutador que exponen estos
      como recursos HTTP bajo <code>/charlas/[título]</code>.</p>
    <p><a class="p_ident" id="p-/JQcLOK+vv" href="#p-/JQcLOK+vv" tabindex="-1" role="presentation"></a>El controlador
      para las solicitudes que hacen <code>GET</code> de una única charla debe buscar la charla y responder ya sea con
      los datos JSON de la charla o con una respuesta de error 404.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-4ftntao2tl" href="#c-4ftntao2tl" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">talkPath</span> = <span class="tok-string2">/^\/talks\/([^\/]+)$/</span>;

router.add(<span class="tok-string">"GET"</span>, talkPath, <span class="tok-keyword">async</span> (<span class="tok-definition">server</span>, <span class="tok-definition">title</span>) =&gt; {
  <span class="tok-keyword">if</span> (Object.hasOwn(server.talks, title)) {
    <span class="tok-keyword">return</span> {<span class="tok-definition">body</span>: JSON.stringify(server.talks[title]),
            <span class="tok-definition">headers</span>: {<span class="tok-string">"Content-Type"</span>: <span class="tok-string">"application/json"</span>}};
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">404</span>, <span class="tok-definition">body</span>: <span class="tok-string2">`No se encontró la charla '</span>${title}<span class="tok-string2'>'</span>};
  }
});</pre>

    <p><a class="p_ident" id="p-LqiBhzHqti" href="#p-LqiBhzHqti" tabindex="-1" role="presentation"></a>Eliminar una
      charla se hace al removerla del objeto <code>talks</code>.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-hHVMqh7is7" href="#c-hHVMqh7is7" tabindex="-1" role="presentation"></a>router.add(<span class="tok-string">"DELETE"</span>, talkPath, <span class="tok-keyword">async</span> (<span class="tok-definition">server</span>, <span class="tok-definition">title</span>) =&gt; {
  <span class="tok-keyword">if</span> (Object.hasOwn(server.talks, title)) {
    <span class="tok-keyword">delete</span> server.talks[title];
    server.updated();
  }
  <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">204</span>};
});</pre>

    <p><a class="p_ident" id="p-uw4JQI97zd" href="#p-uw4JQI97zd" tabindex="-1" role="presentation"></a>El método
      <code>updated</code>, que definiremos <a href="21_skillsharing.html#updated">más tarde</a>, notifica a las
      solicitudes de espera de larga espera sobre el cambio.</p>

    <p><a class="p_ident" id="p-nKzpVkDH6v" href="#p-nKzpVkDH6v" tabindex="-1" role="presentation"></a>Un controlador
      que necesita leer cuerpos de solicitud es el controlador <code>PUT</code>, que se utiliza para crear nuevas
      charlas. Tiene que verificar si los datos que se le dieron tienen las propiedades <code>presenter</code> y
      <code>summary</code>, que son cadenas. Cualquier dato que venga de fuera del sistema podría ser un sinsentido, y
      no queremos corromper nuestro modelo de datos interno ni colapsar cuando lleguen solicitudes incorrectas.</p>
    <p><a class="p_ident" id="p-vLKX/LDu2A" href="#p-vLKX/LDu2A" tabindex="-1" role="presentation"></a>Si los datos
      parecen válidos, el manejador almacena un objeto que representa la nueva charla en el objeto <code>talks</code>,
      posiblemente sobrescribiendo una charla existente con este título, y llama nuevamente a <code>updated</code>.</p>

    <p><a class="p_ident" id="p-B6Mlo1jSnH" href="#p-B6Mlo1jSnH" tabindex="-1" role="presentation"></a>Para leer el
      cuerpo del flujo de solicitud, utilizaremos la función <code>json</code> de
      <code>"node:stream/<wbr>consumers"</code>, que recopila los datos en el flujo y luego los analiza como JSON. Hay
      exportaciones similares llamadas <code>text</code> (para leer el contenido como una cadena) y <code>buffer</code>
      (para leerlo como datos binarios) en este paquete. Dado que <code>json</code> es un nombre muy genérico, la
      importación lo renombra a <code>readJSON</code> para evitar confusiones.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-QPyxkP5MWN" href="#c-QPyxkP5MWN" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {json <span class="tok-keyword">as</span> <span class="tok-definition">readJSON</span>} <span class="tok-keyword">from</span> <span class="tok-string">"node:stream/consumers"</span>

router.add(<span class="tok-string">"PUT"</span>, talkPath,
           <span class="tok-keyword">async</span> (<span class="tok-definition">server</span>, <span class="tok-definition">title</span>, <span class="tok-definition">request</span>) =&gt; {
  <span class="tok-keyword">let</span> <span class="tok-definition">talk</span> = <span class="tok-keyword">await</span> readJSON(request);
  <span class="tok-keyword">if</span> (!talk ||
      <span class="tok-keyword">typeof</span> talk.presenter != <span class="tok-string">"string"</span> ||
      <span class="tok-keyword">typeof</span> talk.summary != <span class="tok-string">"string"</span>) {
    <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">400</span>, <span class="tok-definition">body</span>: <span class="tok-string">"Datos de charla inválidos"</span>};
  }
  server.talks[title] = {
    <span class="tok-definition">title</span>,
    <span class="tok-definition">presenter</span>: talk.presenter,
    <span class="tok-definition">summary</span>: talk.summary,
    <span class="tok-definition">comments</span>: []
  };
  server.updated();
  <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">204</span>};
});</pre>

    <p><a class="p_ident" id="p-5d2itdrhai" href="#p-5d2itdrhai" tabindex="-1" role="presentation"></a>Agregar un
      comentario a una charla funciona de manera similar. Utilizamos <code>readJSON</code> para obtener el contenido de
      la solicitud, validamos los datos resultantes y los almacenamos como un comentario cuando parecen válidos.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-4SE8JFXmeR" href="#c-4SE8JFXmeR" tabindex="-1" role="presentation"></a>router.add(<span class="tok-string">"POST"</span>, <span class="tok-string2">/^\/talks\/([^\/]+)\/comments$/</span>,
           <span class="tok-keyword">async</span> (<span class="tok-definition">server</span>, <span class="tok-definition">title</span>, <span class="tok-definition">request</span>) =&gt; {
  <span class="tok-keyword">let</span> <span class="tok-definition">comment</span> = <span class="tok-keyword">await</span> readJSON(request);
  <span class="tok-keyword">if</span> (!comment ||
      <span class="tok-keyword">typeof</span> comment.author != <span class="tok-string">"string"</span> ||
      <span class="tok-keyword">typeof</span> comment.message != <span class="tok-string">"string"</span>) {
    <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">400</span>, <span class="tok-definition">body</span>: <span class="tok-string">"Datos de comentario inválidos"</span>};
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (Object.hasOwn(server.talks, title)) {
    server.talks[title].comments.push(comment);
    server.updated();
    <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">204</span>};
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">404</span>, <span class="tok-definition">body</span>: <span class="tok-string2">`No se encontró la charla '</span>${title}<span class="tok-string2'`</span>};
  }
});</pre>
    <p><a class="p_ident" id="p-offphkhUrd" href="#p-offphkhUrd" tabindex="-1" role="presentation"></a>Intentar agregar
      un comentario a una charla inexistente devuelve un error 404.</p>

    <h3><a class="i_ident" id="i-gPETZjVKK3" href="#i-gPETZjVKK3" tabindex="-1" role="presentation"></a>Soporte para
      polling largo</h3>

    <p><a class="p_ident" id="p-9djdnDsKLr" href="#p-9djdnDsKLr" tabindex="-1" role="presentation"></a>El aspecto más
      interesante del servidor es la parte que maneja el polling largo. Cuando llega una solicitud <code>GET</code> para
      <code>/charlas</code>, puede ser una solicitud regular o una solicitud de polling largo.</p>

    <p><a class="p_ident" id="p-jwvB6KBzkt" href="#p-jwB6KBzkt" tabindex="-1" role="presentation"></a>Habrá múltiples
      lugares en los que tendremos que enviar un array de charlas al cliente, así que primero definimos un método
      auxiliar que construye dicho array e incluye un encabezado <code>ETag</code> en la respuesta.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-XiOFQSm9fc" href="#c-XiOFQSm9fc" tabindex="-1" role="presentation"></a>SkillShareServer.prototype.talkResponse = <span class="tok-keyword">function</span>() {
  <span class="tok-keyword">let</span> <span class="tok-definition">charlas</span> = Object.keys(<span class="tok-keyword">this</span>.talks)
    .map(<span class="tok-definition">titulo</span> =&gt; <span class="tok-keyword">this</span>.talks[titulo]);
  <span class="tok-keyword">return</span> {
    <span class="tok-definition">cuerpo</span>: JSON.stringify(charlas),
    <span class="tok-definition">encabezados</span>: {<span class="tok-string">"Content-Type"</span>: <span class="tok-string">"application/json"</span>,
              <span class="tok-string">"ETag"</span>: <span class="tok-string2">`"</span>${<span class="tok-keyword">this</span>.version}<span class="tok-string2">"`</span>,
              <span class="tok-string">"Cache-Control"</span>: <span class="tok-string">"no-store"</span>}
  };
};</pre>

    <p><a class="p_ident" id="p-eW+F9Sakvc" href="#p-eW+F9Sakvc" tabindex="-1" role="presentation"></a>El manejador en
      sí mismo necesita mirar los encabezados de la solicitud para ver si los encabezados <code>If-None-Match</code> y
      <code>Prefer</code> están presentes. Node almacena los encabezados, cuyos nombres se especifican como insensibles
      a mayúsculas y minúsculas, bajo sus nombres en minúsculas.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-/t9cPK34U3" href="#c-/t9cPK34U3" tabindex="-1" role="presentation"></a>router.add(<span class="tok-string">"GET"</span>, <span class="tok-string2">/^\/charlas$/</span>, <span class="tok-keyword">async</span> (<span class="tok-definition">servidor</span>, <span class="tok-definition">solicitud</span>) =&gt; {
  <span class="tok-keyword">let</span> <span class="tok-definition">etiqueta</span> = <span class="tok-string2">/"(.*)"/</span>.exec(solicitud.headers[<span class="tok-string">"if-none-match"</span>]);
  <span class="tok-keyword">let</span> <span class="tok-definition">espera</span> = <span class="tok-string2">/\bwait=(\d+)/</span>.exec(solicitud.headers[<span class="tok-string">"prefer"</span>]);
  <span class="tok-keyword">if</span> (!etiqueta || etiqueta[<span class="tok-number">1</span>] != servidor.version) {
    <span class="tok-keyword">return</span> servidor.talkResponse();
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (!espera) {
    <span class="tok-keyword">return</span> {<span class="tok-definition">estado</span>: <span class="tok-number">304</span>};
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">return</span> servidor.waitForChanges(Number(espera[<span class="tok-number">1</span>]));
  }
});</pre>
    <p><a class="p_ident" id="p-5eDtLyizDw" href="#p-5eDtLyizDw" tabindex="-1" role="presentation"></a>Si no se
      proporcionó una etiqueta o se proporcionó una que no coincide con la versión actual del servidor, el controlador
      responde con la lista de charlas. Si la solicitud es condicional y las charlas no han cambiado, consultamos el
      encabezado <code>Prefer</code> para ver si debemos retrasar la respuesta o responder de inmediato.</p>

    <p><a class="p_ident" id="p-YauV3/x5ZF" href="#p-YauV3/x5ZF" tabindex="-1" role="presentation"></a>Las funciones de
      devolución de llamada para solicitudes diferidas se almacenan en la matriz <code>waiting</code> del servidor para
      que puedan ser notificadas cuando algo suceda. El método <code>waitForChanges</code> también establece
      inmediatamente un temporizador para responder con un estado 304 cuando la solicitud haya esperado el tiempo
      suficiente.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-4a/A2U+gT3" href="#c-4a/A2U+gT3" tabindex="-1" role="presentation"></a>SkillShareServer.prototype.waitForChanges = <span class="tok-keyword">function</span>(<span class="tok-definition">time</span>) {
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Promise(<span class="tok-definition">resolve</span> =&gt; {
    <span class="tok-keyword">this</span>.waiting.push(resolve);
    setTimeout(() =&gt; {
      <span class="tok-keyword">if</span> (!<span class="tok-keyword">this</span>.waiting.includes(resolve)) <span class="tok-keyword">return</span>;
      <span class="tok-keyword">this</span>.waiting = <span class="tok-keyword">this</span>.waiting.filter(<span class="tok-definition">r</span> =&gt; r != resolve);
      resolve({<span class="tok-definition">status</span>: <span class="tok-number">304</span>});
    }, time * <span class="tok-number">1000</span>);
  });
};</pre>

    <p id="updated"><a class="p_ident" id="p-NwQeYwTIHL" href="#p-NwQeYwTIHL" tabindex="-1"
        role="presentation"></a>Registrar un cambio con <code>updated</code> aumenta la propiedad <code>version</code> y
      despierta todas las solicitudes en espera.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-mZ7p2D8VNW" href="#c-mZ7p2D8VNW" tabindex="-1" role="presentation"></a>SkillShareServer.prototype.updated = <span class="tok-keyword">function</span>() {
  <span class="tok-keyword">this</span>.version++;
  <span class="tok-keyword">let</span> <span class="tok-definition">response</span> = <span class="tok-keyword">this</span>.talkResponse();
  <span class="tok-keyword">this</span>.waiting.forEach(<span class="tok-definition">resolve</span> =&gt; resolve(response));
  <span class="tok-keyword">this</span>.waiting = [];
};</pre>

    <p><a class="p_ident" id="p-ts7X+FFBfd" href="#p-ts7X+FFBfd" tabindex="-1" role="presentation"></a>Así concluye el
      código del servidor. Si creamos una instancia de <code>SkillShareServer</code> y lo iniciamos en el puerto 8000,
      el servidor HTTP resultante servirá archivos desde el subdirectorio <code>public</code> junto con una interfaz de
      gestión de charlas bajo la URL <code>/talks</code>.</p>
    <pre tabindex="0" class="snippet"
      data-language="javascript"><a class="c_ident" id="c-aaqy/FYjqn" href="#c-aaqy/FYjqn" tabindex="-1" role="presentation"></a><span class="tok-keyword">new</span> SkillShareServer({}).start(<span class="tok-number">8000</span>);</pre>

    <h2><a class="h_ident" id="h-+jMNtbJ4U3" href="#h-+jMNtbJ4U3" tabindex="-1" role="presentation"></a>El cliente</h2>

    <p><a class="p_ident" id="p-wVvjBUA/vN" href="#p-wVvjBUA/vN" tabindex="-1" role="presentation"></a>La parte del
      cliente del sitio web de intercambio de habilidades consta de tres archivos: una pequeña página HTML, una hoja de
      estilo y un archivo JavaScript.</p>

    <h3><a class="i_ident" id="i-n3OM6EV/KR" href="#i-n3OM6EV/KR" tabindex="-1" role="presentation"></a>HTML</h3>

    <p><a class="p_ident" id="p-jNP5xbaXQN" href="#p-jNP5xbaXQN" tabindex="-1" role="presentation"></a>Es una convención
      ampliamente utilizada para que los servidores web intenten servir un archivo llamado <code>index.html</code>
      cuando se realiza una solicitud directamente a una ruta que corresponde a un directorio. El módulo de servidor de
      archivos que utilizamos, <code>serve-static</code>, soporta esta convención. Cuando se realiza una solicitud a la
      ruta <code>/</code>, el servidor busca el archivo <code>./<wbr>public/<wbr>index.<wbr>html</code> (siendo
      <code>./public</code> la raíz que le dimos) y devuelve ese archivo si se encuentra.</p>

    <p><a class="p_ident" id="p-MdU5OXjZCN" href="#p-MdU5OXjZCN" tabindex="-1" role="presentation"></a>Por lo tanto, si
      queremos que una página aparezca cuando un navegador apunta a nuestro servidor, debemos ponerla en
      <code>public/<wbr>index.<wbr>html</code>. Este es nuestro archivo index:</p>

    <pre tabindex="0" class="snippet"
      data-language="html"><a class="c_ident" id="c-ysNDoq7Ue1" href="#c-ysNDoq7Ue1" tabindex="-1" role="presentation"></a><span class="tok-meta">&lt;!doctype html&gt;</span>
&lt;<span class="tok-typeName">meta</span> charset=<span class="tok-string">"utf-8"</span>&gt;
&lt;<span class="tok-typeName">title</span>&gt;Intercambio de habilidades&lt;/<span class="tok-typeName">title</span>&gt;
&lt;<span class="tok-typeName">link</span> rel=<span class="tok-string">"stylesheet"</span> href=<span class="tok-string">"skillsharing.css"</span>&gt;

&lt;<span class="tok-typeName">h1</span>&gt;Intercambio de habilidades&lt;/<span class="tok-typeName">h1</span>&gt;

&lt;<span class="tok-typeName">script</span> src=<span class="tok-string">"skillsharing_client.js"</span>&gt;&lt;/<span class="tok-typeName">script</span>&gt;</pre>

    <p><a class="p_ident" id="p-vuFR4LpXIa" href="#p-vuFR4LpXIa" tabindex="-1" role="presentation"></a>Define el título
      del documento e incluye una hoja de estilo que define algunos estilos para, entre otras cosas, asegurarse de que
      haya algo de espacio entre las charlas. Luego agrega un encabezado en la parte superior de la página y carga el
      script que contiene la aplicación del lado del cliente.</p>

    <h3><a class="i_ident" id="i-w81jalhbIM" href="#i-w81jalhbIM" tabindex="-1" role="presentation"></a>Acciones</h3>

    <p><a class="p_ident" id="p-bEYXHSjNDU" href="#p-bEYXHSjNDU" tabindex="-1" role="presentation"></a>El estado de la
      aplicación consiste en la lista de charlas y el nombre del usuario, y lo almacenaremos en un objeto
      <code>{charlas, usuario}</code>. No permitimos que la interfaz de usuario manipule directamente el estado ni envíe
      solicitudes HTTP. En cambio, puede emitir <em>acciones</em> que describan lo que el usuario intenta hacer.</p>
    <p><a class="p_ident" id="p-tHOGfwmHo2" href="#p-tHOGfwmHo2" tabindex="-1" role="presentation"></a>La función
      <code>handleAction</code> toma dicha acción y la lleva a cabo. Debido a que nuestras actualizaciones de estado son
      muy simples, los cambios de estado se manejan en la misma función.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-TZfLAx6p12" href="#c-TZfLAx6p12" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">handleAction</span>(<span class="tok-definition">state</span>, <span class="tok-definition">action</span>) {
  <span class="tok-keyword">if</span> (action.type == <span class="tok-string">"setUser"</span>) {
    localStorage.setItem(<span class="tok-string">"userName"</span>, action.user);
    <span class="tok-keyword">return</span> {...state, <span class="tok-definition">user</span>: action.user};
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (action.type == <span class="tok-string">"setTalks"</span>) {
    <span class="tok-keyword">return</span> {...state, <span class="tok-definition">talks</span>: action.talks};
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (action.type == <span class="tok-string">"newTalk"</span>) {
    fetchOK(talkURL(action.title), {
      <span class="tok-definition">method</span>: <span class="tok-string">"PUT"</span>,
      <span class="tok-definition">headers</span>: {<span class="tok-string">"Content-Type"</span>: <span class="tok-string">"application/json"</span>},
      <span class="tok-definition">body</span>: JSON.stringify({
        <span class="tok-definition">presenter</span>: state.user,
        <span class="tok-definition">summary</span>: action.summary
      })
    }).catch(reportError);
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (action.type == <span class="tok-string">"deleteTalk"</span>) {
    fetchOK(talkURL(action.talk), {<span class="tok-definition">method</span>: <span class="tok-string">"DELETE"</span>})
      .catch(reportError);
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (action.type == <span class="tok-string">"newComment"</span>) {
    fetchOK(talkURL(action.talk) + <span class="tok-string">"/comments"</span>, {
      <span class="tok-definition">method</span>: <span class="tok-string">"POST"</span>,
      <span class="tok-definition">headers</span>: {<span class="tok-string">"Content-Type"</span>: <span class="tok-string">"application/json"</span>},
      <span class="tok-definition">body</span>: JSON.stringify({
        <span class="tok-definition">author</span>: state.user,
        <span class="tok-definition">message</span>: action.message
      })
    }).catch(reportError);
  }
  <span class="tok-keyword">return</span> state;
}</pre>

    <p><a class="p_ident" id="p-Uq1nPxr4CD" href="#p-Uq1nPxr4CD" tabindex="-1" role="presentation"></a>Vamos a almacenar
      el nombre del usuario en <code>localStorage</code> para que pueda ser restaurado cuando se cargue la página.</p>
    <p><a class="p_ident" id="p-VcQ5L8zOm7" href="#p-VcQ5L8zOm7" tabindex="-1" role="presentation"></a>Las acciones que
      necesitan involucrar al servidor hacen solicitudes de red, utilizando <code>fetch</code>, a la interfaz HTTP
      descrita anteriormente. Utilizamos una función envoltorio, <code>fetchOK</code>, que se asegura de que la promesa
      devuelta sea rechazada cuando el servidor devuelve un código de error.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-IM58YE2b7h" href="#c-IM58YE2b7h" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">fetchOK</span>(<span class="tok-definition">url</span>, <span class="tok-definition">options</span>) {
  <span class="tok-keyword">return</span> fetch(url, options).then(<span class="tok-definition">response</span> =&gt; {
    <span class="tok-keyword">if</span> (response.status &lt; <span class="tok-number">400</span>) <span class="tok-keyword">return</span> response;
    <span class="tok-keyword">else</span> <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> Error(response.statusText);
  });
}</pre>

    <p><a class="p_ident" id="p-c9CWzDQBPu" href="#p-c9CWzDQBPu" tabindex="-1" role="presentation"></a>Esta función
      auxiliar se utiliza para construir una URL para una charla con un título dado.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-KDfsRI9rOO" href="#c-KDfsRI9rOO" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">talkURL</span>(<span class="tok-definition">title</span>) {
  <span class="tok-keyword">return</span> <span class="tok-string">"talks/"</span> + encodeURIComponent(title);
}</pre>

    <p><a class="p_ident" id="p-gwDxefJOAx" href="#p-gwDxefJOAx" tabindex="-1" role="presentation"></a>Cuando la
      solicitud falla, no queremos que nuestra página se quede simplemente ahí, sin hacer nada sin explicación. Por lo
      tanto, definimos una función llamada <code>reportError</code>, que al menos muestra al usuario un diálogo que le
      indica que algo salió mal.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-upWq63EA/j" href="#c-upWq63EA/j" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">reportError</span>(<span class="tok-definition">error</span>) {
  alert(String(error));
}</pre>

    <h3><a class="i_ident" id="i-C2L6BWc+wz" href="#i-C2L6BWc+wz" tabindex="-1" role="presentation"></a>Renderización de
      componentes</h3>

    <p><a class="p_ident" id="p-dpJwa0vSxW" href="#p-dpJwa0vSxW" tabindex="-1" role="presentation"></a>Utilizaremos un
      enfoque similar al que vimos en <a href="19_paint.html">Capítulo 19</a>, dividiendo la aplicación en componentes.
      Pero dado que algunos de los componentes nunca necesitan actualizarse o siempre se redespliegan por completo al
      actualizarse, definiremos esos no como clases sino como funciones que devuelven directamente un nodo DOM. Por
      ejemplo, aquí hay un componente que muestra el campo donde el usuario puede ingresar su nombre:</p>
    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-XPxLoKIFvt" href="#c-XPxLoKIFvt" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">renderUserField</span>(<span class="tok-definition">name</span>, <span class="tok-definition">dispatch</span>) {
  <span class="tok-keyword">return</span> elt(<span class="tok-string">"label"</span>, {}, <span class="tok-string">"Tu nombre: "</span>, elt(<span class="tok-string">"input"</span>, {
    <span class="tok-definition">type</span>: <span class="tok-string">"text"</span>,
    <span class="tok-definition">value</span>: name,
    <span class="tok-definition">onchange</span>(<span class="tok-definition">event</span>) {
      dispatch({<span class="tok-definition">type</span>: <span class="tok-string">"setUser"</span>, <span class="tok-definition">user</span>: event.target.value});
    }
  }));
}</pre>

    <p><a class="p_ident" id="p-eImxxZOeJD" href="#p-eImxxZOeJD" tabindex="-1" role="presentation"></a>La función
      <code>elt</code> utilizada para construir elementos DOM es la que usamos en <a href="19_paint.html">Capítulo
        19</a>.</p>

    <p><a class="p_ident" id="p-cYex6IZjTT" href="#p-cYex6IZjTT" tabindex="-1" role="presentation"></a>Una función
      similar se utiliza para renderizar charlas, que incluyen una lista de comentarios y un formulario para agregar un
      nuevo comentario.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-VdTnp45oFj" href="#c-VdTnp45oFj" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">renderTalk</span>(<span class="tok-definition">talk</span>, <span class="tok-definition">dispatch</span>) {
  <span class="tok-keyword">return</span> elt(
    <span class="tok-string">"section"</span>, {<span class="tok-definition">className</span>: <span class="tok-string">"talk"</span>},
    elt(<span class="tok-string">"h2"</span>, <span class="tok-keyword">null</span>, talk.title, <span class="tok-string">" "</span>, elt(<span class="tok-string">"button"</span>, {
      <span class="tok-definition">type</span>: <span class="tok-string">"button"</span>,
      <span class="tok-definition">onclick</span>() {
        dispatch({<span class="tok-definition">type</span>: <span class="tok-string">"deleteTalk"</span>, <span class="tok-definition">talk</span>: talk.title});
      }
    }, <span class="tok-string">"Eliminar"</span>)),
    elt(<span class="tok-string">"div"</span>, <span class="tok-keyword">null</span>, <span class="tok-string">"por "</span>,
        elt(<span class="tok-string">"strong"</span>, <span class="tok-keyword">null</span>, talk.presenter)),
    elt(<span class="tok-string">"p"</span>, <span class="tok-keyword">null</span>, talk.summary),
    ...talk.comments.map(renderComment),
    elt(<span class="tok-string">"form"</span>, {
      <span class="tok-definition">onsubmit</span>(<span class="tok-definition">event</span>) {
        event.preventDefault();
        <span class="tok-keyword">let</span> <span class="tok-definition">form</span> = event.target;
        dispatch({<span class="tok-definition">type</span>: <span class="tok-string">"newComment"</span>,
                  <span class="tok-definition">talk</span>: talk.title,
                  <span class="tok-definition">message</span>: form.elements.comment.value});
        form.reset();
      }
    }, elt(<span class="tok-string">"input"</span>, {<span class="tok-definition">type</span>: <span class="tok-string">"text"</span>, <span class="tok-definition">name</span>: <span class="tok-string">"comment"</span>}), <span class="tok-string">" "</span>,
       elt(<span class="tok-string">"button"</span>, {<span class="tok-definition">type</span>: <span class="tok-string">"submit"</span>}, <span class="tok-string">"Agregar comentario"</span>)));
}</pre>
    <p><a class="p_ident" id="p-uhHeAEhpd6" href="#p-uhHeAEhpd6" tabindex="-1" role="presentation"></a>El controlador de
      eventos <code>"submit"</code> llama a <code>form.reset</code> para limpiar el contenido del formulario después de
      crear una acción <code>"newComment"</code>.</p>

    <p><a class="p_ident" id="p-IE2osanrUZ" href="#p-IE2osanrUZ" tabindex="-1" role="presentation"></a>Cuando se crean
      piezas moderadamente complejas de DOM, este estilo de programación comienza a verse bastante desordenado. Para
      evitar esto, la gente a menudo usa un <em>lenguaje de plantillas</em>, que te permite escribir tu interfaz como un
      archivo HTML con algunos marcadores especiales para indicar dónde van elementos dinámicos. O utilizan
      <em>JSX</em>, un dialecto de JavaScript no estándar que te permite escribir algo muy parecido a etiquetas HTML en
      tu programa como si fueran expresiones de JavaScript. Ambos enfoques utilizan herramientas adicionales para
      preprocesar el código antes de que pueda ser ejecutado, lo cual evitaremos en este capítulo.</p>

    <p><a class="p_ident" id="p-fMO3vVoxLH" href="#p-fMO3vVoxLH" tabindex="-1" role="presentation"></a>Renderizar
      comentarios es simple.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-N9+wrVgBuY" href="#c-N9+wrVgBuY" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">renderComment</span>(<span class="tok-definition">comment</span>) {
  <span class="tok-keyword">return</span> elt(<span class="tok-string">"p"</span>, {<span class="tok-definition">className</span>: <span class="tok-string">"comment"</span>},
             elt(<span class="tok-string">"strong"</span>, <span class="tok-keyword">null</span>, comment.author),
             <span class="tok-string">": "</span>, comment.message);
}</pre>

    <p><a class="p_ident" id="p-Z3Iqdng7Q6" href="#p-Z3Iqdng7Q6" tabindex="-1" role="presentation"></a>Finalmente, el
      formulario que el usuario puede utilizar para crear una nueva charla se renderiza de esta forma:</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-CrmrTqBxyk" href="#c-CrmrTqBxyk" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">renderTalkForm</span>(<span class="tok-definition">dispatch</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">title</span> = elt(<span class="tok-string">"input"</span>, {<span class="tok-definition">type</span>: <span class="tok-string">"text"</span>});
  <span class="tok-keyword">let</span> <span class="tok-definition">summary</span> = elt(<span class="tok-string">"input"</span>, {<span class="tok-definition">type</span>: <span class="tok-string">"text"</span>});
  <span class="tok-keyword">return</span> elt(<span class="tok-string">"form"</span>, {
    <span class="tok-definition">onsubmit</span>(<span class="tok-definition">event</span>) {
      event.preventDefault();
      dispatch({<span class="tok-definition">type</span>: <span class="tok-string">"newTalk"</span>,
                <span class="tok-definition">title</span>: title.value,
                <span class="tok-definition">summary</span>: summary.value});
      event.target.reset();
    }
  }, elt(<span class="tok-string">"h3"</span>, <span class="tok-keyword">null</span>, <span class="tok-string">"Enviar una Charla"</span>),
     elt(<span class="tok-string">"label"</span>, <span class="tok-keyword">null</span>, <span class="tok-string">"Título: "</span>, title),
     elt(<span class="tok-string">"label"</span>, <span class="tok-keyword">null</span>, <span class="tok-string">"Resumen: "</span>, summary),
     elt(<span class="tok-string">"button"</span>, {<span class="tok-definition">type</span>: <span class="tok-string">"submit"</span>}, <span class="tok-string">"Enviar"</span>));
}</pre>
    <h3><a class="i_ident" id="i-QESJMin8/J" href="#i-QESJMin8/J" tabindex="-1" role="presentation"></a>Polling</h3>

    <p><a class="p_ident" id="p-MAgZ8zA1qk" href="#p-MAgZ8zA1qk" tabindex="-1" role="presentation"></a>Para iniciar la
      aplicación necesitamos la lista actual de charlas. Dado que la carga inicial está estrechamente relacionada con el
      proceso de polling largo, el <code>ETag</code> de la carga debe ser utilizado durante el polling, escribiremos una
      función que siga haciendo polling al servidor por <code>/talks</code> y llamará a una función de callback cuando
      un nuevo conjunto de charlas esté disponible.</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-y9uqyFVtpt" href="#c-y9uqyFVtpt" tabindex="-1" role="presentation"></a><span class="tok-keyword">async</span> <span class="tok-keyword">function</span> <span class="tok-definition">pollTalks</span>(<span class="tok-definition">update</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">tag</span> = undefined;
  <span class="tok-keyword">for</span> (;;) {
    <span class="tok-keyword">let</span> <span class="tok-definition">response</span>;
    <span class="tok-keyword">try</span> {
      response = <span class="tok-keyword">await</span> fetchOK(<span class="tok-string">"/talks"</span>, {
        <span class="tok-definition">headers</span>: tag &amp;&amp; {<span class="tok-string">"If-None-Match"</span>: tag,
                         <span class="tok-string">"Prefer"</span>: <span class="tok-string">"wait=90"</span>}
      });
    } <span class="tok-keyword">catch</span> (<span class="tok-definition">e</span>) {
      console.log(<span class="tok-string">"La solicitud falló: "</span> + e);
      <span class="tok-keyword">await</span> <span class="tok-keyword">new</span> Promise(<span class="tok-definition">resolve</span> =&gt; setTimeout(resolve, <span class="tok-number">500</span>));
      <span class="tok-keyword">continue</span>;
    }
    <span class="tok-keyword">if</span> (response.status == <span class="tok-number">304</span>) <span class="tok-keyword">continue</span>;
    tag = response.headers.get(<span class="tok-string">"ETag"</span>);
    update(<span class="tok-keyword">await</span> response.json());
  }
}</pre>

    <p><a class="p_ident" id="p-XmvUprtL9b" href="#p-XmvUprtL9b" tabindex="-1" role="presentation"></a>Esta es una
      función <code>async</code> para que el bucle y la espera de la solicitud sean más fáciles. Ejecuta un bucle
      infinito que, en cada iteración, recupera la lista de charlas, ya sea normalmente o, si esta no es la primera
      solicitud, con las cabeceras incluidas que la convierten en una solicitud de long polling.</p>

    <p><a class="p_ident" id="p-4wGPaNuukd" href="#p-4wGPaNuukd" tabindex="-1" role="presentation"></a>Cuando una
      solicitud falla, la función espera un momento y luego lo intenta de nuevo. De esta manera, si tu conexión de red
      se interrumpe por un tiempo y luego vuelve, la aplicación puede recuperarse y continuar actualizándose. La promesa
      resuelta mediante <code>setTimeout</code> es una forma de forzar a la función <code>async</code> a esperar.</p>
    <p><a class="p_ident" id="p-hPYul5CaBK" href="#p-hPYul5CaBK" tabindex="-1" role="presentation"></a>Cuando el
      servidor devuelve una respuesta 304, significa que una solicitud de "long polling" expiró, por lo que la función
      debería iniciar inmediatamente la siguiente solicitud. Si la respuesta es una respuesta normal 200, su cuerpo se
      lee como JSON y se pasa al callback, y el valor del encabezado <code>ETag</code> se almacena para la próxima
      iteración.</p>

    <h3><a class="i_ident" id="i-bxOeMBlEZu" href="#i-bxOeMBlEZu" tabindex="-1" role="presentation"></a>La aplicación
    </h3>

    <p><a class="p_ident" id="p-AhQIfiK0Gw" href="#p-AhQIfiK0Gw" tabindex="-1" role="presentation"></a>El siguiente
      componente une toda la interfaz de usuario:</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-PzYGJXojtl" href="#c-PzYGJXojtl" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> SkillShareApp {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">state</span>, <span class="tok-definition">dispatch</span>) {
    <span class="tok-keyword">this</span>.dispatch = dispatch;
    <span class="tok-keyword">this</span>.talkDOM = elt(<span class="tok-string">"div"</span>, {<span class="tok-definition">className</span>: <span class="tok-string">"talks"</span>});
    <span class="tok-keyword">this</span>.dom = elt(<span class="tok-string">"div"</span>, <span class="tok-keyword">null</span>,
                   renderUserField(state.user, dispatch),
                   <span class="tok-keyword">this</span>.talkDOM,
                   renderTalkForm(dispatch));
    <span class="tok-keyword">this</span>.syncState(state);
  }

  <span class="tok-definition">syncState</span>(<span class="tok-definition">state</span>) {
    <span class="tok-keyword">if</span> (state.talks != <span class="tok-keyword">this</span>.talks) {
      <span class="tok-keyword">this</span>.talkDOM.textContent = <span class="tok-string">""</span>;
      <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">talk</span> <span class="tok-keyword">of</span> state.talks) {
        <span class="tok-keyword">this</span>.talkDOM.appendChild(
          renderTalk(talk, <span class="tok-keyword">this</span>.dispatch));
      }
      <span class="tok-keyword">this</span>.talks = state.talks;
    }
  }
}</pre>

    <p><a class="p_ident" id="p-eC+tHNKRrV" href="#p-eC+tHNKRrV" tabindex="-1" role="presentation"></a>Cuando cambian
      los "talks", este componente vuelve a dibujarlos todos. Esto es simple pero también ineficiente. Volveremos a esto
      en los ejercicios.</p>

    <p><a class="p_ident" id="p-i8K8y4/q6h" href="#p-i8K8y4/q6h" tabindex="-1" role="presentation"></a>Podemos iniciar
      la aplicación de la siguiente manera:</p>

    <pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-6Z6pm4dZOv" href="#c-6Z6pm4dZOv" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">runApp</span>() {
  <span class="tok-keyword">let</span> <span class="tok-definition">user</span> = localStorage.getItem(<span class="tok-string">"userName"</span>) || <span class="tok-string">"Anon"</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">state</span>, <span class="tok-definition">app</span>;
  <span class="tok-keyword">function</span> <span class="tok-definition">dispatch</span>(<span class="tok-definition">action</span>) {
    state = handleAction(state, action);
    app.syncState(state);
  }

```html
  pollTalks(<span class="tok-definition">charlas</span> =&gt; {
    <span class="tok-keyword">if</span> (!app) {
      state = {<span class="tok-definition">usuario</span>, <span class="tok-definition">charlas</span>};
      app = <span class="tok-keyword">new</span> SkillShareApp(state, dispatch);
      document.body.appendChild(app.dom);
    } <span class="tok-keyword">else</span> {
      dispatch({<span class="tok-definition">type</span>: <span class="tok-string">"setCharlas"</span>, <span class="tok-definition">charlas</span>});
    }
  }).catch(reportError);
}

runApp();</pre>

    <p><a class="p_ident" id="p-zfJgnDyZM2" href="#p-zfJgnDyZM2" tabindex="-1" role="presentation"></a>Si ejecutas el
      servidor y abres dos ventanas del navegador para <a
        href="http://localhost:8000/"><em>http://localhost:8000</em></a> una al lado de la otra, puedes ver que las
      acciones que realizas en una ventana son inmediatamente visibles en la otra.</p>

    <h2><a class="h_ident" id="h-TcUD2vzyMe" href="#h-TcUD2vzyMe" tabindex="-1" role="presentation"></a>Ejercicios</h2>

    <p><a class="p_ident" id="p-d53G5uBJj7" href="#p-d53G5uBJj7" tabindex="-1" role="presentation"></a>Los siguientes
      ejercicios implicarán modificar el sistema definido en este capítulo. Para trabajar en ellos, asegúrate de
      descargar primero el código (<a
        href="https://eloquentjavascript.net/code/skillsharing.zip"><em>https://eloquentjavascript.net/code/skillsharing.zip</em></a>),
      tener Node instalado (<a href="https://nodejs.org"><em>https://nodejs.org</em></a>) e instalar las dependencias
      del proyecto con <code>npm install</code>.</p>

    <h3><a class="i_ident" id="i-QcUCZfnLE+" href="#i-QcUCZfnLE+" tabindex="-1" role="presentation"></a>Persistencia en
      disco</h3>

    <p><a class="p_ident" id="p-wtP8pzYaoa" href="#p-wtP8pzYaoa" tabindex="-1" role="presentation"></a>El servidor de
      intercambio de habilidades mantiene sus datos únicamente en memoria. Esto significa que cuando se detiene o se
      reinicia por cualquier motivo, todas las charlas y comentarios se pierden.</p>

    <p><a class="p_ident" id="p-3H2K0biSmc" href="#p-3H2K0biSmc" tabindex="-1" role="presentation"></a>Amplía el
      servidor para que almacene los datos de las charlas en disco y recargue automáticamente los datos cuando se
      reinicie. No te preocupes por la eficiencia, haz lo más simple que funcione.</p>

    <details class="solution">
      <summary>Mostrar pistas...</summary>
      <div class="solution-text">

        <p><a class="p_ident" id="p-VyCgv1RQvk" href="#p-VyCgv1RQvk" tabindex="-1" role="presentation"></a>La solución
          más simple que se me ocurre es codificar todo el objeto <code>charlas</code> como JSON y volcarlo en un
          archivo con <code>writeFile</code>. Ya hay un método (<code>updated</code>) que se llama cada vez que cambian
          los datos del servidor. Se puede ampliar para escribir los nuevos datos en disco.</p>

        <p><a class="p_ident" id="p-Pko5rJ5s3N" href="#p-Pko5rJ5s3N" tabindex="-1" role="presentation"></a>Elige un
          nombre de archivo, por ejemplo <code>./charlas.json</code>. Cuando el servidor se inicie, puede intentar leer
          ese archivo con <code>readFile</code>, y si tiene éxito, el servidor puede usar el contenido del archivo como
          sus datos de inicio.</p>
        ```
      </div>
    </details>

    <h3><a class="i_ident" id="i-oMIXw3b5pk" href="#i-oMIXw3b5pk" tabindex="-1" role="presentation"></a>Reseteo del
      campo de comentarios</h3>

    <p><a class="p_ident" id="p-ZLgsWCWv6a" href="#p-ZLgsWCWv6a" tabindex="-1" role="presentation"></a>El redibujado
      completo de las conversaciones funciona bastante bien porque generalmente no se puede distinguir entre un nodo del
      DOM y su reemplazo idéntico. Pero existen excepciones. Si comienzas a escribir algo en el campo de comentarios
      para una conversación en una ventana del navegador y luego, en otra, agregas un comentario a esa conversación, el
      campo en la primera ventana se redibujará, eliminando tanto su contenido como su foco.</p>

    <p><a class="p_ident" id="p-la+PCSK6bH" href="#p-la+PCSK6bH" tabindex="-1" role="presentation"></a>Cuando varias
      personas están agregando comentarios al mismo tiempo, esto podría resultar molesto. ¿Puedes encontrar una forma de
      solucionarlo?</p>

    <details class="solution">
      <summary>Mostrar pistas...</summary>
      <div class="solution-text">

        <p><a class="p_ident" id="p-OKOD6yxMV5" href="#p-OKOD6yxMV5" tabindex="-1" role="presentation"></a>La mejor
          manera de hacer esto probablemente sea convertir el componente de conversación en un objeto, con un método
          <code>syncState</code>, para que se puedan actualizar y mostrar una versión modificada de la conversación.
          Durante la operación normal, la única forma en la que una conversación puede ser modificada es agregando más
          comentarios, por lo que el método <code>syncState</code> puede ser relativamente simple.</p>

        <p><a class="p_ident" id="p-ZaEDjaSq5N" href="#p-ZaEDjaSq5N" tabindex="-1" role="presentation"></a>La parte
          difícil es que, cuando llega una lista modificada de conversaciones, tenemos que conciliar la lista existente
          de componentes del DOM con las conversaciones de la nueva lista—eliminando componentes cuya conversación fue
          eliminada y actualizando componentes cuya conversación cambió.</p>

        <p><a class="p_ident" id="p-tuOnXu3Qr+" href="#p-tuOnXu3Qr+" tabindex="-1" role="presentation"></a>Para hacer
          esto, podría resultar útil mantener una estructura de datos que almacene los componentes de conversación bajo
          los títulos de las conversaciones para que puedas averiguar fácilmente si existe un componente para una
          conversación determinada. Luego puedes iterar sobre el nuevo array de conversaciones y, para cada una de
          ellas, sincronizar un componente existente o crear uno nuevo. Para eliminar componentes de conversaciones
          eliminadas, también tendrás que iterar sobre los componentes y verificar si las conversaciones
          correspondientes aún existen.</p>

      </div>
    </details>
    <nav><a href="20_node.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html"
        title="portada" aria-label="portada">●</a>&nbsp;<button class="help" title="ayuda"
        aria-label="ayuda"><strong>?</strong></button>
    </nav>
  </article>

  <script src="js/ejs.js"></script>
</body>

</html>
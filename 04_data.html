<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Estructuras de Datos: Objetos y Arrays :: JavaScript Elocuente</title>
  <link rel="stylesheet" href="css/ejs.css"><script>
      var page = {"type":"chapter","number":4,"load_files":["code/journal.js","code/chapter/04_data.js"]}</script></head>

<body><article>
<nav><a href="03_functions.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="05_higher_order.html" title="próximo capítulo" aria-label="próximo capítulo">▸</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>

<h1>Estructuras de Datos: Objetos y Arrays</h1>

<blockquote>

<p><a class="p_ident" id="p-3DGxnMhaad" href="#p-3DGxnMhaad" tabindex="-1" role="presentation"></a>En dos ocasiones me han preguntado: "Rezar, Sr. Babbage, si introduce figuras incorrectas en la máquina, ¿saldrán las respuestas correctas?" [...] No soy capaz de entender correctamente el tipo de confusión de ideas que podría provocar tal pregunta.</p>

<footer>Charles Babbage, <cite>Extractos de la Vida de un Filósofo (1864)</cite></footer>

</blockquote><figure class="chapter framed"><img src="images/chapter_picture_4.jpg" alt="Ilustración de una ardilla junto a una pila de libros y un par de gafas. Una luna y estrellas son visibles en el fondo."></figure>

<p><a class="p_ident" id="p-j/UjCN3npi" href="#p-j/UjCN3npi" tabindex="-1" role="presentation"></a>Los números, booleanos y cadenas son los átomos a partir de los cuales se construyen las estructuras de datos. Sin embargo, muchos tipos de información requieren más de un átomo. Los <em>objetos</em> nos permiten agrupar valores, incluidos otros objetos, para construir estructuras más complejas.</p>

<p><a class="p_ident" id="p-F4YgzUjHcT" href="#p-F4YgzUjHcT" tabindex="-1" role="presentation"></a>Los programas que hemos construido hasta ahora han estado limitados por el hecho de que solo operaban con tipos de datos simples. Después de aprender los conceptos básicos de las estructuras de datos en este capítulo, sabrás lo suficiente como para empezar a escribir programas útiles.</p>

<p><a class="p_ident" id="p-C0gWXpRjbI" href="#p-C0gWXpRjbI" tabindex="-1" role="presentation"></a>El capítulo trabajará a través de un ejemplo de programación más o menos realista, introduciendo conceptos a medida que se aplican al problema en cuestión. El código de ejemplo a menudo se basará en funciones y enlaces introducidos anteriormente en el libro.</p>

<h2><a class="h_ident" id="h-NvjtahQLlw" href="#h-NvjtahQLlw" tabindex="-1" role="presentation"></a>El ardilla humana</h2>

<p><a class="p_ident" id="p-2uQlDOT3CH" href="#p-2uQlDOT3CH" tabindex="-1" role="presentation"></a>De vez en cuando, usualmente entre las 8 p.m. y las 10 p.m., Jacques se encuentra transformándose en un pequeño roedor peludo con una cola espesa.</p>

<p><a class="p_ident" id="p-EIDMzKWaqr" href="#p-EIDMzKWaqr" tabindex="-1" role="presentation"></a>Por un lado, Jacques está bastante contento de que no tenga licantropía clásica. Convertirse en una ardilla causa menos problemas que convertirse en un lobo. En lugar de preocuparse por comer accidentalmente al vecino (<em>eso</em> sería incómodo), se preocupa por ser comido por el gato del vecino. Después de dos ocasiones de despertarse en una rama precariamente delgada en la copa de un roble, desnudo y desorientado, ha tomado la costumbre de cerrar con llave las puertas y ventanas de su habitación por la noche y de poner unas cuantas nueces en el suelo para mantenerse ocupado.</p><p><a class="p_ident" id="p-p0rI7qnh8H" href="#p-p0rI7qnh8H" tabindex="-1" role="presentation"></a>Pero Jacques preferiría deshacerse por completo de su condición. Las ocurrencias irregulares de la transformación le hacen sospechar que podrían ser desencadenadas por algo. Por un tiempo, creyó que solo sucedía en los días en los que había estado cerca de robles. Sin embargo, evitar los robles no resolvió el problema.</p>

<p><a class="p_ident" id="p-I4RF6opRCC" href="#p-I4RF6opRCC" tabindex="-1" role="presentation"></a>Cambiando a un enfoque más científico, Jacques ha comenzado a llevar un registro diario de todo lo que hace en un día determinado y si cambió de forma. Con estos datos espera reducir las condiciones que desencadenan las transformaciones.</p>

<p><a class="p_ident" id="p-WERwFzJu93" href="#p-WERwFzJu93" tabindex="-1" role="presentation"></a>Lo primero que necesita es una estructura de datos para almacenar esta información.</p>

<h2><a class="h_ident" id="h-HjL/otjEJn" href="#h-HjL/otjEJn" tabindex="-1" role="presentation"></a>Conjuntos de datos</h2>

<p><a class="p_ident" id="p-HFLfyQFSDp" href="#p-HFLfyQFSDp" tabindex="-1" role="presentation"></a>Para trabajar con un fragmento de datos digitales, primero tenemos que encontrar una forma de representarlo en la memoria de nuestra máquina. Digamos, por ejemplo, que queremos representar una colección de los números 2, 3, 5, 7 y 11.</p>

<p><a class="p_ident" id="p-cnzv4pg+Wz" href="#p-cnzv4pg+Wz" tabindex="-1" role="presentation"></a>Podríamos ser creativos con las cadenas de texto—después de todo, las cadenas de texto pueden tener cualquier longitud, por lo que podemos poner muchos datos en ellas—y usar <code>"2 3 5 7 11"</code> como nuestra representación. Pero esto es incómodo. Tendríamos que extraer de alguna manera los dígitos y convertirlos nuevamente a números para acceder a ellos.</p>

<p><a class="p_ident" id="p-/aFILq7bDn" href="#p-/aFILq7bDn" tabindex="-1" role="presentation"></a>Afortunadamente, JavaScript proporciona un tipo de dato específico para almacenar secuencias de valores. Se llama un <em>array</em> y se escribe como una lista de valores entre corchetes, separados por comas:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-05cIH1hy/D" href="#c-05cIH1hy/D" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">listaDeNumeros</span> = [<span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">11</span>];
console.log(listaDeNumeros[<span class="tok-number">2</span>]);
<span class="tok-comment">// → 5</span>
console.log(listaDeNumeros[<span class="tok-number">0</span>]);
<span class="tok-comment">// → 2</span>
console.log(listaDeNumeros[<span class="tok-number">2</span> - <span class="tok-number">1</span>]);
<span class="tok-comment">// → 3</span></pre>

<p><a class="p_ident" id="p-xu5bhsrvS2" href="#p-xu5bhsrvS2" tabindex="-1" role="presentation"></a>La notación para acceder a los elementos dentro de un array también utiliza corchetes. Un par de corchetes inmediatamente después de una expresión, con otra expresión en su interior, buscará el elemento en la expresión de la izquierda que corresponda al <em>índice</em> dado por la expresión en los corchetes.</p><p id="array_indexing"><a class="p_ident" id="p-1+NmIJreij" href="#p-1+NmIJreij" tabindex="-1" role="presentation"></a>El primer índice de un array es cero, no uno, por lo que el primer elemento se obtiene con <code>listOfNumbers[0]</code>. El contar desde cero es una tradición larga en tecnología y en cierta manera tiene mucho sentido, pero lleva algo de tiempo acostumbrarse. Piensa en el índice como el número de elementos a omitir, contando desde el inicio del array.</p>

<h2 id="properties"><a class="h_ident" id="h-vGyI2y8HA6" href="#h-vGyI2y8HA6" tabindex="-1" role="presentation"></a>Propiedades</h2>

<p><a class="p_ident" id="p-GC4++VF2pM" href="#p-GC4++VF2pM" tabindex="-1" role="presentation"></a>Hemos visto algunas expresiones como <code>myString.length</code> (para obtener la longitud de un string) y <code>Math.max</code> (la función máxima) en capítulos anteriores. Estas expresiones acceden a una <em>propiedad</em> de algún valor. En el primer caso, accedemos a la propiedad <code>length</code> del valor en <code>myString</code>. En el segundo caso, accedemos a la propiedad llamada <code>max</code> en el objeto <code>Math</code> (que es una colección de constantes y funciones relacionadas con matemáticas).</p>

<p><a class="p_ident" id="p-dTOk+Nu/lR" href="#p-dTOk+Nu/lR" tabindex="-1" role="presentation"></a>Casi todos los valores en JavaScript tienen propiedades. Las excepciones son <code>null</code> y <code>undefined</code>. Si intentas acceder a una propiedad en alguno de estos valores no definidos, obtendrás un error:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-FNR95AymUx" href="#c-FNR95AymUx" tabindex="-1" role="presentation"></a><span class="tok-keyword">null</span>.length;
<span class="tok-comment">// → TypeError: null no tiene propiedades</span></pre>

<p><a class="p_ident" id="p-wm1lZqKJ49" href="#p-wm1lZqKJ49" tabindex="-1" role="presentation"></a>Las dos principales formas para acceder a propiedades en JavaScript son con un punto y con corchetes. Tanto <code>valor.x</code> como <code>valor[x]</code> acceden a una propiedad en <code>valor</code>—pero no necesariamente a la misma propiedad. La diferencia radica en cómo se interpreta <code>x</code>. Al usar un punto, la palabra después del punto es el nombre literal de la propiedad. Al usar corchetes, la expresión entre los corchetes es <em>evaluada</em> para obtener el nombre de la propiedad. Mientras que <code>valor.x</code> obtiene la propiedad de <code>valor</code> llamada "x", <code>valor[x]</code> toma el valor de la variable llamada <code>x</code> y lo usa, convertido a string, como nombre de la propiedad.</p>

<p><a class="p_ident" id="p-IFDhCfCn07" href="#p-IFDhCfCn07" tabindex="-1" role="presentation"></a>Si sabes que la propiedad en la que estás interesado se llama <em>color</em>, dices <code>valor.color</code>. Si deseas extraer la propiedad nombrada por el valor contenido en el binding <code>i</code>, dices <code>valor[i]</code>. Los nombres de las propiedades son strings. Pueden ser cualquier string, pero la notación con punto sólo funciona con nombres que parezcan nombres de bindings válidos—comenzando con una letra o guion bajo, y conteniendo solo letras, números y guiones bajos. Si deseas acceder a una propiedad llamada <em>2</em> o <em>John Doe</em>, debes usar corchetes: <code>valor[2]</code> o <code>valor["John Doe"]</code>.</p><p><a class="p_ident" id="p-v2+DwDjnmO" href="#p-v2+DwDjnmO" tabindex="-1" role="presentation"></a>Los elementos en un array se almacenan como propiedades del array, utilizando números como nombres de propiedad. Como no se puede usar la notación de punto con números y normalmente se quiere usar un enlace que contenga el índice de todas maneras, hay que utilizar la notación de corchetes para acceder a ellos.</p>

<p><a class="p_ident" id="p-Cy6452q54S" href="#p-Cy6452q54S" tabindex="-1" role="presentation"></a>Al igual que las cadenas, los arrays tienen una propiedad <code>length</code> que nos indica cuántos elementos tiene el array.</p>

<h2 id="methods"><a class="h_ident" id="h-fkrGgDyRWc" href="#h-fkrGgDyRWc" tabindex="-1" role="presentation"></a>Métodos</h2>

<p><a class="p_ident" id="p-t1dHhJEzat" href="#p-t1dHhJEzat" tabindex="-1" role="presentation"></a>Tanto los valores de tipo cadena como los de tipo array contienen, además de la propiedad <code>length</code>, una serie de propiedades que contienen valores de función.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-prRDc5amqh" href="#c-prRDc5amqh" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">doh</span> = <span class="tok-string">"Doh"</span>;
console.log(<span class="tok-keyword">typeof</span> doh.toUpperCase);
<span class="tok-comment">// → function</span>
console.log(doh.toUpperCase());
<span class="tok-comment">// → DOH</span></pre>

<p><a class="p_ident" id="p-TWVl3O+8/l" href="#p-TWVl3O+8/l" tabindex="-1" role="presentation"></a>Cada cadena tiene una propiedad <code>toUpperCase</code>. Cuando se llama, devuelve una copia de la cadena en la que todas las letras han sido convertidas a mayúsculas. También existe <code>toLowerCase</code>, que hace lo contrario.</p>

<p><a class="p_ident" id="p-BYc3P/St+z" href="#p-BYc3P/St+z" tabindex="-1" role="presentation"></a>Curiosamente, aunque la llamada a <code>toUpperCase</code> no pasa argumentos, la función de alguna manera accede a la cadena <code>"Doh"</code>, cuya propiedad hemos llamado. Descubrirás cómo funciona esto en <a href="06_object.html#obj_methods">Capítulo 6</a>.</p>

<p><a class="p_ident" id="p-gvO150ZgOs" href="#p-gvO150ZgOs" tabindex="-1" role="presentation"></a>Las propiedades que contienen funciones generalmente se denominan <em>métodos</em> del valor al que pertenecen, como en " <code>toUpperCase</code> es un método de una cadena".</p>

<p id="array_methods"><a class="p_ident" id="p-jl6Ba/aRaG" href="#p-jl6Ba/aRaG" tabindex="-1" role="presentation"></a>Este ejemplo muestra dos métodos que se pueden utilizar para manipular arrays:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-RiFZUNk6gr" href="#c-RiFZUNk6gr" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">sequence</span> = [<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>];
sequence.push(<span class="tok-number">4</span>);
sequence.push(<span class="tok-number">5</span>);
console.log(sequence);
<span class="tok-comment">// → [1, 2, 3, 4, 5]</span>
console.log(sequence.pop());
<span class="tok-comment">// → 5</span>
console.log(sequence);
<span class="tok-comment">// → [1, 2, 3, 4]</span></pre><p><a class="p_ident" id="p-QCPXtNs4aH" href="#p-QCPXtNs4aH" tabindex="-1" role="presentation"></a>El método <code>push</code> añade valores al final de un array. El método <code>pop</code> hace lo contrario, removiendo el último valor en el array y devolviéndolo.</p>

<p><a class="p_ident" id="p-0p3gvnUXoK" href="#p-0p3gvnUXoK" tabindex="-1" role="presentation"></a>Estos nombres algo tontos son términos tradicionales para operaciones en una <em>stack</em> (pila). Una stack, en programación, es una estructura de datos que te permite empujar valores en ella y sacarlos en el orden opuesto para que lo que se agregó último sea lo primero en ser removido. Las stacks son comunes en programación—puedes recordar la pila de llamadas a funciones del <a href="03_functions.html#stack">capítulo anterior</a>, que es una instancia de la misma idea.</p>

<h2><a class="h_ident" id="h-cqg63Sxe3o" href="#h-cqg63Sxe3o" tabindex="-1" role="presentation"></a>Objetos</h2>

<p><a class="p_ident" id="p-D8cm1kz0P8" href="#p-D8cm1kz0P8" tabindex="-1" role="presentation"></a>Volviendo al hombre ardilla. Un conjunto de entradas de registro diario puede ser representado como un array, pero las entradas no consisten solo de un número o una cadena—cada entrada necesita almacenar una lista de actividades y un valor booleano que indique si Jacques se convirtió en una ardilla o no. Idealmente, nos gustaría agrupar estos valores juntos en un solo valor y luego poner esos valores agrupados en un array de entradas de registro.</p>

<p><a class="p_ident" id="p-XVi3Pzlvev" href="#p-XVi3Pzlvev" tabindex="-1" role="presentation"></a>Los valores del tipo <em>object</em> son colecciones arbitrarias de propiedades. Una forma de crear un objeto es usando llaves como una expresión:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Y37a9WsXpl" href="#c-Y37a9WsXpl" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">dia1</span> = {
  <span class="tok-definition">ardilla</span>: false,
  <span class="tok-definition">eventos</span>: [<span class="tok-string">"trabajo"</span>, <span class="tok-string">"tocó un árbol"</span>, <span class="tok-string">"pizza"</span>, <span class="tok-string">"corriendo"</span>]
};
console.log(dia1.ardilla);
<span class="tok-comment">// → false</span>
console.log(dia1.lobo);
<span class="tok-comment">// → undefined</span>
dia1.lobo = false;
console.log(dia1.lobo);
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-SsR4SHTgsC" href="#p-SsR4SHTgsC" tabindex="-1" role="presentation"></a>Dentro de las llaves, escribes una lista de propiedades separadas por comas. Cada propiedad tiene un nombre seguido de dos puntos y un valor. Cuando un objeto se escribe en múltiples líneas, indentarlo como se muestra en este ejemplo ayuda a la legibilidad. Las propiedades cuyos nombres no son nombres de variables válidos o números válidos deben ir entre comillas:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-n8ErtKNPW/" href="#c-n8ErtKNPW/" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">descripciones</span> = {
  <span class="tok-definition">trabajo</span>: <span class="tok-string">"Fui a trabajar"</span>,
  <span class="tok-string">"tocó un árbol"</span>: <span class="tok-string">"Tocó un árbol"</span>
};</pre><p><a class="p_ident" id="p-FUAzRrU5b0" href="#p-FUAzRrU5b0" tabindex="-1" role="presentation"></a>Esto significa que las llaves tienen <em>dos</em> significados en JavaScript. Al comienzo de una sentencia, inician un bloque de sentencias. En cualquier otra posición, describen un objeto. Afortunadamente, rara vez es útil comenzar una sentencia con un objeto en llaves, por lo que la ambigüedad entre estos dos no es demasiado problema. El único caso en el que surge esto es cuando quieres devolver un objeto desde una función de flecha abreviada—no puedes escribir <code>n =&gt; {prop: n}</code>, ya que las llaves serán interpretadas como el cuerpo de una función. En su lugar, debes poner un conjunto de paréntesis alrededor del objeto para dejar claro que es una expresión.</p>

<p><a class="p_ident" id="p-lBjH6GtvXt" href="#p-lBjH6GtvXt" tabindex="-1" role="presentation"></a>Leer una propiedad que no existe te dará el valor <code>undefined</code>.</p>

<p><a class="p_ident" id="p-m1hLPDyHXE" href="#p-m1hLPDyHXE" tabindex="-1" role="presentation"></a>Es posible asignar un valor a una expresión de propiedad con el operador <code>=</code>. Esto reemplazará el valor de la propiedad si ya existía o creará una nueva propiedad en el objeto si no existía.</p>

<p><a class="p_ident" id="p-fcdbXiJaBo" href="#p-fcdbXiJaBo" tabindex="-1" role="presentation"></a>Para volver brevemente a nuestro modelo de enlaces tipo <em>tentáculos</em>—los enlaces de propiedades son similares. <em>Atrapan</em> valores, pero otros enlaces y propiedades podrían estar sosteniendo esos mismos valores. Puedes pensar en los objetos como pulpos con cualquier cantidad de tentáculos, cada uno de los cuales tiene un nombre escrito en él.</p>

<p><a class="p_ident" id="p-nQBjCOh9nC" href="#p-nQBjCOh9nC" tabindex="-1" role="presentation"></a>El operador <code>delete</code> corta un tentáculo de dicho pulpo. Es un operador unario que, cuando se aplica a una propiedad de un objeto, removerá la propiedad nombrada del objeto. No es algo común de hacer, pero es posible.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-66M3B1wG98" href="#c-66M3B1wG98" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">unObjeto</span> = {<span class="tok-definition">izquierda</span>: <span class="tok-number">1</span>, <span class="tok-definition">derecha</span>: <span class="tok-number">2</span>};
console.log(unObjeto.izquierda);
<span class="tok-comment">// → 1</span>
<span class="tok-keyword">delete</span> unObjeto.izquierda;
console.log(unObjeto.izquierda);
<span class="tok-comment">// → undefined</span>
console.log(<span class="tok-string">"izquierda"</span> <span class="tok-keyword">in</span> unObjeto);
<span class="tok-comment">// → false</span>
console.log(<span class="tok-string">"derecha"</span> <span class="tok-keyword">in</span> unObjeto);
<span class="tok-comment">// → true</span></pre>

<p><a class="p_ident" id="p-vVEymXRSvR" href="#p-vVEymXRSvR" tabindex="-1" role="presentation"></a>El operador binario <code>in</code>, cuando se aplica a un string y un objeto, te dice si ese objeto tiene una propiedad con ese nombre. La diferencia entre establecer una propiedad como <code>undefined</code> y realmente eliminarla es que en el primer caso, el objeto todavía <em>tiene</em> la propiedad (simplemente no tiene un valor muy interesante), mientras que en el segundo caso la propiedad ya no está presente y <code>in</code> devolverá <code>false</code>.</p><p><a class="p_ident" id="p-SvMW6lxfp+" href="#p-SvMW6lxfp+" tabindex="-1" role="presentation"></a>Para averiguar qué propiedades tiene un objeto, puedes usar la función <code>Object.keys</code>. Dale la función un objeto y devolverá una matriz de cadenas: los nombres de las propiedades del objeto:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-0oaalmpqn6" href="#c-0oaalmpqn6" tabindex="-1" role="presentation"></a>console.log(Object.keys({<span class="tok-definition">x</span>: <span class="tok-number">0</span>, <span class="tok-definition">y</span>: <span class="tok-number">0</span>, <span class="tok-definition">z</span>: <span class="tok-number">2</span>}));
<span class="tok-comment">// → ["x", "y", "z"]</span></pre>

<p><a class="p_ident" id="p-z4/OPZzTTK" href="#p-z4/OPZzTTK" tabindex="-1" role="presentation"></a>Hay una función <code>Object.assign</code> que copia todas las propiedades de un objeto en otro:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-ngXKayzwiT" href="#c-ngXKayzwiT" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">objectA</span> = {<span class="tok-definition">a</span>: <span class="tok-number">1</span>, <span class="tok-definition">b</span>: <span class="tok-number">2</span>};
Object.assign(objectA, {<span class="tok-definition">b</span>: <span class="tok-number">3</span>, <span class="tok-definition">c</span>: <span class="tok-number">4</span>});
console.log(objectA);
<span class="tok-comment">// → {a: 1, b: 3, c: 4}</span></pre>

<p><a class="p_ident" id="p-Rl8msr9DUz" href="#p-Rl8msr9DUz" tabindex="-1" role="presentation"></a>Los arrays, entonces, son solo un tipo de objeto especializado para almacenar secuencias de cosas. Si evalúas <code>typeof []</code>, produce <code>"object"</code>. Puedes visualizar los arrays como pulpos largos y planos con todos sus tentáculos en una fila ordenada, etiquetados con números.</p>

<p><a class="p_ident" id="p-WVwn19dvlw" href="#p-WVwn19dvlw" tabindex="-1" role="presentation"></a>Jacques representará el diario que mantiene Jacques como un array de objetos:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-H7Np/tieSQ" href="#c-H7Np/tieSQ" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">journal</span> = [
  {<span class="tok-definition">events</span>: [<span class="tok-string">"work"</span>, <span class="tok-string">"touched tree"</span>, <span class="tok-string">"pizza"</span>,
            <span class="tok-string">"running"</span>, <span class="tok-string">"television"</span>],
   <span class="tok-definition">squirrel</span>: false},
  {<span class="tok-definition">events</span>: [<span class="tok-string">"work"</span>, <span class="tok-string">"ice cream"</span>, <span class="tok-string">"cauliflower"</span>,
            <span class="tok-string">"lasagna"</span>, <span class="tok-string">"touched tree"</span>, <span class="tok-string">"brushed teeth"</span>],
   <span class="tok-definition">squirrel</span>: false},
  {<span class="tok-definition">events</span>: [<span class="tok-string">"weekend"</span>, <span class="tok-string">"cycling"</span>, <span class="tok-string">"break"</span>, <span class="tok-string">"peanuts"</span>,
            <span class="tok-string">"beer"</span>],
   <span class="tok-definition">squirrel</span>: true},
  <span class="tok-comment">/* y así sucesivamente... */</span>
];</pre><h2><a class="h_ident" id="h-C3n45IkMhg" href="#h-C3n45IkMhg" tabindex="-1" role="presentation"></a>Mutabilidad</h2>

<p><a class="p_ident" id="p-HZ50qDRWmj" href="#p-HZ50qDRWmj" tabindex="-1" role="presentation"></a>Pronto abordaremos la programación real, pero primero hay una pieza más de teoría para entender.</p>

<p><a class="p_ident" id="p-ZAtU8veKBN" href="#p-ZAtU8veKBN" tabindex="-1" role="presentation"></a>Vimos que los valores de los objetos pueden modificarse. Los tipos de valores discutidos en capítulos anteriores, como números, cadenas y booleanos, son todos <em>inmutables</em>; es imposible cambiar los valores de esos tipos. Puedes combinarlos y derivar nuevos valores a partir de ellos, pero cuando tomas un valor de cadena específico, ese valor siempre permanecerá igual. El texto dentro de él no se puede cambiar. Si tienes una cadena que contiene <code>"gato"</code>, no es posible que otro código cambie un carácter en tu cadena para que escriba <code>"rata"</code>.</p>

<p><a class="p_ident" id="p-0geJong3Bv" href="#p-0geJong3Bv" tabindex="-1" role="presentation"></a>Los objetos funcionan de manera diferente. Sí <em>puedes</em> cambiar sus propiedades, lo que hace que un solo valor de objeto tenga diferente contenido en diferentes momentos.</p>

<p><a class="p_ident" id="p-fVZ1xXAqW5" href="#p-fVZ1xXAqW5" tabindex="-1" role="presentation"></a>Cuando tenemos dos números, 120 y 120, podemos considerarlos exactamente iguales, ya sea que se refieran o no a los mismos bits físicos. Con los objetos, hay una diferencia entre tener dos referencias al mismo objeto y tener dos objetos diferentes que contienen las mismas propiedades. Considera el siguiente código:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-I1Dv6D46/p" href="#c-I1Dv6D46/p" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">objeto1</span> = {<span class="tok-definition">valor</span>: <span class="tok-number">10</span>};
<span class="tok-keyword">let</span> <span class="tok-definition">objeto2</span> = objeto1;
<span class="tok-keyword">let</span> <span class="tok-definition">objeto3</span> = {<span class="tok-definition">valor</span>: <span class="tok-number">10</span>};

console.log(objeto1 == objeto2);
<span class="tok-comment">// → true</span>
console.log(objeto1 == objeto3);
<span class="tok-comment">// → false</span>

objeto1.valor = <span class="tok-number">15</span>;
console.log(objeto2.valor);
<span class="tok-comment">// → 15</span>
console.log(objeto3.valor);
<span class="tok-comment">// → 10</span></pre>

<p><a class="p_ident" id="p-LKrvBk0ldY" href="#p-LKrvBk0ldY" tabindex="-1" role="presentation"></a>Los enlaces <code>objeto1</code> y <code>objeto2</code> apuntan al <em>mismo</em> objeto, por eso, al cambiar <code>objeto1</code> también cambia el valor de <code>objeto2</code>. Se dice que tienen la misma <em>identidad</em>. El enlace <code>objeto3</code> apunta a un objeto diferente, que inicialmente contiene las mismas propiedades que <code>objeto1</code>, pero vive una vida separada.</p><p><a class="p_ident" id="p-eic4GJbroA" href="#p-eic4GJbroA" tabindex="-1" role="presentation"></a>Los enlaces también pueden ser modificables o constantes, pero esto es independiente de cómo se comportan sus valores. Aunque los valores numéricos no cambian, puedes usar un enlace <code>let</code> para hacer un seguimiento de un número cambiante cambiando el valor al que apunta el enlace. De manera similar, aunque un enlace <code>const</code> a un objeto en sí no se puede cambiar y seguirá apuntando al mismo objeto, los <em>contenidos</em> de ese objeto pueden cambiar.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-eOXMRndYxO" href="#c-eOXMRndYxO" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">score</span> = {<span class="tok-definition">visitors</span>: <span class="tok-number">0</span>, <span class="tok-definition">home</span>: <span class="tok-number">0</span>};
<span class="tok-comment">// Esto está bien</span>
score.visitors = <span class="tok-number">1</span>;
<span class="tok-comment">// Esto no está permitido</span>
score = {<span class="tok-definition">visitors</span>: <span class="tok-number">1</span>, <span class="tok-definition">home</span>: <span class="tok-number">1</span>};</pre>

<p><a class="p_ident" id="p-wD7jhXt+Tr" href="#p-wD7jhXt+Tr" tabindex="-1" role="presentation"></a>Cuando comparas objetos con el operador <code>==</code> de JavaScript, compara por identidad: solo producirá <code>true</code> si ambos objetos son exactamente el mismo valor. Comparar objetos diferentes devolverá <code>false</code>, incluso si tienen propiedades idénticas. No existe una operación de comparación "profunda" integrada en JavaScript que compare objetos por contenidos, pero es posible escribirla tú mismo (que es uno de los <a href="04_data.html#exercise_deep_compare">ejercicios</a> al final de este capítulo).</p>

<h2><a class="h_ident" id="h-qHGOoBxOeE" href="#h-qHGOoBxOeE" tabindex="-1" role="presentation"></a>Registro del licántropo</h2>

<p><a class="p_ident" id="p-x/AJh/yvUl" href="#p-x/AJh/yvUl" tabindex="-1" role="presentation"></a>Jacques inicia su intérprete de JavaScript y configura el entorno que necesita para mantener su diario:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-CI+dtzXW/x" href="#c-CI+dtzXW/x" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">journal</span> = [];

<span class="tok-keyword">function</span> <span class="tok-definition">addEntry</span>(<span class="tok-definition">events</span>, <span class="tok-definition">squirrel</span>) {
  journal.push({<span class="tok-definition">events</span>, <span class="tok-definition">squirrel</span>});
}</pre>

<p><a class="p_ident" id="p-ljMiZolRIM" href="#p-ljMiZolRIM" tabindex="-1" role="presentation"></a>Observa que el objeto añadido al diario parece un poco extraño. En lugar de declarar propiedades como <code>events: events</code>, simplemente da un nombre de propiedad: <code>events</code>. Esto es una abreviatura que significa lo mismo: si un nombre de propiedad en notación de llaves no va seguido de un valor, su valor se toma del enlace con el mismo nombre.</p><p><a class="p_ident" id="p-/n5bAuomL7" href="#p-/n5bAuomL7" tabindex="-1" role="presentation"></a>Cada noche a las 10 p. m.—o a veces a la mañana siguiente, después de bajar del estante superior de su estantería—Jacques registra el día:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-S+F+R2oIfR" href="#c-S+F+R2oIfR" tabindex="-1" role="presentation"></a>addEntry([<span class="tok-string">"trabajo"</span>, <span class="tok-string">"tocó árbol"</span>, <span class="tok-string">"pizza"</span>, <span class="tok-string">"correr"</span>,
          <span class="tok-string">"televisión"</span>], false);
addEntry([<span class="tok-string">"trabajo"</span>, <span class="tok-string">"helado"</span>, <span class="tok-string">"coliflor"</span>, <span class="tok-string">"lasaña"</span>,
          <span class="tok-string">"tocó árbol"</span>, <span class="tok-string">"cepilló los dientes"</span>], false);
addEntry([<span class="tok-string">"fin de semana"</span>, <span class="tok-string">"ciclismo"</span>, <span class="tok-string">"descanso"</span>, <span class="tok-string">"cacahuetes"</span>,
          <span class="tok-string">"cerveza"</span>], true);</pre>

<p><a class="p_ident" id="p-7VcOxe4CEu" href="#p-7VcOxe4CEu" tabindex="-1" role="presentation"></a>Una vez que tenga suficientes puntos de datos, tiene la intención de usar estadísticas para averiguar qué eventos pueden estar relacionados con las ardillificaciones.</p>

<p><a class="p_ident" id="p-EedDVNQ30H" href="#p-EedDVNQ30H" tabindex="-1" role="presentation"></a><em>Correlación</em> es una medida de dependencia entre variables estadísticas. Una variable estadística no es exactamente lo mismo que una variable de programación. En estadística típicamente tienes un conjunto de <em>mediciones</em>, y cada variable se mide para cada medición. La correlación entre variables suele expresarse como un valor que va de -1 a 1. Una correlación de cero significa que las variables no están relacionadas. Una correlación de 1 indica que ambas variables están perfectamente relacionadas—si conoces una, también conoces la otra. Un -1 también significa que las variables están perfectamente relacionadas pero son opuestas—cuando una es verdadera, la otra es falsa.</p>

<p><a class="p_ident" id="p-mq//xARuKm" href="#p-mq//xARuKm" tabindex="-1" role="presentation"></a>Para calcular la medida de correlación entre dos variables booleanas, podemos usar el <em>coeficiente phi</em> (<em>ϕ</em>). Esta es una fórmula cuya entrada es una tabla de frecuencias que contiene el número de veces que se observaron las diferentes combinaciones de las variables. La salida de la fórmula es un número entre -1 y 1 que describe la correlación.</p>

<p><a class="p_ident" id="p-enPDgop6ZQ" href="#p-enPDgop6ZQ" tabindex="-1" role="presentation"></a>Podríamos tomar el evento de comer pizza y ponerlo en una tabla de frecuencias como esta, donde cada número indica la cantidad de veces que ocurrió esa combinación en nuestras mediciones.</p><figure><img src="fonts/pizza-squirrel.svg" alt="Una tabla de dos por dos mostrando la variable pizza en el eje horizontal y la variable ardilla en el eje vertical. Cada celda muestra cuántas veces ocurrió esa combinación. En 76 casos, no ocurrió ninguno. En 9 casos, solo fue verdadera la pizza. En 4 casos solo fue verdadera la ardilla. Y en un caso ambas ocurrieron."></figure><p><a class="p_ident" id="p-34XzN30BBH" href="#p-34XzN30BBH" tabindex="-1" role="presentation"></a>Si llamamos a esa tabla <em>n</em>, podemos calcular <em>ϕ</em> usando la siguiente fórmula:</p><div> <table style="border-collapse: collapse; margin-left: 1em;"><tbody><tr>   <td style="vertical-align: middle"><em>ϕ</em> =</td>   <td style="padding-left: .5em">     <div style="border-bottom: 1px solid black; padding: 0 7px;"><em>n</em><sub>11</sub><em>n</em><sub>00</sub> −       <em>n</em><sub>10</sub><em>n</em><sub>01</sub></div>     <div style="padding: 0 7px;">√<span style="border-top: 1px solid black; position: relative; top: 2px;">       <span style="position: relative; top: -4px"><em>n</em><sub>1•</sub><em>n</em><sub>0•</sub><em>n</em><sub>•1</sub><em>n</em><sub>•0</sub></span>     </span></div>   </td> </tr></tbody></table> </div>


<p><a class="p_ident" id="p-BlqmmOB0tg" href="#p-BlqmmOB0tg" tabindex="-1" role="presentation"></a>(Si en este punto estás dejando el libro para concentrarte en un terrible flashback a la clase de matemáticas de décimo grado, ¡espera! No pretendo torturarte con interminables páginas de notación críptica, es solo esta fórmula por ahora. Y aún con esta, todo lo que hacemos es convertirla a JavaScript).</p>

<p><a class="p_ident" id="p-6U87ck4G90" href="#p-6U87ck4G90" tabindex="-1" role="presentation"></a>La notación <em>n</em><sub>01</sub> indica el número de medidas donde la primera variable (ardillez) es falsa (0) y la segunda variable (pizza) es verdadera (1). En la tabla de pizza, <em>n</em><sub>01</sub> es 9.</p>

<p><a class="p_ident" id="p-pweIXp0GRF" href="#p-pweIXp0GRF" tabindex="-1" role="presentation"></a>El valor <em>n</em><sub>1•</sub> se refiere a la suma de todas las medidas donde la primera variable es verdadera, que en la tabla de ejemplo es 5. De manera similar, <em>n</em><sub>•0</sub> se refiere a la suma de las medidas donde la segunda variable es falsa.</p>

<p><a class="p_ident" id="p-ACMn7uvFzz" href="#p-ACMn7uvFzz" tabindex="-1" role="presentation"></a>Entonces, para la tabla de pizza, la parte por encima de la línea de división (el dividendo) sería 1×76−4×9 = 40, y la parte por debajo de ella (el divisor) sería la raíz cuadrada de 5×85×10×80, o √340,000. Esto resulta en que <em>ϕ</em> ≈ 0.069, lo cual es pequeño. Comer pizza no parece tener influencia en las transformaciones.</p>

<h2><a class="h_ident" id="h-YwedOm6SqZ" href="#h-YwedOm6SqZ" tabindex="-1" role="presentation"></a>Calculando correlación</h2>

<p><a class="p_ident" id="p-jn2nhCXEpR" href="#p-jn2nhCXEpR" tabindex="-1" role="presentation"></a>Podemos representar una tabla dos por dos en JavaScript con un array de cuatro elementos (<code>[76, 9, 4, 1]</code>). También podríamos usar otras representaciones, como un array que contenga dos arrays de dos elementos (<code>[[76, 9], [4, 1]]</code>) o un objeto con nombres de propiedades como <code>"11"</code> y <code>"01"</code>, pero el array plano es simple y hace que las expresiones que acceden a la tabla sean agradables y cortas. Interpretaremos los índices del array como números binarios de dos bits, donde el dígito más a la izquierda (más significativo) se refiere a la variable ardilla y el dígito más a la derecha (menos significativo) se refiere a la variable evento. Por ejemplo, el número binario <code>10</code> se refiere al caso donde Jacques se convirtió en ardilla, pero el evento (digamos, "pizza") no ocurrió. Esto sucedió cuatro veces. Y como binario <code>10</code> es 2 en notación decimal, almacenaremos este número en el índice 2 del array.</p><p id="phi_function"><a class="p_ident" id="p-napfsNS5sk" href="#p-napfsNS5sk" tabindex="-1" role="presentation"></a>Esta es la función que calcula el coeficiente <em>ϕ</em> a partir de un array:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-AnoNjFldkv" href="#c-AnoNjFldkv" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">phi</span>(<span class="tok-definition">tabla</span>) {
  <span class="tok-keyword">return</span> (tabla[<span class="tok-number">3</span>] * tabla[<span class="tok-number">0</span>] - tabla[<span class="tok-number">2</span>] * tabla[<span class="tok-number">1</span>]) /
    Math.sqrt((tabla[<span class="tok-number">2</span>] + tabla[<span class="tok-number">3</span>]) *
              (tabla[<span class="tok-number">0</span>] + tabla[<span class="tok-number">1</span>]) *
              (tabla[<span class="tok-number">1</span>] + tabla[<span class="tok-number">3</span>]) *
              (tabla[<span class="tok-number">0</span>] + tabla[<span class="tok-number">2</span>]));
}

console.log(phi([<span class="tok-number">76</span>, <span class="tok-number">9</span>, <span class="tok-number">4</span>, <span class="tok-number">1</span>]));
<span class="tok-comment">// → 0.068599434</span></pre>

<p><a class="p_ident" id="p-DPLO2QZk5F" href="#p-DPLO2QZk5F" tabindex="-1" role="presentation"></a>Esta es una traducción directa de la fórmula <em>ϕ</em> a JavaScript. <code>Math.sqrt</code> es la función de raíz cuadrada, proporcionada por el objeto <code>Math</code> en un entorno JavaScript estándar. Debemos sumar dos campos de la tabla para obtener campos como n<sub>1•</sub> porque las sumas de filas o columnas no se almacenan directamente en nuestra estructura de datos.</p>

<p><a class="p_ident" id="p-AVpGWeJG94" href="#p-AVpGWeJG94" tabindex="-1" role="presentation"></a>Jacques lleva su diario durante tres meses. El conjunto de datos resultante está disponible en el <a href="https://eloquentjavascript.net/code#4">sandbox de codificación</a> para este capítulo, donde se almacena en el enlace <code>JOURNAL</code>, y en un <a href="https://eloquentjavascript.net/code/journal.js">archivo</a> descargable.</p>

<p><a class="p_ident" id="p-sM+4QT8FKs" href="#p-sM+4QT8FKs" tabindex="-1" role="presentation"></a>Para extraer una tabla de dos por dos para un evento específico del diario, debemos recorrer todas las entradas y contar cuántas veces ocurre el evento en relación a las transformaciones de ardillas:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-rfea+FwMb5" href="#c-rfea+FwMb5" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">tablaPara</span>(<span class="tok-definition">evento</span>, <span class="tok-definition">diario</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">tabla</span> = [<span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; diario.length; i++) {
    <span class="tok-keyword">let</span> <span class="tok-definition">entrada</span> = diario[i], <span class="tok-definition">indice</span> = <span class="tok-number">0</span>;
    <span class="tok-keyword">if</span> (entrada.eventos.includes(evento)) indice += <span class="tok-number">1</span>;
    <span class="tok-keyword">if</span> (entrada.ardilla) indice += <span class="tok-number">2</span>;
    tabla[indice] += <span class="tok-number">1</span>;
  }
  <span class="tok-keyword">return</span> tabla;
}

console.log(tableFor(<span class="tok-string">"pizza"</span>, JOURNAL));
<span class="tok-comment">// → [76, 9, 4, 1]</span></pre>

<p><a class="p_ident" id="p-cKYDkrur/D" href="#p-cKYDkrur/D" tabindex="-1" role="presentation"></a>Las Arrays tienen un método <code>includes</code> que verifica si un valor dado existe en la array. La función utiliza esto para determinar si el nombre del evento en el que está interesada forma parte de la lista de eventos de un día determinado.</p>

<p><a class="p_ident" id="p-2jmDtun7lQ" href="#p-2jmDtun7lQ" tabindex="-1" role="presentation"></a>El cuerpo del bucle en <code>tableFor</code> determina en qué casilla de la tabla cae cada entrada del diario verificando si la entrada contiene el evento específico en el que está interesado y si el evento ocurre junto con un incidente de ardilla. El bucle luego agrega uno a la casilla correcta en la tabla.</p>

<p><a class="p_ident" id="p-f0iI+VuF1R" href="#p-f0iI+VuF1R" tabindex="-1" role="presentation"></a>Ahora tenemos las herramientas necesarias para calcular correlaciones individuales. El único paso restante es encontrar una correlación para cada tipo de evento que se haya registrado y ver si hay algo destacable.</p>

<h2 id="for_of_loop"><a class="h_ident" id="h-4WwZLib71C" href="#h-4WwZLib71C" tabindex="-1" role="presentation"></a>Bucles de Array</h2>

<p><a class="p_ident" id="p-NcUX4h3Azc" href="#p-NcUX4h3Azc" tabindex="-1" role="presentation"></a>En la función <code>tableFor</code>, hay un bucle como este:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-pE7VRrRQir" href="#c-pE7VRrRQir" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; JOURNAL.length; i++) {
  <span class="tok-keyword">let</span> <span class="tok-definition">entry</span> = JOURNAL[i];
  <span class="tok-comment">// Hacer algo con entry</span>
}</pre>

<p><a class="p_ident" id="p-MvatvZTKVo" href="#p-MvatvZTKVo" tabindex="-1" role="presentation"></a>Este tipo de bucle es común en JavaScript clásico: recorrer arrays elemento por elemento es algo que surge con frecuencia, y para hacer eso se ejecutaría un contador sobre la longitud de la array y se seleccionaría cada elemento sucesivamente.</p>

<p><a class="p_ident" id="p-Xl/M0+NR/e" href="#p-Xl/M0+NR/e" tabindex="-1" role="presentation"></a>Hay una forma más sencilla de escribir estos bucles en JavaScript moderno:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-OXsCQPvDE1" href="#c-OXsCQPvDE1" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">entry</span> <span class="tok-keyword">of</span> JOURNAL) {
  console.log(<span class="tok-string2">`</span>${entry.events.length}<span class="tok-string2"> eventos.</span>);
}</pre>

<p><a class="p_ident" id="p-LDkHv2luaA" href="#p-LDkHv2luaA" tabindex="-1" role="presentation"></a>Cuando un bucle <code>for</code> utiliza la palabra <code>of</code> después de su definición de variable, recorrerá los elementos del valor dado después de <code>of</code>. Esto funciona no solo para arrays, sino también para strings y algunas otras estructuras de datos. Hablaremos sobre <em>cómo</em> funciona en el <a href="06_object.html">Capítulo 6</a>.</p><h2 id="analysis"><a class="h_ident" id="h-Lg5n7mjqw/" href="#h-Lg5n7mjqw/" tabindex="-1" role="presentation"></a>El análisis final</h2>

<p><a class="p_ident" id="p-BY4xjOyjt5" href="#p-BY4xjOyjt5" tabindex="-1" role="presentation"></a> Necesitamos calcular una correlación para cada tipo de evento que ocurre en el conjunto de datos. Para hacer eso, primero necesitamos <em>encontrar</em> cada tipo de evento.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-P6cqJZBL1M" href="#c-P6cqJZBL1M" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">eventosDiarios</span>(<span class="tok-definition">diario</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">eventos</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">entrada</span> <span class="tok-keyword">of</span> diario) {
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">evento</span> <span class="tok-keyword">of</span> entrada.events) {
      <span class="tok-keyword">if</span> (!eventos.includes(evento)) {
        eventos.push(evento);
      }
    }
  }
  <span class="tok-keyword">return</span> eventos;
}

console.log(eventosDiarios(DIARIO));
<span class="tok-comment">// → ["zanahoria", "ejercicio", "fin de semana", "pan", …]</span></pre>

<p><a class="p_ident" id="p-prPslkN5JU" href="#p-prPslkN5JU" tabindex="-1" role="presentation"></a>Al agregar cualquier nombre de evento que no esté aún en él al array <code>eventos</code>, la función recopila cada tipo de evento.</p>

<p><a class="p_ident" id="p-316GVT+FAl" href="#p-316GVT+FAl" tabindex="-1" role="presentation"></a>Usando esa función, podemos ver todas las correlaciones:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-7ws9oWaneM" href="#c-7ws9oWaneM" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">evento</span> <span class="tok-keyword">of</span> eventosDiarios(DIARIO)) {
  console.log(evento + <span class="tok-string">":"</span>, phi(tablaPara(evento, DIARIO)));
}
<span class="tok-comment">// → zanahoria:   0.0140970969</span>
<span class="tok-comment">// → ejercicio: 0.0685994341</span>
<span class="tok-comment">// → fin de semana:  0.1371988681</span>
<span class="tok-comment">// → pan:   -0.0757554019</span>
<span class="tok-comment">// → pudín: -0.0648203724</span>
<span class="tok-comment">// y así sucesivamente...</span></pre>

<p><a class="p_ident" id="p-TiI6dIjE18" href="#p-TiI6dIjE18" tabindex="-1" role="presentation"></a>La mayoría de las correlaciones parecen estar cerca de cero. Comer zanahorias, pan o pudín aparentemente no desencadena la escuilo-licantropía. Las transformaciones parecen ocurrir un poco más a menudo los fines de semana. Vamos a filtrar los resultados para mostrar solo correlaciones mayores a 0.1 o menores a -0.1:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-hBXzmb7hPU" href="#c-hBXzmb7hPU" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">evento</span> <span class="tok-keyword">of</span> eventosDiarios(DIARIO)) {
  <span class="tok-keyword">let</span> <span class="tok-definition">correlación</span> = phi(tablaPara(evento, DIARIO));
  <span class="tok-keyword">if</span> (correlación &gt; <span class="tok-number">0.1</span> || correlación &lt; -<span class="tok-number">0.1</span>) {
    console.log(evento + <span class="tok-string">":"</span>, correlación);
  }
}
<span class="tok-comment">// → fin de semana:        0.1371988681</span>
<span class="tok-comment">// → cepillarse los dientes: -0.3805211953</span>
<span class="tok-comment">// → dulces:          0.1296407447</span>
<span class="tok-comment">// → trabajo:          -0.1371988681</span>
<span class="tok-comment">// → espaguetis:      0.2425356250</span>
<span class="tok-comment">// → leer:        0.1106828054</span>
<span class="tok-comment">// → cacahuetes:        0.5902679812</span></pre><p><a class="p_ident" id="p-SmM3fqump2" href="#p-SmM3fqump2" tabindex="-1" role="presentation"></a>Aha! Hay dos factores con una correlación claramente más fuerte que los demás. Comer cacahuetes tiene un efecto positivo fuerte en la probabilidad de convertirse en una ardilla, mientras que cepillarse los dientes tiene un efecto negativo significativo.</p>

<p><a class="p_ident" id="p-CGdrhu89cM" href="#p-CGdrhu89cM" tabindex="-1" role="presentation"></a>Interesante. Probemos algo:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-x7WUJStSIp" href="#c-x7WUJStSIp" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">entry</span> <span class="tok-keyword">of</span> JOURNAL) {
  <span class="tok-keyword">if</span> (entry.events.includes(<span class="tok-string">"peanuts"</span>) &amp;&amp;
     !entry.events.includes(<span class="tok-string">"brushed teeth"</span>)) {
    entry.events.push(<span class="tok-string">"peanut teeth"</span>);
  }
}
console.log(phi(tableFor(<span class="tok-string">"peanut teeth"</span>, JOURNAL)));
<span class="tok-comment">// → 1</span></pre>

<p><a class="p_ident" id="p-/w8KZsgoPG" href="#p-/w8KZsgoPG" tabindex="-1" role="presentation"></a>Ese es un resultado fuerte. El fenómeno ocurre precisamente cuando Jacques come cacahuetes y no se cepilla los dientes. Si solo no fuera tan descuidado con su higiene dental, ni siquiera habría notado su aflicción.</p>

<p><a class="p_ident" id="p-ZWYYp+hAXk" href="#p-ZWYYp+hAXk" tabindex="-1" role="presentation"></a>Sabiendo esto, Jacques deja de comer cacahuetes por completo y descubre que sus transformaciones se detienen.</p>

<p><a class="p_ident" id="p-TSpXEG8K4k" href="#p-TSpXEG8K4k" tabindex="-1" role="presentation"></a>Pero solo pasan unos meses para que se dé cuenta de que algo falta en esta forma de vivir completamente humana. Sin sus aventuras salvajes, Jacques apenas se siente vivo en absoluto. Decide que prefiere ser un animal salvaje a tiempo completo. Después de construir una hermosa casita en el árbol en el bosque y equiparla con un dispensador de mantequilla de cacahuate y un suministro de diez años de mantequilla de cacahuate, cambia de forma una última vez y vive la corta y enérgica vida de una ardilla.</p>

<h2><a class="h_ident" id="h-GFaxee4PuU" href="#h-GFaxee4PuU" tabindex="-1" role="presentation"></a>Más sobre arrays</h2>

<p><a class="p_ident" id="p-ohl5sM8Idr" href="#p-ohl5sM8Idr" tabindex="-1" role="presentation"></a>Antes de terminar el capítulo, quiero presentarte a algunos conceptos más relacionados con objetos. Comenzaré presentando algunos métodos de arrays generalmente útiles.</p>

<p><a class="p_ident" id="p-Px7nduaW01" href="#p-Px7nduaW01" tabindex="-1" role="presentation"></a>Vimos <code>push</code> y <code>pop</code>, que añaden y eliminan elementos al final de un array, <a href="04_data.html#array_methods">anteriormente</a> en este capítulo. Los métodos correspondientes para agregar y eliminar cosas al inicio de un array se llaman <code>unshift</code> y <code>shift</code>.</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Vq1IBpy+hP" href="#c-Vq1IBpy+hP" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">todoList</span> = [];
<span class="tok-keyword">function</span> <span class="tok-definition">remember</span>(<span class="tok-definition">task</span>) {
  todoList.push(task);
}
<span class="tok-keyword">function</span> <span class="tok-definition">getTask</span>() {
  <span class="tok-keyword">return</span> todoList.shift();
}
<span class="tok-keyword">function</span> <span class="tok-definition">rememberUrgently</span>(<span class="tok-definition">task</span>) {
  todoList.unshift(task);
}</pre>

<p><a class="p_ident" id="p-L9GaeWkvZv" href="#p-L9GaeWkvZv" tabindex="-1" role="presentation"></a>This program manages a queue of tasks. You add tasks to the end of the queue by calling <code>remember("groceries")</code>, and when you’re ready to do something, you call <code>getTask()</code> to get (and remove) the front item from the queue. The <code>rememberUrgently</code> function also adds a task but adds it to the front instead of the back of the queue.</p>

<p><a class="p_ident" id="p-7ZuNdCzsc+" href="#p-7ZuNdCzsc+" tabindex="-1" role="presentation"></a>To search for a specific value, arrays provide an <code>indexOf</code> method. The method searches through the array from the start to the end and returns the index at which the requested value was found—or -1 if it wasn’t found. To search from the end instead of the start, there’s a similar method called <code>lastIndexOf</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-N+G0EtTfto" href="#c-N+G0EtTfto" tabindex="-1" role="presentation"></a>console.log([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>].indexOf(<span class="tok-number">2</span>));
<span class="tok-comment">// → 1</span>
console.log([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>].lastIndexOf(<span class="tok-number">2</span>));
<span class="tok-comment">// → 3</span></pre>

<p><a class="p_ident" id="p-zErdHcwkcD" href="#p-zErdHcwkcD" tabindex="-1" role="presentation"></a>Both <code>indexOf</code> and <code>lastIndexOf</code> take an optional second argument that indicates where to start searching.</p>

<p><a class="p_ident" id="p-xl0kBHXnu2" href="#p-xl0kBHXnu2" tabindex="-1" role="presentation"></a>Another fundamental array method is <code>slice</code>, which takes start and end indices and returns an array that has only the elements between them. The start index is inclusive, the end index exclusive.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-zCBzPnMpIk" href="#c-zCBzPnMpIk" tabindex="-1" role="presentation"></a>console.log([<span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>].slice(<span class="tok-number">2</span>, <span class="tok-number">4</span>));
<span class="tok-comment">// → [2, 3]</span>
console.log([<span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>].slice(<span class="tok-number">2</span>));
<span class="tok-comment">// → [2, 3, 4]</span></pre><p><a class="p_ident" id="p-goepTIyW2N" href="#p-goepTIyW2N" tabindex="-1" role="presentation"></a>Cuando no se proporciona el índice de fin, <code>slice</code> tomará todos los elementos después del índice de inicio. También puedes omitir el índice de inicio para copiar todo el array.</p>

<p><a class="p_ident" id="p-QNFIcCtVLd" href="#p-QNFIcCtVLd" tabindex="-1" role="presentation"></a>El método <code>concat</code> se puede utilizar para concatenar arrays y crear un nuevo array, similar a lo que el operador <code>+</code> hace con las cadenas.</p>

<p><a class="p_ident" id="p-x8OwNmbLzo" href="#p-x8OwNmbLzo" tabindex="-1" role="presentation"></a>El siguiente ejemplo muestra tanto <code>concat</code> como <code>slice</code> en acción. Toma un array y un índice, y devuelve un nuevo array que es una copia del array original con el elemento en el índice dado eliminado:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-q+NBMNgFFy" href="#c-q+NBMNgFFy" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">remove</span>(<span class="tok-definition">array</span>, <span class="tok-definition">index</span>) {
  <span class="tok-keyword">return</span> array.slice(<span class="tok-number">0</span>, index)
    .concat(array.slice(index + <span class="tok-number">1</span>));
}
console.log(remove([<span class="tok-string">"a"</span>, <span class="tok-string">"b"</span>, <span class="tok-string">"c"</span>, <span class="tok-string">"d"</span>, <span class="tok-string">"e"</span>], <span class="tok-number">2</span>));
<span class="tok-comment">// → ["a", "b", "d", "e"]</span></pre>

<p><a class="p_ident" id="p-RxH5uQN5Uq" href="#p-RxH5uQN5Uq" tabindex="-1" role="presentation"></a>Si pasas a <code>concat</code> un argumento que no es un array, ese valor se añadirá al nuevo array como si fuera un array de un solo elemento.</p>

<h2><a class="h_ident" id="h-mT4YQfwHp6" href="#h-mT4YQfwHp6" tabindex="-1" role="presentation"></a>Cadenas y sus propiedades</h2>

<p><a class="p_ident" id="p-sp+O+Km+2n" href="#p-sp+O+Km+2n" tabindex="-1" role="presentation"></a>Puedes leer propiedades como <code>length</code> y <code>toUpperCase</code> de valores de cadena. Pero si intentamos añadir una nueva propiedad, no se mantendrá.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-xvzL9wErq7" href="#c-xvzL9wErq7" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">kim</span> = <span class="tok-string">"Kim"</span>;
kim.age = <span class="tok-number">88</span>;
console.log(kim.age);
<span class="tok-comment">// → undefined</span></pre>

<p><a class="p_ident" id="p-B+oSPYAIbV" href="#p-B+oSPYAIbV" tabindex="-1" role="presentation"></a>Los valores de tipo string, number y Boolean no son objetos, y aunque el lenguaje no se queja si intentas establecer nuevas propiedades en ellos, en realidad no almacena esas propiedades. Como se mencionó anteriormente, dichos valores son inmutables y no se pueden cambiar.</p><p><a class="p_ident" id="p-8L2ib2beYN" href="#p-8L2ib2beYN" tabindex="-1" role="presentation"></a>Pero estos tipos sí tienen propiedades integradas. Cada valor de cadena tiene varios métodos. Algunos muy útiles son <code>slice</code> y <code>indexOf</code>, que se asemejan a los métodos de array del mismo nombre:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-/Tmq1doYeG" href="#c-/Tmq1doYeG" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"coconuts"</span>.slice(<span class="tok-number">4</span>, <span class="tok-number">7</span>));
<span class="tok-comment">// → nut</span>
console.log(<span class="tok-string">"coconut"</span>.indexOf(<span class="tok-string">"u"</span>));
<span class="tok-comment">// → 5</span></pre>

<p><a class="p_ident" id="p-RUd6q+Q4dc" href="#p-RUd6q+Q4dc" tabindex="-1" role="presentation"></a>Una diferencia es que el método <code>indexOf</code> de una cadena puede buscar una cadena que contenga más de un carácter, mientras que el método de array correspondiente busca solo un elemento único:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-xM5/GBnZVG" href="#c-xM5/GBnZVG" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"one two three"</span>.indexOf(<span class="tok-string">"ee"</span>));
<span class="tok-comment">// → 11</span></pre>

<p><a class="p_ident" id="p-USclxilOGS" href="#p-USclxilOGS" tabindex="-1" role="presentation"></a>El método <code>trim</code> elimina los espacios en blanco (espacios, saltos de línea, tabulaciones y caracteres similares) del principio y final de una cadena:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-0AfLRWyjq0" href="#c-0AfLRWyjq0" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"  okay </span><span class="tok-string2">\n</span><span class="tok-string"> "</span>.trim());
<span class="tok-comment">// → okay</span></pre>

<p id="padStart"><a class="p_ident" id="p-pSkK9k9R0g" href="#p-pSkK9k9R0g" tabindex="-1" role="presentation"></a>La función <code>zeroPad</code> del <a href="03_functions.html">capítulo anterior</a> también existe como un método. Se llama <code>padStart</code> y toma la longitud deseada y el carácter de relleno como argumentos:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-SJbD9MiYu+" href="#c-SJbD9MiYu+" tabindex="-1" role="presentation"></a>console.log(String(<span class="tok-number">6</span>).padStart(<span class="tok-number">3</span>, <span class="tok-string">"0"</span>));
<span class="tok-comment">// → 006</span></pre>

<p id="split"><a class="p_ident" id="p-/nMvmESoIj" href="#p-/nMvmESoIj" tabindex="-1" role="presentation"></a>Puedes dividir una cadena en cada ocurrencia de otra cadena con <code>split</code> y unirla de nuevo con <code>join</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-/rV2Ed5e8V" href="#c-/rV2Ed5e8V" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">sentence</span> = <span class="tok-string">"Secretarybirds specialize in stomping"</span>;
<span class="tok-keyword">let</span> <span class="tok-definition">words</span> = sentence.split(<span class="tok-string">" "</span>);
console.log(words);
<span class="tok-comment">// → ["Secretarybirds", "specialize", "in", "stomping"]</span>
console.log(words.join(<span class="tok-string">". "</span>));
<span class="tok-comment">// → Secretarybirds. specialize. in. stomping</span></pre><p><a class="p_ident" id="p-3VBrEittN5" href="#p-3VBrEittN5" tabindex="-1" role="presentation"></a>Una cadena puede repetirse con el método <code>repeat</code>, el cual crea una nueva cadena que contiene múltiples copias de la cadena original, pegadas juntas:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-70WotkNADb" href="#c-70WotkNADb" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"LA"</span>.repeat(<span class="tok-number">3</span>));
<span class="tok-comment">// → LALALA</span></pre>

<p><a class="p_ident" id="p-JoGJxr+Ofe" href="#p-JoGJxr+Ofe" tabindex="-1" role="presentation"></a>Ya hemos visto la propiedad <code>length</code> del tipo string. Acceder a los caracteres individuales en una cadena se ve como acceder a los elementos de un array (con una complicación que discutiremos en el <a href="05_higher_order.html#code_units">Capítulo 5</a>).</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Aeop9AuKAb" href="#c-Aeop9AuKAb" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">string</span> = <span class="tok-string">"abc"</span>;
console.log(string.length);
<span class="tok-comment">// → 3</span>
console.log(string[<span class="tok-number">1</span>]);
<span class="tok-comment">// → b</span></pre>

<h2 id="rest_parameters"><a class="h_ident" id="h-hX9DkIBp9y" href="#h-hX9DkIBp9y" tabindex="-1" role="presentation"></a>Parámetros restantes</h2>

<p><a class="p_ident" id="p-/k7jj3oaN5" href="#p-/k7jj3oaN5" tabindex="-1" role="presentation"></a>Puede ser útil para una función aceptar cualquier número de argumentos. Por ejemplo, <code>Math.max</code> calcula el máximo de <em>todos</em> los argumentos que recibe. Para escribir una función así, se colocan tres puntos antes del último parámetro de la función, de esta forma:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-UXPbyGFVIB" href="#c-UXPbyGFVIB" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">max</span>(...<span class="tok-definition">numbers</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">result</span> = -Infinity;
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">number</span> <span class="tok-keyword">of</span> numbers) {
    <span class="tok-keyword">if</span> (number &gt; result) result = number;
  }
  <span class="tok-keyword">return</span> result;
}
console.log(max(<span class="tok-number">4</span>, <span class="tok-number">1</span>, <span class="tok-number">9</span>, -<span class="tok-number">2</span>));
<span class="tok-comment">// → 9</span></pre>

<p><a class="p_ident" id="p-rGoFNpUuEy" href="#p-rGoFNpUuEy" tabindex="-1" role="presentation"></a>Cuando se llama a una función de esta manera, el <em>parámetro restante</em> está ligado a un array que contiene todos los argumentos restantes. Si hay otros parámetros antes que él, sus valores no formarán parte de ese array. Cuando, como en <code>max</code>, es el único parámetro, contendrá todos los argumentos.</p><p><a class="p_ident" id="p-7abYMB0i3P" href="#p-7abYMB0i3P" tabindex="-1" role="presentation"></a>Puedes usar una notación similar de tres puntos para <em>llamar</em> a una función con un array de argumentos:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-h9hmTe3vix" href="#c-h9hmTe3vix" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">numbers</span> = [<span class="tok-number">5</span>, <span class="tok-number">1</span>, <span class="tok-number">7</span>];
console.log(max(...numbers));
<span class="tok-comment">// → 7</span></pre>

<p><a class="p_ident" id="p-Q6Tzyy9eaj" href="#p-Q6Tzyy9eaj" tabindex="-1" role="presentation"></a>Esto "esparce" el array en la llamada a la función, pasando sus elementos como argumentos separados. Es posible incluir un array de esa manera junto con otros argumentos, como en <code>max(9, .<wbr>.<wbr>.<wbr>numbers, 2)</code>.</p>

<p><a class="p_ident" id="p-/SfVO/tjcB" href="#p-/SfVO/tjcB" tabindex="-1" role="presentation"></a>La notación de array con corchetes cuadrados de forma similar permite que el operador de tres puntos esparza otro array en el nuevo array:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-4t+LJt3Kyo" href="#c-4t+LJt3Kyo" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">words</span> = [<span class="tok-string">"never"</span>, <span class="tok-string">"fully"</span>];
console.log([<span class="tok-string">"will"</span>, ...words, <span class="tok-string">"understand"</span>]);
<span class="tok-comment">// → ["will", "never", "fully", "understand"]</span></pre>

<p><a class="p_ident" id="p-nSrEDCBbJD" href="#p-nSrEDCBbJD" tabindex="-1" role="presentation"></a>Esto funciona incluso en objetos con llaves, donde agrega todas las propiedades de otro objeto. Si una propiedad se agrega varias veces, gana el último valor agregado:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-R8ckVyEB1L" href="#c-R8ckVyEB1L" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">coordinates</span> = {<span class="tok-definition">x</span>: <span class="tok-number">10</span>, <span class="tok-definition">y</span>: <span class="tok-number">0</span>};
console.log({...coordinates, <span class="tok-definition">y</span>: <span class="tok-number">5</span>, <span class="tok-definition">z</span>: <span class="tok-number">1</span>});
<span class="tok-comment">// → {x: 10, y: 5, z: 1}</span></pre>

<h2><a class="h_ident" id="h-C51DnYk8WZ" href="#h-C51DnYk8WZ" tabindex="-1" role="presentation"></a>El objeto Math</h2>

<p><a class="p_ident" id="p-h3aa0itA5J" href="#p-h3aa0itA5J" tabindex="-1" role="presentation"></a>Como hemos visto, <code>Math</code> es una colección de funciones de utilidad relacionadas con números, tales como <code>Math.max</code> (máximo), <code>Math.min</code> (mínimo) y <code>Math.sqrt</code> (raíz cuadrada).</p><p id="namespace_pollution"><a class="p_ident" id="p-Sae3fXYP2/" href="#p-Sae3fXYP2/" tabindex="-1" role="presentation"></a>El objeto <code>Math</code> se utiliza como un contenedor para agrupar un montón de funcionalidades relacionadas. Solo hay un objeto <code>Math</code>, y casi nunca es útil como un valor. Más bien, proporciona un <em>espacio de nombres</em> para que todas estas funciones y valores no tengan que ser vinculaciones globales.</p>

<p><a class="p_ident" id="p-fGEMziAXhp" href="#p-fGEMziAXhp" tabindex="-1" role="presentation"></a>Tener demasiadas vinculaciones globales "contamina" el espacio de nombres. Cuantos más nombres se hayan tomado, más probable es que sobrescribas accidentalmente el valor de alguna vinculación existente. Por ejemplo, es probable que quieras nombrar algo <code>max</code> en uno de tus programas. Dado que la función <code>max</code> incorporada de JavaScript está protegida dentro del objeto <code>Math</code>, no tienes que preocuparte por sobrescribirla.</p>

<p><a class="p_ident" id="p-GbzMjeRmsU" href="#p-GbzMjeRmsU" tabindex="-1" role="presentation"></a>Muchos lenguajes te detendrán, o al menos te avisarán, cuando estés definiendo una vinculación con un nombre que ya está tomado. JavaScript hace esto para vinculaciones que declaraste con <code>let</code> o <code>const</code> pero, perversamente, no lo hace para vinculaciones estándar ni para vinculaciones declaradas con <code>var</code> o <code>function</code>.</p>

<p><a class="p_ident" id="p-zWXQRNgLI/" href="#p-zWXQRNgLI/" tabindex="-1" role="presentation"></a>Volvamos al objeto <code>Math</code>. Si necesitas hacer trigonometría, <code>Math</code> puede ayudarte. Contiene <code>cos</code> (coseno), <code>sin</code> (seno) y <code>tan</code> (tangente), así como sus funciones inversas, <code>acos</code>, <code>asin</code> y <code>atan</code>, respectivamente. El número π (pi)—o al menos la aproximación más cercana que cabe en un número de JavaScript—está disponible como <code>Math.PI</code>. Hay una antigua tradición de programación de escribir los nombres de valores constantes en mayúsculas:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-54zxf+2nsU" href="#c-54zxf+2nsU" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">randomPointOnCircle</span>(<span class="tok-definition">radio</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">ángulo</span> = Math.random() * <span class="tok-number">2</span> * Math.PI;
  <span class="tok-keyword">return</span> {<span class="tok-definition">x</span>: radio * Math.cos(ángulo),
          <span class="tok-definition">y</span>: radio * Math.sin(ángulo)};
}
console.log(randomPointOnCircle(<span class="tok-number">2</span>));
<span class="tok-comment">// → {x: 0.3667, y: 1.966}</span></pre>

<p><a class="p_ident" id="p-FInqPaWe7p" href="#p-FInqPaWe7p" tabindex="-1" role="presentation"></a>Si no estás familiarizado con senos y cosenos, no te preocupes. Los explicaré cuando se utilicen en este libro, en <a href="14_dom.html#sin_cos">Capítulo 14</a>.</p><p><a class="p_ident" id="p-a6xMq73yCc" href="#p-a6xMq73yCc" tabindex="-1" role="presentation"></a>El ejemplo anterior utilizó <code>Math.random</code>. Esta es una función que devuelve un nuevo número pseudoaleatorio entre cero (inclusive) y uno (exclusivo) cada vez que la llamas:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-+gqW4B1qk1" href="#c-+gqW4B1qk1" tabindex="-1" role="presentation"></a>console.log(Math.random());
<span class="tok-comment">// → 0.36993729369714856</span>
console.log(Math.random());
<span class="tok-comment">// → 0.727367032552138</span>
console.log(Math.random());
<span class="tok-comment">// → 0.40180766698904335</span></pre>

<p><a class="p_ident" id="p-Kd0tokTBKZ" href="#p-Kd0tokTBKZ" tabindex="-1" role="presentation"></a>Aunque las computadoras son máquinas determinísticas —siempre reaccionan de la misma manera si se les da la misma entrada— es posible hacer que produzcan números que parecen aleatorios. Para lograrlo, la máquina mantiene un valor oculto y, cada vez que pides un nuevo número aleatorio, realiza cálculos complicados en este valor oculto para crear un nuevo valor. Almacena un nuevo valor y devuelve algún número derivado de él. De esta manera, puede producir constantemente nuevos números difíciles de predecir de una manera que <em>parece</em> aleatoria.</p>

<p><a class="p_ident" id="p-YqJwVQC0me" href="#p-YqJwVQC0me" tabindex="-1" role="presentation"></a>Si queremos obtener un número aleatorio entero en lugar de uno fraccionario, podemos usar <code>Math.floor</code> (que redondea hacia abajo al número entero más cercano) en el resultado de <code>Math.random</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-LlfOX4tbSH" href="#c-LlfOX4tbSH" tabindex="-1" role="presentation"></a>console.log(Math.floor(Math.random() * <span class="tok-number">10</span>));
<span class="tok-comment">// → 2</span></pre>

<p><a class="p_ident" id="p-52aDRkOsyH" href="#p-52aDRkOsyH" tabindex="-1" role="presentation"></a>Multiplicar el número aleatorio por 10 nos da un número mayor o igual a 0 y menor a 10. Dado que <code>Math.floor</code> redondea hacia abajo, esta expresión producirá, con igual probabilidad, cualquier número del 0 al 9.</p>

<p><a class="p_ident" id="p-4Vo+PhEiYY" href="#p-4Vo+PhEiYY" tabindex="-1" role="presentation"></a>También existen las funciones <code>Math.ceil</code> (para "techo", que redondea hacia arriba al número entero más cercano), <code>Math.round</code> (al número entero más cercano) y <code>Math.abs</code>, que toma el valor absoluto de un número, lo que significa que niega los valores negativos pero deja los positivos tal como están.</p>

<h2><a class="h_ident" id="h-B372u36cp6" href="#h-B372u36cp6" tabindex="-1" role="presentation"></a>Desestructuración</h2>

<p><a class="p_ident" id="p-0/7lTPGaf9" href="#p-0/7lTPGaf9" tabindex="-1" role="presentation"></a>Volviendo por un momento a la función <code>phi</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-8p90ivE8ZI" href="#c-8p90ivE8ZI" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">phi</span>(<span class="tok-definition">table</span>) {
  <span class="tok-keyword">return</span> (table[<span class="tok-number">3</span>] * table[<span class="tok-number">0</span>] - table[<span class="tok-number">2</span>] * table[<span class="tok-number">1</span>]) /
    Math.sqrt((table[<span class="tok-number">2</span>] + table[<span class="tok-number">3</span>]) *
              (table[<span class="tok-number">0</span>] + table[<span class="tok-number">1</span>]) *
              (table[<span class="tok-number">1</span>] + table[<span class="tok-number">3</span>]) *
              (table[<span class="tok-number">0</span>] + table[<span class="tok-number">2</span>]));
}</pre><p><a class="p_ident" id="p-i8CXj8pcLh" href="#p-i8CXj8pcLh" tabindex="-1" role="presentation"></a>Una razón por la que esta función es difícil de leer es que tenemos un enlace apuntando a nuestro array, pero preferiríamos tener enlaces para los <em>elementos</em> del array, es decir, <code>let n00 = table[0]</code> y así sucesivamente. Afortunadamente, hay una forma concisa de hacer esto en JavaScript:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-z2cboTL/zX" href="#c-z2cboTL/zX" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">phi</span>([<span class="tok-definition">n00</span>, <span class="tok-definition">n01</span>, <span class="tok-definition">n10</span>, <span class="tok-definition">n11</span>]) {
  <span class="tok-keyword">return</span> (n11 * n00 - n10 * n01) /
    Math.sqrt((n10 + n11) * (n00 + n01) *
              (n01 + n11) * (n00 + n10));
}</pre>

<p><a class="p_ident" id="p-19LeEQ6aUS" href="#p-19LeEQ6aUS" tabindex="-1" role="presentation"></a>Esto también funciona para enlaces creados con <code>let</code>, <code>var</code> o <code>const</code>. Si sabes que el valor al que estás enlazando es un array, puedes usar corchetes para "mirar dentro" del valor, enlazando su contenido.</p>

<p><a class="p_ident" id="p-/ua5XkCTLw" href="#p-/ua5XkCTLw" tabindex="-1" role="presentation"></a>Un truco similar funciona para objetos, utilizando llaves en lugar de corchetes:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-ZXEdn9Xbfc" href="#c-ZXEdn9Xbfc" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> {name} = {<span class="tok-definition">name</span>: <span class="tok-string">"Faraji"</span>, <span class="tok-definition">age</span>: <span class="tok-number">23</span>};
console.log(name);
<span class="tok-comment">// → Faraji</span></pre>

<p><a class="p_ident" id="p-MNAZNaf82S" href="#p-MNAZNaf82S" tabindex="-1" role="presentation"></a>Recuerda que si intentas desestructurar <code>null</code> o <code>undefined</code>, obtendrás un error, al igual que si intentaras acceder directamente a una propiedad de esos valores.</p>

<h2><a class="h_ident" id="h-Ves5c04PGx" href="#h-Ves5c04PGx" tabindex="-1" role="presentation"></a>Acceso opcional a propiedades</h2>

<p><a class="p_ident" id="p-mz6ha2As9s" href="#p-mz6ha2As9s" tabindex="-1" role="presentation"></a>Cuando no estás seguro de si un valor dado produce un objeto pero aún quieres leer una propiedad de él cuando lo hace, puedes usar una variante de la notación de punto: <code>object?.property</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-DLFJL/nC30" href="#c-DLFJL/nC30" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">city</span>(<span class="tok-definition">object</span>) {
  <span class="tok-keyword">return</span> object.address?.city;
}
console.log(city({<span class="tok-definition">address</span>: {<span class="tok-definition">city</span>: <span class="tok-string">"Toronto"</span>}}));
<span class="tok-comment">// → Toronto</span>
console.log(city({<span class="tok-definition">name</span>: <span class="tok-string">"Vera"</span>}));
<span class="tok-comment">// → undefined</span></pre><p><a class="p_ident" id="p-2boSIcIBYD" href="#p-2boSIcIBYD" tabindex="-1" role="presentation"></a>La expresión <code>a?.b</code> significa lo mismo que <code>a.b</code> cuando <code>a</code> no es nulo ni está indefinido. Cuando lo es, se evalúa como indefinido. Esto puede ser conveniente cuando, como en el ejemplo, no estás seguro de que exista una propiedad dada o cuando una variable podría contener un valor indefinido.</p>

<p><a class="p_ident" id="p-4G0+izUNb9" href="#p-4G0+izUNb9" tabindex="-1" role="presentation"></a>Una notación similar se puede utilizar con el acceso a corchetes, e incluso con llamadas a funciones, colocando <code>?.</code> delante de los paréntesis o corchetes:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Zkj/5F9HnZ" href="#c-Zkj/5F9HnZ" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"string"</span>.notAMethod?.());
<span class="tok-comment">// → undefined</span>
console.log({}.arrayProp?.[<span class="tok-number">0</span>]);
<span class="tok-comment">// → undefined</span></pre>

<h2><a class="h_ident" id="h-AxpOdvCznQ" href="#h-AxpOdvCznQ" tabindex="-1" role="presentation"></a>JSON</h2>

<p><a class="p_ident" id="p-OxPuD+9dU4" href="#p-OxPuD+9dU4" tabindex="-1" role="presentation"></a>Porque las propiedades capturan su valor en lugar de contenerlo, objetos y arrays se almacenan en la memoria de la computadora como secuencias de bits que contienen las <em>direcciones</em>—el lugar en la memoria—de sus contenidos. Un array con otro array dentro de él consta de (al menos) una región de memoria para el array interno y otra para el array externo, que contiene (entre otras cosas) un número que representa la dirección del array interno.</p>

<p><a class="p_ident" id="p-aF+08iJEQw" href="#p-aF+08iJEQw" tabindex="-1" role="presentation"></a>Si deseas guardar datos en un archivo para más adelante o enviarlos a otra computadora a través de la red, debes convertir de alguna manera estos enredos de direcciones de memoria a una descripción que se pueda almacenar o enviar. <em>Podrías</em> enviar toda la memoria de tu computadora junto con la dirección del valor en el que estás interesado, supongo, pero eso no parece ser el mejor enfoque.</p>

<p><a class="p_ident" id="p-ZM103Qyv6l" href="#p-ZM103Qyv6l" tabindex="-1" role="presentation"></a>Lo que podemos hacer es <em>serializar</em> los datos. Eso significa que se convierten en una descripción plana. Un formato de serialización popular se llama <em>JSON</em> (pronunciado "Jason"), que significa Notación de Objetos JavaScript. Se utiliza ampliamente como formato de almacenamiento y comunicación en la Web, incluso en lenguajes distintos a JavaScript.</p>

<p><a class="p_ident" id="p-IMEKAvSfAI" href="#p-IMEKAvSfAI" tabindex="-1" role="presentation"></a>JSON se ve similar a la forma en que JavaScript escribe arrays y objetos, con algunas restricciones. Todos los nombres de propiedades deben estar rodeados por comillas dobles, y solo se permiten expresiones de datos simples, sin llamadas de funciones, vinculaciones, o cualquier cosa que implique cálculos reales. Los comentarios no están permitidos en JSON.</p><p><a class="p_ident" id="p-9DCLKzKNiz" href="#p-9DCLKzKNiz" tabindex="-1" role="presentation"></a>Un registro de diario podría lucir así cuando se representa como datos JSON:</p>

<pre class="snippet" data-language="json"><a class="c_ident" id="c-A3jdCqz1Q6" href="#c-A3jdCqz1Q6" tabindex="-1" role="presentation"></a>{
  <span class="tok-string">"ardilla"</span>: false,
  <span class="tok-string">"eventos"</span>: [<span class="tok-string">"trabajo"</span>, <span class="tok-string">"tocó árbol"</span>, <span class="tok-string">"pizza"</span>, <span class="tok-string">"correr"</span>]
}</pre>

<p><a class="p_ident" id="p-1IU60Zh2Af" href="#p-1IU60Zh2Af" tabindex="-1" role="presentation"></a>JavaScript nos proporciona las funciones <code>JSON.stringify</code> y <code>JSON.parse</code> para convertir datos hacia y desde este formato. La primera recibe un valor de JavaScript y retorna una cadena codificada en JSON. La segunda toma dicha cadena y la convierte en el valor que codifica:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-HYCgCsK7z1" href="#c-HYCgCsK7z1" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">cadena</span> = JSON.stringify({<span class="tok-definition">ardilla</span>: false,
                             <span class="tok-definition">eventos</span>: [<span class="tok-string">"fin de semana"</span>]});
console.log(cadena);
<span class="tok-comment">// → {"ardilla":false,"eventos":["fin de semana"]}</span>
console.log(JSON.parse(cadena).eventos);
<span class="tok-comment">// → ["fin de semana"]</span></pre>

<h2><a class="h_ident" id="h-ErccPg/l98" href="#h-ErccPg/l98" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-78ZfHX5x1B" href="#p-78ZfHX5x1B" tabindex="-1" role="presentation"></a>Los objetos y arrays proporcionan formas de agrupar varios valores en un único valor. Esto nos permite meter un montón de cosas relacionadas en una bolsa y correr con la bolsa en lugar de envolver nuestros brazos alrededor de todas las cosas individuales y tratar de sostenerlas por separado.</p>

<p><a class="p_ident" id="p-ayhyxvWlMH" href="#p-ayhyxvWlMH" tabindex="-1" role="presentation"></a>La mayoría de los valores en JavaScript tienen propiedades, con las excepciones de <code>null</code> y <code>undefined</code>. Las propiedades se acceden usando <code>valor.prop</code> o <code>valor["prop"]</code>. Los objetos tienden a usar nombres para sus propiedades y almacenar más o menos un conjunto fijo de ellas. Los arrays, por otro lado, por lo general contienen cantidades variables de valores conceptualmente idénticos y usan números (empezando desde 0) como nombres de sus propiedades.</p>

<p><a class="p_ident" id="p-Cg0n8RyG0A" href="#p-Cg0n8RyG0A" tabindex="-1" role="presentation"></a>Existen <em>algunas</em> propiedades con nombre en los arrays, como <code>length</code> y varios métodos. Los métodos son funciones que residen en propiedades y (usualmente) actúan sobre el valor del cual son una propiedad.</p>

<p><a class="p_ident" id="p-KWzs1al6OP" href="#p-KWzs1al6OP" tabindex="-1" role="presentation"></a>Puedes recorrer arrays usando un tipo especial de ciclo <code>for</code>: <code>for (let elemento of array)</code>.</p><h2><a class="h_ident" id="h-TcUD2vzyMe" href="#h-TcUD2vzyMe" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-8ZspxiCEC/" href="#i-8ZspxiCEC/" tabindex="-1" role="presentation"></a>La suma de un rango</h3>

<p><a class="p_ident" id="p-fpyyiv/hm1" href="#p-fpyyiv/hm1" tabindex="-1" role="presentation"></a>La <a href="00_intro.html">introducción</a> de este libro aludió a lo siguiente como una forma buena de computar la suma de un rango de números:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-KTbQMmMCli" href="#c-KTbQMmMCli" tabindex="-1" role="presentation"></a>console.log(sum(range(<span class="tok-number">1</span>, <span class="tok-number">10</span>)));</pre>

<p><a class="p_ident" id="p-uTMnVb6I1m" href="#p-uTMnVb6I1m" tabindex="-1" role="presentation"></a>Escribe una función <code>range</code> que tome dos argumentos, <code>start</code> y <code>end</code>, y devuelva un array que contenga todos los números desde <code>start</code> hasta <code>end</code>, incluyéndolo.</p>

<p><a class="p_ident" id="p-0GiJNcBSop" href="#p-0GiJNcBSop" tabindex="-1" role="presentation"></a>A continuación, escribe una función <code>sum</code> que tome un array de números y devuelva la suma de esos números. Ejecuta el programa de ejemplo y comprueba si realmente devuelve 55.</p>

<p><a class="p_ident" id="p-1Uvf7bfQT8" href="#p-1Uvf7bfQT8" tabindex="-1" role="presentation"></a>Como tarea adicional, modifica tu función <code>range</code> para que tome un tercer argumento opcional que indique el valor de "paso" utilizado al construir el array. Si no se proporciona ningún paso, los elementos deben aumentar en incrementos de uno, correspondiendo al comportamiento anterior. La llamada de función <code>range(1, 10, 2)</code> debería devolver <code>[1, 3, 5, 7, 9]</code>. Asegúrate de que esto también funcione con valores de paso negativos de modo que <code>range(5, 2, -1)</code> produzca <code>[5, 4, 3, 2]</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-gV3XCKJAqj" href="#c-gV3XCKJAqj" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu código va aquí.</span>

console.log(range(<span class="tok-number">1</span>, <span class="tok-number">10</span>));
<span class="tok-comment">// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
console.log(range(<span class="tok-number">5</span>, <span class="tok-number">2</span>, -<span class="tok-number">1</span>));
<span class="tok-comment">// → [5, 4, 3, 2]</span>
console.log(sum(range(<span class="tok-number">1</span>, <span class="tok-number">10</span>)));
<span class="tok-comment">// → 55</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-AzWVqPrlre" href="#p-AzWVqPrlre" tabindex="-1" role="presentation"></a>Construir un array es más fácilmente hecho inicializando un enlace a <code>[]</code> (un array nuevo y vacío) y llamando repetidamente a su método <code>push</code> para añadir un valor. No olvides devolver el array al final de la función.</p><p><a class="p_ident" id="p-eu6MUPwjEb" href="#p-eu6MUPwjEb" tabindex="-1" role="presentation"></a>Dado que el límite final es inclusivo, necesitarás usar el operador <code>&lt;=</code> en lugar de <code>&lt;</code> para verificar el final de tu bucle.</p>

<p><a class="p_ident" id="p-kvr5NnqBEW" href="#p-kvr5NnqBEW" tabindex="-1" role="presentation"></a>El parámetro step puede ser un parámetro opcional que por defecto (usando el operador <code>=</code>) es igual a 1.</p>

<p><a class="p_ident" id="p-zih2wFkrk5" href="#p-zih2wFkrk5" tabindex="-1" role="presentation"></a>Hacer que <code>range</code> entienda valores de paso negativos probablemente sea mejor hacerlo escribiendo dos bucles separados: uno para contar hacia arriba y otro para contar hacia abajo, porque la comparación que verifica si el bucle ha terminado debe ser <code>&gt;=</code> en lugar de <code>&lt;=</code> al contar hacia abajo.</p>

<p><a class="p_ident" id="p-d7Vi2uDSps" href="#p-d7Vi2uDSps" tabindex="-1" role="presentation"></a>También podría valer la pena usar un paso predeterminado diferente, es decir, -1, cuando el final del rango es menor que el inicio. De esta manera, <code>range(5, 2)</code> devuelve algo significativo, en lugar de quedarse atascado en un bucle infinito. Es posible hacer referencia a parámetros anteriores en el valor predeterminado de un parámetro.</p>

</div></details>

<h3><a class="i_ident" id="i-6xTmjj4Rf5" href="#i-6xTmjj4Rf5" tabindex="-1" role="presentation"></a>Revertir un array</h3>

<p><a class="p_ident" id="p-+SVCOC/qcN" href="#p-+SVCOC/qcN" tabindex="-1" role="presentation"></a>Los arrays tienen un método <code>reverse</code> que cambia el array invirtiendo el orden en el que aparecen sus elementos. Para este ejercicio, escribe dos funciones, <code>reverseArray</code> y <code>reverseArrayInPlace</code>. La primera, <code>reverseArray</code>, debería tomar un array como argumento y producir un <em>nuevo</em> array que tenga los mismos elementos en orden inverso. La segunda, <code>reverseArrayInPlace</code>, debería hacer lo que hace el método <code>reverse</code>: <em>modificar</em> el array dado como argumento invirtiendo sus elementos. Ninguna de las dos debería usar el método estándar <code>reverse</code>.</p>

<p><a class="p_ident" id="p-SpaDJmGkSI" href="#p-SpaDJmGkSI" tabindex="-1" role="presentation"></a>Volviendo a las notas sobre efectos secundarios y funciones puras en el <a href="03_functions.html#pure">capítulo anterior</a>, ¿qué variante esperas que sea útil en más situaciones? ¿Cuál se ejecuta más rápido?</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-5Vb8iy8kxG" href="#c-5Vb8iy8kxG" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu código aquí.</span>

<span class="tok-keyword">let</span> <span class="tok-definition">miArray</span> = [<span class="tok-string">"A"</span>, <span class="tok-string">"B"</span>, <span class="tok-string">"C"</span>];
console.log(reverseArray(miArray));
<span class="tok-comment">// → ["C", "B", "A"];</span>
console.log(miArray);
<span class="tok-comment">// → ["A", "B", "C"];</span>
<span class="tok-keyword">let</span> <span class="tok-definition">valorArray</span> = [<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>];
reverseArrayInPlace(valorArray);
console.log(valorArray);
<span class="tok-comment">// → [5, 4, 3, 2, 1]</span></pre><details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-bJlW8Cyw1e" href="#p-bJlW8Cyw1e" tabindex="-1" role="presentation"></a>Hay dos formas obvias de implementar <code>reverseArray</code>. La primera es simplemente recorrer el array de entrada de principio a fin y usar el método <code>unshift</code> en el nuevo array para insertar cada elemento al inicio. La segunda es recorrer el array de entrada en reversa y usar el método <code>push</code>. Iterar sobre un array en reversa requiere una (algo incómoda) especificación <code>for</code>, como <code>(let i = array.<wbr>length - 1; i &gt;= 0; i--)</code>.</p>

<p><a class="p_ident" id="p-Y08sN3Yej5" href="#p-Y08sN3Yej5" tabindex="-1" role="presentation"></a>Revertir el array en su lugar es más difícil. Debes tener cuidado de no sobrescribir elementos que necesitarás más adelante. Usar <code>reverseArray</code> o copiar el array completo de alguna otra manera (<code>array.slice()</code> es una buena forma de copiar un array) funciona pero es hacer trampa.</p>

<p><a class="p_ident" id="p-hzYSkS4zzl" href="#p-hzYSkS4zzl" tabindex="-1" role="presentation"></a>El truco es <em>intercambiar</em> el primer y el último elemento, luego el segundo y el penúltimo, y así sucesivamente. Puedes hacer esto recorriendo la mitad de la longitud del array (usa <code>Math.floor</code> para redondear hacia abajo; no necesitas tocar el elemento del medio en un array con un número impar de elementos) e intercambiando el elemento en la posición <code>i</code> con el de la posición <code>array.<wbr>length - 1 - i</code>. Puedes usar una asignación local para sostener brevemente uno de los elementos, sobrescribir ese con su imagen en el espejo, y luego colocar el valor de la asignación local en el lugar donde solía estar la imagen en el espejo.</p>

</div></details>

<h3 id="list"><a class="i_ident" id="i-nSTX34CM1M" href="#i-nSTX34CM1M" tabindex="-1" role="presentation"></a>Una lista</h3>

<p><a class="p_ident" id="p-hy91OFxbTm" href="#p-hy91OFxbTm" tabindex="-1" role="presentation"></a>Como bloques genéricos de valores, los objetos se pueden usar para construir todo tipo de estructuras de datos. Una estructura de datos común es la lista (no confundir con arrays). Una lista es un conjunto anidado de objetos, donde el primer objeto tiene una referencia al segundo, el segundo al tercero, y así sucesivamente:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-kYAco70aHD" href="#c-kYAco70aHD" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">lista</span> = {
  <span class="tok-definition">valor</span>: <span class="tok-number">1</span>,
  <span class="tok-definition">resto</span>: {
    <span class="tok-definition">valor</span>: <span class="tok-number">2</span>,
    <span class="tok-definition">resto</span>: {
      <span class="tok-definition">valor</span>: <span class="tok-number">3</span>,
      <span class="tok-definition">resto</span>: <span class="tok-keyword">null</span>
    }
  }
};</pre>

<p><a class="p_ident" id="p-Vyz5U7tFos" href="#p-Vyz5U7tFos" tabindex="-1" role="presentation"></a>Los objetos resultantes forman una cadena, como se muestra en el siguiente diagrama:</p><figure><img src="fonts/linked-list.svg" alt="Un diagrama que muestra la estructura de memoria de una lista enlazada. Hay 3 celdas, cada una con un campo de valor que contiene un número, y un campo 'resto' con una flecha al resto de la lista. La flecha de la primera celda apunta a la segunda celda, la flecha de la segunda celda apunta a la última celda, y el campo 'resto' de la última celda contiene null."></figure><p><a class="p_ident" id="p-NaI0fhp38z" href="#p-NaI0fhp38z" tabindex="-1" role="presentation"></a>Una buena característica de las listas es que pueden compartir partes de su estructura. Por ejemplo, si creo dos nuevos valores <code>{value: 0, rest: list}</code> y <code>{value: -1, rest: list}</code> (con <code>list</code> refiriéndose al enlace definido anteriormente), ambos son listas independientes, pero comparten la estructura que conforma sus últimos tres elementos. La lista original sigue siendo válida como una lista de tres elementos.</p>

<p><a class="p_ident" id="p-iPlgVCeZGh" href="#p-iPlgVCeZGh" tabindex="-1" role="presentation"></a>Escribe una función <code>arrayToList</code> que construya una estructura de lista como la mostrada cuando se le da <code>[1, 2, 3]</code> como argumento. También escribe una función <code>listToArray</code> que produzca un arreglo a partir de una lista. Agrega las funciones auxiliares <code>prepend</code>, que toma un elemento y una lista y crea una nueva lista que agrega el elemento al principio de la lista de entrada, y <code>nth</code>, que toma una lista y un número y devuelve el elemento en la posición dada en la lista (siendo cero el primer elemento) o <code>undefined</code> cuando no existe tal elemento.</p>

<p><a class="p_ident" id="p-8YcepSmcdv" href="#p-8YcepSmcdv" tabindex="-1" role="presentation"></a>Si aún no lo has hecho, también escribe una versión recursiva de <code>nth</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-rufmukl+AQ" href="#c-rufmukl+AQ" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu código aquí.</span>

console.log(arrayToList([<span class="tok-number">10</span>, <span class="tok-number">20</span>]));
<span class="tok-comment">// → {value: 10, rest: {value: 20, rest: null}}</span>
console.log(listToArray(arrayToList([<span class="tok-number">10</span>, <span class="tok-number">20</span>, <span class="tok-number">30</span>])));
<span class="tok-comment">// → [10, 20, 30]</span>
console.log(prepend(<span class="tok-number">10</span>, prepend(<span class="tok-number">20</span>, <span class="tok-keyword">null</span>)));
<span class="tok-comment">// → {value: 10, rest: {value: 20, rest: null}}</span>
console.log(nth(arrayToList([<span class="tok-number">10</span>, <span class="tok-number">20</span>, <span class="tok-number">30</span>]), <span class="tok-number">1</span>));
<span class="tok-comment">// → 20</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-gUGYq9Tjlx" href="#p-gUGYq9Tjlx" tabindex="-1" role="presentation"></a>Construir una lista es más fácil cuando se hace de atrás hacia adelante. Así que <code>arrayToList</code> podría iterar sobre el arreglo en reversa (ver el ejercicio anterior) y, para cada elemento, agregar un objeto a la lista. Puedes usar un enlace local para mantener la parte de la lista construida hasta ahora y usar una asignación como <code>list = {value: X, rest: list}</code> para agregar un elemento.</p>

<p><a class="p_ident" id="p-+rJULr60CD" href="#p-+rJULr60CD" tabindex="-1" role="presentation"></a>Para recorrer una lista (en <code>listToArray</code> y <code>nth</code>), se puede utilizar una especificación de bucle <code>for</code> como esta:</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-HLrOQGihFR" href="#c-HLrOQGihFR" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">node</span> = list; node; node = node.rest) {}</pre>

<p><a class="p_ident" id="p-LnwEAnSmsp" href="#p-LnwEAnSmsp" tabindex="-1" role="presentation"></a>¿Puedes ver cómo funciona eso? En cada iteración del bucle, <code>node</code> apunta a la sublista actual, y el cuerpo puede leer su propiedad <code>value</code> para obtener el elemento actual. Al final de una iteración, <code>node</code> pasa a la siguiente sublista. Cuando eso es nulo, hemos llegado al final de la lista y el bucle ha terminado.</p>

<p><a class="p_ident" id="p-ASUOjWBRh5" href="#p-ASUOjWBRh5" tabindex="-1" role="presentation"></a>La versión recursiva de <code>nth</code>, de manera similar, examinará una parte cada vez más pequeña de la "cola" de la lista y al mismo tiempo contará hacia abajo el índice hasta que alcance cero, momento en el cual puede devolver la propiedad <code>value</code> del nodo que está examinando. Para obtener el elemento cero de una lista, simplemente tomas la propiedad <code>value</code> de su nodo de cabecera. Para obtener el elemento <em>N</em> + 1, tomas el enésimo elemento de la lista que está en la propiedad <code>rest</code> de esta lista.</p>

</div></details>

<h3 id="exercise_deep_compare"><a class="i_ident" id="i-IJBU+aXOIC" href="#i-IJBU+aXOIC" tabindex="-1" role="presentation"></a>Comparación profunda</h3>

<p><a class="p_ident" id="p-xTwbRlqHNJ" href="#p-xTwbRlqHNJ" tabindex="-1" role="presentation"></a>El operador <code>==</code> compara objetos por identidad, pero a veces prefieres comparar los valores de sus propiedades reales.</p>

<p><a class="p_ident" id="p-DwdnLiD0pC" href="#p-DwdnLiD0pC" tabindex="-1" role="presentation"></a>Escribe una función <code>deepEqual</code> que tome dos valores y devuelva true solo si son el mismo valor o son objetos con las mismas propiedades, donde los valores de las propiedades son iguales cuando se comparan con una llamada recursiva a <code>deepEqual</code>.</p>

<p><a class="p_ident" id="p-J4qe8P6a4v" href="#p-J4qe8P6a4v" tabindex="-1" role="presentation"></a>Para saber si los valores deben compararse directamente (usando el operador <code>===</code> para eso) o si sus propiedades deben compararse, puedes usar el operador <code>typeof</code>. Si produce <code>"object"</code> para ambos valores, deberías hacer una comparación profunda. Pero hay que tener en cuenta una excepción tonta: debido a un accidente histórico, <code>typeof null</code> también produce <code>"object"</code>.</p>

<p><a class="p_ident" id="p-n9AoXEbeFg" href="#p-n9AoXEbeFg" tabindex="-1" role="presentation"></a>La función <code>Object.keys</code> será útil cuando necesites recorrer las propiedades de objetos para compararlas.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-kWPN5i/Y3x" href="#c-kWPN5i/Y3x" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu código aquí.</span>```html
<span class="tok-keyword">let</span> <span class="tok-definition">obj</span> = {<span class="tok-definition">here</span>: {<span class="tok-definition">is</span>: <span class="tok-string">"an"</span>}, <span class="tok-definition">object</span>: <span class="tok-number">2</span>};
console.log(deepEqual(obj, obj));
<span class="tok-comment">// → true</span>
console.log(deepEqual(obj, {<span class="tok-definition">here</span>: <span class="tok-number">1</span>, <span class="tok-definition">object</span>: <span class="tok-number">2</span>}));
<span class="tok-comment">// → false</span>
console.log(deepEqual(obj, {<span class="tok-definition">here</span>: {<span class="tok-definition">is</span>: <span class="tok-string">"an"</span>}, <span class="tok-definition">object</span>: <span class="tok-number">2</span>}));
<span class="tok-comment">// → true</span></pre>
```
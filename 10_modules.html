<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Módulos :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="css/ejs.css"><script>
      var page = {"type":"chapter","number":10,"load_files":["code/packages_chapter_10.js","code/chapter/07_robot.js"]}</script></head>

<body><article>
<nav><a href="09_regexp.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="11_async.html" title="próximo capítulo" aria-label="próximo capítulo">▸</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>

<h1>Módulos</h1>

<blockquote>

<p><a class="p_ident" id="p-OwlHMaRbBt" href="#p-OwlHMaRbBt" tabindex="-1" role="presentation"></a>Escribe código que sea fácil de eliminar, no fácil de extender.</p>

<footer>Tef, <cite>Programar es Terrible</cite></footer>

</blockquote><figure class="chapter framed"><img src="images/chapter_picture_10.jpg" alt="Ilustración de un edificio complicado construido a partir de piezas modulares"></figure>

<p><a class="p_ident" id="p-eJ85ThKM0E" href="#p-eJ85ThKM0E" tabindex="-1" role="presentation"></a>Idealmente, un programa tiene una estructura clara y directa. La forma en que funciona es fácil de explicar, y cada parte desempeña un papel bien definido.</p>

<p><a class="p_ident" id="p-7GiMFmlznT" href="#p-7GiMFmlznT" tabindex="-1" role="presentation"></a>En la práctica, los programas crecen de forma orgánica. Se agregan piezas de funcionalidad a medida que el programador identifica nuevas necesidades. Mantener un programa así bien estructurado requiere atención constante y trabajo. Este es un trabajo que solo dará sus frutos en el futuro, la próxima vez que alguien trabaje en el programa. Por lo tanto, es tentador descuidarlo y permitir que las diversas partes del programa se enreden profundamente.</p>

<p><a class="p_ident" id="p-PhgZ29SZIs" href="#p-PhgZ29SZIs" tabindex="-1" role="presentation"></a>Esto causa dos problemas prácticos. Primero, entender un sistema enredado es difícil. Si todo puede tocar cualquier otra cosa, es difícil mirar una pieza específica de forma aislada. Te ves obligado a construir una comprensión holística de todo el conjunto. Segundo, si deseas utilizar alguna funcionalidad de dicho programa en otra situación, puede ser más fácil reescribirla que tratar de desenredarla de su contexto.</p>

<p><a class="p_ident" id="p-CsLPd2jqMS" href="#p-CsLPd2jqMS" tabindex="-1" role="presentation"></a>La frase "gran bola de mugre" se usa a menudo para describir programas grandes y sin estructura. Todo se une, y cuando intentas sacar una pieza, todo se desmorona y solo logras hacer un desastre.</p>

<h2><a class="h_ident" id="h-hu5082lMHg" href="#h-hu5082lMHg" tabindex="-1" role="presentation"></a>Programas modulares</h2>

<p><a class="p_ident" id="p-LoWZBZ2Vpv" href="#p-LoWZBZ2Vpv" tabindex="-1" role="presentation"></a>Los <em>módulos</em> son un intento de evitar estos problemas. Un módulo es una parte del programa que especifica en qué otras piezas depende y qué funcionalidad proporciona para que otros módulos la usen (su <em>interfaz</em>).</p><p><a class="p_ident" id="p-KiUFTXHbS0" href="#p-KiUFTXHbS0" tabindex="-1" role="presentation"></a>Las interfaces de módulos tienen mucho en común con las interfaces de objetos, como las vimos en el <a href="06_object.html#interface">Capítulo 6</a>. Hacen que parte del módulo esté disponible para el mundo exterior y mantienen el resto en privado.</p>

<p><a class="p_ident" id="p-AYKUG7ZJhD" href="#p-AYKUG7ZJhD" tabindex="-1" role="presentation"></a>Pero la interfaz que un módulo proporciona para que otros la utilicen es solo la mitad de la historia. Un buen sistema de módulos también requiere que los módulos especifiquen qué código <em>ellos</em> utilizan de otros módulos. Estas relaciones se llaman <em>dependencias</em>. Si el módulo A utiliza funcionalidades del módulo B, se dice que <em>depende</em> de él. Cuando estas se especifican claramente en el propio módulo, se pueden utilizar para determinar qué otros módulos deben estar presentes para poder utilizar un módulo dado y para cargar las dependencias automáticamente.</p>

<p><a class="p_ident" id="p-qn8ZAquFZ+" href="#p-qn8ZAquFZ+" tabindex="-1" role="presentation"></a>Cuando las formas en que los módulos interactúan entre sí son explícitas, un sistema se vuelve más similar a LEGO, donde las piezas interactúan a través de conectores bien definidos, y menos como barro, donde todo se mezcla con todo.</p>

<h2 id="es"><a class="h_ident" id="h-5QhuRo3nod" href="#h-5QhuRo3nod" tabindex="-1" role="presentation"></a>Módulos ES</h2>

<p><a class="p_ident" id="p-jSEHpQV1WL" href="#p-jSEHpQV1WL" tabindex="-1" role="presentation"></a>El lenguaje JavaScript original no tenía ningún concepto de módulo. Todos los scripts se ejecutaban en el mismo ámbito, y acceder a una función definida en otro script se hacía referenciando las asignaciones globales creadas por ese script. Esto fomentaba activamente los enredos accidentales y difíciles de ver del código e invitaba a problemas como scripts no relacionados que intentaban usar el mismo nombre de asignación.</p>

<p><a class="p_ident" id="p-CsA0uHlD44" href="#p-CsA0uHlD44" tabindex="-1" role="presentation"></a>Desde ECMAScript 2015, JavaScript soporta dos tipos diferentes de programas. Los <em>scripts</em> se comportan de la forma antigua: sus asignaciones se definen en el ámbito global, y no tienen forma de hacer referencia directa a otros scripts. Los <em>módulos</em> obtienen su propio ámbito separado y admiten las palabras clave <code>import</code> y <code>export</code>, que no están disponibles en los scripts, para declarar sus dependencias e interfaz. Este sistema de módulos se suele llamar <em>módulos ES</em> (donde "ES" significa "ECMAScript").</p>

<p><a class="p_ident" id="p-tzC5Mbbz1R" href="#p-tzC5Mbbz1R" tabindex="-1" role="presentation"></a>Un programa modular se compone de varios módulos de este tipo, conectados a través de sus importaciones y exportaciones.</p>

<p><a class="p_ident" id="p-Qefh5ZJVhr" href="#p-Qefh5ZJVhr" tabindex="-1" role="presentation"></a>Este ejemplo de módulo convierte entre nombres de días y números (como los devueltos por el método <code>getDay</code> de <code>Date</code>). Define una constante que no forma parte de su interfaz, y dos funciones que sí lo hacen. No tiene dependencias.</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-0Er93uC2EW" href="#c-0Er93uC2EW" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">names</span> = [<span class="tok-string">"Domingo"</span>, <span class="tok-string">"Lunes"</span>, <span class="tok-string">"Martes"</span>, <span class="tok-string">"Miércoles"</span>,
               <span class="tok-string">"Jueves"</span>, <span class="tok-string">"Viernes"</span>, <span class="tok-string">"Sábado"</span>];

<span class="tok-keyword">export</span> <span class="tok-keyword">function</span> <span class="tok-definition">nombreDia</span>(<span class="tok-definition">numero</span>) {
  <span class="tok-keyword">return</span> names[numero];
}
<span class="tok-keyword">export</span> <span class="tok-keyword">function</span> <span class="tok-definition">numeroDia</span>(<span class="tok-definition">nombre</span>) {
  <span class="tok-keyword">return</span> names.indexOf(nombre);
}</pre>

<p><a class="p_ident" id="p-0xJEStYLkj" href="#p-0xJEStYLkj" tabindex="-1" role="presentation"></a>La palabra clave <code>export</code> se puede colocar delante de una función, clase o definición de enlace para indicar que ese enlace es parte de la interfaz del módulo. Esto hace posible que otros módulos utilicen ese enlace importándolo.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-2oqdYiDrM5" href="#c-2oqdYiDrM5" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">nombreDia</span>} <span class="tok-keyword">from</span> <span class="tok-string">"./nombreDia.js"</span>;
<span class="tok-keyword">let</span> <span class="tok-definition">ahora</span> = <span class="tok-keyword">new</span> Date();
console.log(<span class="tok-string2">`Hoy es </span>${nombreDia(ahora.getDay())}<span class="tok-string2">`</span>);
<span class="tok-comment">// → Hoy es Lunes</span></pre>

<p><a class="p_ident" id="p-hjldO4njBb" href="#p-hjldO4njBb" tabindex="-1" role="presentation"></a>La palabra clave <code>import</code>, seguida de una lista de nombres de enlace entre llaves, hace que los enlaces de otro módulo estén disponibles en el módulo actual. Los módulos se identifican con cadenas entre comillas.</p>

<p><a class="p_ident" id="p-do5wE0mFRq" href="#p-do5wE0mFRq" tabindex="-1" role="presentation"></a>Cómo se resuelve un nombre de módulo a un programa real difiere según la plataforma. El navegador los trata como direcciones web, mientras que Node.js los resuelve como archivos. Para ejecutar un módulo, se cargan todos los demás módulos en los que depende, y los enlaces exportados se ponen a disposición de los módulos que los importan.</p>

<p><a class="p_ident" id="p-LBXRIpj2E0" href="#p-LBXRIpj2E0" tabindex="-1" role="presentation"></a>Las declaraciones de importación y exportación no pueden aparecer dentro de funciones, bucles u otros bloques. Se resuelven inmediatamente cuando se carga el módulo, independientemente de cómo se ejecute el código en el módulo, y para reflejar esto deben aparecer solo en el cuerpo exterior del módulo.</p><p><a class="p_ident" id="p-jEcGKPC/Uy" href="#p-jEcGKPC/Uy" tabindex="-1" role="presentation"></a>Entonces, la interfaz de un módulo consiste en una colección de enlaces nombrados, a los cuales otros módulos que dependen de ellos tienen acceso. Los enlaces importados pueden ser renombrados dándoles un nuevo nombre local usando <code>as</code> después de su nombre.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-1rWa8n4g2w" href="#c-1rWa8n4g2w" tabindex="-1" role="presentation"></a><span class="tok-keyword">importa</span> {dayName <span class="tok-keyword">como</span> <span class="tok-definition">nomDeJour</span>} <span class="tok-keyword">desde</span> <span class="tok-string">"./dayname.js"</span>;
console.log(nomDeJour(<span class="tok-number">3</span>));
<span class="tok-comment">// → Wednesday</span></pre>

<p><a class="p_ident" id="p-SYkTgzWla9" href="#p-SYkTgzWla9" tabindex="-1" role="presentation"></a>También es posible que un módulo tenga una exportación especial llamada <code>default</code>, la cual se usa a menudo para módulos que exportan solo un enlace. Para definir una exportación predeterminada, escribes <code>exportar predeterminado</code> antes de una expresión, una declaración de función o una declaración de clase.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Y6Wnu9X+/W" href="#c-Y6Wnu9X+/W" tabindex="-1" role="presentation"></a><span class="tok-keyword">exportar</span> <span class="tok-keyword">predeterminado</span> [<span class="tok-string">"Winter"</span>, <span class="tok-string">"Spring"</span>, <span class="tok-string">"Summer"</span>, <span class="tok-string">"Autumn"</span>];</pre>

<p><a class="p_ident" id="p-xA/MW6oxes" href="#p-xA/MW6oxes" tabindex="-1" role="presentation"></a>Un enlace como este se importa omitiendo las llaves alrededor del nombre de la importación.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-kGA5r04JCR" href="#c-kGA5r04JCR" tabindex="-1" role="presentation"></a><span class="tok-keyword">importa</span> <span class="tok-definition">seasonNames</span> <span class="tok-keyword">desde</span> <span class="tok-string">"./seasonname.js"</span>;</pre>

<h2><a class="h_ident" id="h-CpmQEv+4ez" href="#h-CpmQEv+4ez" tabindex="-1" role="presentation"></a>Paquetes</h2>

<p><a class="p_ident" id="p-g7o14y8ONd" href="#p-g7o14y8ONd" tabindex="-1" role="presentation"></a>Una de las ventajas de construir un programa a partir de piezas separadas y ser capaz de ejecutar algunas de esas piezas por separado, es que podrías aplicar la misma pieza en diferentes programas.</p>

<p><a class="p_ident" id="p-HS7MnVNKZK" href="#p-HS7MnVNKZK" tabindex="-1" role="presentation"></a>Pero, ¿cómo se configura esto? Digamos que quiero usar la función <code>parseINI</code> del <a href="09_regexp.html#ini">Capítulo 9</a> en otro programa. Si queda claro de qué depende la función (en este caso, nada), puedo simplemente copiar ese módulo en mi nuevo proyecto y usarlo. Pero luego, si encuentro un error en el código, probablemente lo corrija en el programa con el que estoy trabajando en ese momento y olvide corregirlo también en el otro programa.</p><p><a class="p_ident" id="p-TA/SfLJ50i" href="#p-TA/SfLJ50i" tabindex="-1" role="presentation"></a>Una vez que comienzas a duplicar código, rápidamente te encontrarás perdiendo tiempo y energía moviendo copias y manteniéndolas actualizadas.</p>

<p><a class="p_ident" id="p-J+q9mcOuhX" href="#p-J+q9mcOuhX" tabindex="-1" role="presentation"></a>Es aquí donde entran en juego los <em>paquetes</em>. Un paquete es un bloque de código que puede ser distribuido (copiado e instalado). Puede contener uno o más módulos y tiene información sobre qué otros paquetes depende. Un paquete generalmente viene con documentación que explica qué hace, de manera que personas que no lo hayan escrito aún puedan usarlo.</p>

<p><a class="p_ident" id="p-VPdW27vgpM" href="#p-VPdW27vgpM" tabindex="-1" role="presentation"></a>Cuando se encuentra un problema en un paquete o se añade una nueva característica, el paquete se actualiza. Ahora los programas que dependen de él (que también pueden ser paquetes) pueden copiar la nueva versión para obtener las mejoras que se hicieron en el código.</p>

<p id="modules_npm"><a class="p_ident" id="p-oiLHr3lvbw" href="#p-oiLHr3lvbw" tabindex="-1" role="presentation"></a>Trabajar de esta manera requiere infraestructura. Necesitamos un lugar para almacenar y encontrar paquetes, y una forma conveniente de instalar y actualizarlos. En el mundo de JavaScript, esta infraestructura es provista por NPM (<a href="https://npmjs.org"><em>https://npmjs.org</em></a>).</p>

<p><a class="p_ident" id="p-WUPNc5b7D2" href="#p-WUPNc5b7D2" tabindex="-1" role="presentation"></a>NPM es dos cosas: un servicio en línea donde puedes descargar (y subir) paquetes, y un programa (incluido con Node.js) que te ayuda a instalar y gestionarlos.</p>

<p><a class="p_ident" id="p-I47qD+z+f/" href="#p-I47qD+z+f/" tabindex="-1" role="presentation"></a>En el momento de escribir esto, hay más de tres millones de paquetes diferentes disponibles en NPM. Una gran parte de ellos son basura, para ser sinceros. Pero casi cada paquete JavaScript útil y disponible públicamente se puede encontrar en NPM. Por ejemplo, un parser de archivos INI, similar al que construimos en el <a href="09_regexp.html">Capítulo 9</a>, está disponible bajo el nombre de paquete <code>ini</code>.</p>

<p><a class="p_ident" id="p-irXmhzBaaT" href="#p-irXmhzBaaT" tabindex="-1" role="presentation"></a><a href="20_node.html">Capítulo 20</a> mostrará cómo instalar dichos paquetes localmente utilizando el programa de línea de comandos <code>npm</code>.</p>

<p><a class="p_ident" id="p-D/2FJ7Crwg" href="#p-D/2FJ7Crwg" tabindex="-1" role="presentation"></a>Tener paquetes de calidad disponibles para descargar es extremadamente valioso. Significa que a menudo podemos evitar reinventar un programa que 100 personas han escrito antes y obtener una implementación sólida y bien probada con tan solo presionar unas teclas.</p>

<p><a class="p_ident" id="p-MXIvtdCvsp" href="#p-MXIvtdCvsp" tabindex="-1" role="presentation"></a>El software es barato de copiar, así que una vez que alguien lo ha escrito, distribuirlo a otras personas es un proceso eficiente. Pero escribirlo en primer lugar <em>es</em> trabajo, y responder a personas que han encontrado problemas en el código, o que quieren proponer nuevas características, es aún más trabajo.</p><p><a class="p_ident" id="p-K/LevaOaUV" href="#p-K/LevaOaUV" tabindex="-1" role="presentation"></a>Por defecto, eres dueño de los derechos de autor del código que escribes, y otras personas solo pueden usarlo con tu permiso. Pero porque algunas personas son amables y porque publicar buen software puede ayudarte a volverte un poco famoso entre los programadores, muchos paquetes se publican bajo una licencia que permite explícitamente a otras personas usarlo.</p>

<p><a class="p_ident" id="p-sWMlqqRmbd" href="#p-sWMlqqRmbd" tabindex="-1" role="presentation"></a>La mayoría del código en NPM tiene licencia de esta manera. Algunas licencias requieren que también publiques el código que construyes sobre el paquete bajo la misma licencia. Otros son menos exigentes, solo requiriendo que mantengas la licencia con el código al distribuirlo. La comunidad de JavaScript mayormente usa el último tipo de licencia. Al utilizar paquetes de otras personas, asegúrate de estar al tanto de su licencia.</p>

<p id="modules_ini"><a class="p_ident" id="p-iWZpEnVUgg" href="#p-iWZpEnVUgg" tabindex="-1" role="presentation"></a>Ahora, en lugar de escribir nuestro propio analizador de archivos INI, podemos usar uno de NPM.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-zTHcTC2U1Z" href="#c-zTHcTC2U1Z" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">parse</span>} <span class="tok-keyword">from</span> <span class="tok-string">"ini"</span>;

console.log(parse(<span class="tok-string">"x = 10</span><span class="tok-string2">\n</span><span class="tok-string">y = 20"</span>));
<span class="tok-comment">// → {x: "10", y: "20"}</span></pre>

<h2 id="commonjs"><a class="h_ident" id="h-6oeH1bEsmu" href="#h-6oeH1bEsmu" tabindex="-1" role="presentation"></a>Módulos CommonJS</h2>

<p><a class="p_ident" id="p-SWGjBNIgtd" href="#p-SWGjBNIgtd" tabindex="-1" role="presentation"></a>Antes de 2015, cuando el lenguaje JavaScript no tenía un sistema de módulos integrado real, las personas ya estaban construyendo sistemas grandes en JavaScript. Para hacer que fuera viable, ellos <em>necesitaban</em> módulos.</p>

<p><a class="p_ident" id="p-TAQWCwa461" href="#p-TAQWCwa461" tabindex="-1" role="presentation"></a>La comunidad diseñó sus propios sistemas de módulos improvisados sobre el lenguaje. Estos utilizan funciones para crear un ámbito local para los módulos y objetos regulares para representar las interfaces de módulos.</p>

<p><a class="p_ident" id="p-Nvl0FAzSr8" href="#p-Nvl0FAzSr8" tabindex="-1" role="presentation"></a>Inicialmente, las personas envolvían manualmente todo su módulo en una "expresión de función invocada inmediatamente" para crear el ámbito del módulo y asignaban sus objetos de interfaz a una única variable global.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-m+yRMF5NXw" href="#c-m+yRMF5NXw" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">weekDay</span> = <span class="tok-keyword">function</span>() {
  <span class="tok-keyword">const</span> <span class="tok-definition">names</span> = [<span class="tok-string">"Sunday"</span>, <span class="tok-string">"Monday"</span>, <span class="tok-string">"Tuesday"</span>, <span class="tok-string">"Wednesday"</span>,
                 <span class="tok-string">"Thursday"</span>, <span class="tok-string">"Friday"</span>, <span class="tok-string">"Saturday"</span>];
  <span class="tok-keyword">return</span> {
    <span class="tok-definition">name</span>(<span class="tok-definition">number</span>) { <span class="tok-keyword">return</span> names[number]; },
    <span class="tok-definition">number</span>(<span class="tok-definition">name</span>) { <span class="tok-keyword">return</span> names.indexOf(name); }
  };
}();console.log(weekDay.name(weekDay.number(<span class="tok-string">"Domingo"</span>)));
<span class="tok-comment">// → Sunday</span></pre>

<p><a class="p_ident" id="p-gikwn4tonM" href="#p-gikwn4tonM" tabindex="-1" role="presentation"></a>This style of modules provides isolation, to a certain degree, but it does not declare dependencies. Instead, it just puts its interface into the global scope and expects its dependencies, if any, to do the same. This is not ideal.</p>

<p><a class="p_ident" id="p-0p3BQtuh5W" href="#p-0p3BQtuh5W" tabindex="-1" role="presentation"></a>If we implement our own module loader, we can do better. The most widely used approach to bolted-on JavaScript modules is called <em>CommonJS modules</em>. Node.js used it from the start (though it now also knows how to load ES modules) it and is the module system used by many packages on NPM.</p>

<p><a class="p_ident" id="p-WjlUe2D0sb" href="#p-WjlUe2D0sb" tabindex="-1" role="presentation"></a>A CommonJS module looks like a regular script, but it has access to two bindings that it uses to interact with other modules. The first is a function called <code>require</code>. When you call this with the module name of your dependency, it makes sure the module is loaded and returns its interface. The second is an object named <code>exports</code>, which is the interface object for the module. It starts out empty and you add properties to it to define exported values.</p>

<p><a class="p_ident" id="p-ueslU3cQeD" href="#p-ueslU3cQeD" tabindex="-1" role="presentation"></a>This CommonJS example module provides a date-formatting function. It uses two packages from NPM—<code>ordinal</code> to convert numbers to strings like <code>"1st"</code> and <code>"2nd"</code>, and <code>date-names</code> to get the English names for weekdays and months. It exports a single function, <code>formatDate</code>, which takes a <code>Date</code> object and a template string.</p>

<p><a class="p_ident" id="p-fH0b3BN1Fp" href="#p-fH0b3BN1Fp" tabindex="-1" role="presentation"></a>The template string may contain codes that direct the format, such as <code>YYYY</code> for the full year and <code>Do</code> for the ordinal day of the month. You could give it a string like <code>"MMMM Do YYYY"</code> to get output like “November 22nd 2017”.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-hEFnba6fud" href="#c-hEFnba6fud" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">ordinal</span> = require(<span class="tok-string">"ordinal"</span>);
<span class="tok-keyword">const</span> {days, months} = require(<span class="tok-string">"date-names"</span>);

exports.formatDate = <span class="tok-keyword">function</span>(<span class="tok-definition">date</span>, <span class="tok-definition">format</span>) {
  <span class="tok-keyword">return</span> format.replace(<span class="tok-string2">/YYYY|M(MMM)?|Do?|dddd/g</span>, <span class="tok-definition">tag</span> =&gt; {
    <span class="tok-keyword">if</span> (tag == <span class="tok-string">"YYYY"</span>) <span class="tok-keyword">return</span> date.getFullYear();
    <span class="tok-keyword">if</span> (tag == <span class="tok-string">"M"</span>) <span class="tok-keyword">return</span> date.getMonth();
    <span class="tok-keyword">if</span> (tag == <span class="tok-string">"MMMM"</span>) <span class="tok-keyword">return</span> months[date.getMonth()];
    <span class="tok-keyword">if</span> (tag == <span class="tok-string">"D"</span>) <span class="tok-keyword">return</span> date.getDate();
    <span class="tok-keyword">if</span> (tag == <span class="tok-string">"Do"</span>) <span class="tok-keyword">return</span> ordinal(date.getDate());
    <span class="tok-keyword">if</span> (tag == <span class="tok-string">"dddd"</span>) <span class="tok-keyword">return</span> days[date.getDay()];
  });
};</pre><p><a class="p_ident" id="p-jvrgfRxGB4" href="#p-jvrgfRxGB4" tabindex="-1" role="presentation"></a>La interfaz de <code>ordinal</code> es una sola función, mientras que <code>date-names</code> exporta un objeto que contiene múltiples cosas — <code>days</code> y <code>months</code> son arreglos de nombres. La destructuración es muy conveniente al crear enlaces para interfaces importadas.</p>

<p><a class="p_ident" id="p-cHv4rZkvfj" href="#p-cHv4rZkvfj" tabindex="-1" role="presentation"></a>El módulo añade su función de interfaz a <code>exports</code> para que los módulos que dependen de él tengan acceso a esta. Podríamos usar el módulo de la siguiente manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-O5poqM7SoC" href="#c-O5poqM7SoC" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> {formatDate} = require(<span class="tok-string">"./format-date.js"</span>);

console.log(formatDate(<span class="tok-keyword">new</span> Date(<span class="tok-number">2017</span>, <span class="tok-number">9</span>, <span class="tok-number">13</span>),
                       <span class="tok-string">"dddd the Do"</span>));
<span class="tok-comment">// → Viernes el 13</span></pre>

<p><a class="p_ident" id="p-yNTIAPHtV/" href="#p-yNTIAPHtV/" tabindex="-1" role="presentation"></a>CommonJS se implementa con un cargador de módulos que, al cargar un módulo, envuelve su código en una función (dándole su propio ámbito local) y pasa los enlaces <code>require</code> y <code>exports</code> a esa función como argumentos.</p>

<p id="require"><a class="p_ident" id="p-GF4ZcyudM2" href="#p-GF4ZcyudM2" tabindex="-1" role="presentation"></a>Si asumimos que tenemos acceso a una función <code>readFile</code> que lee un archivo por nombre y nos da su contenido, podemos definir una forma simplificada de <code>require</code> de la siguiente manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript" data-sandbox="require"><a class="c_ident" id="c-t+bc73kgqw" href="#c-t+bc73kgqw" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">require</span>(<span class="tok-definition">name</span>) {
  <span class="tok-keyword">if</span> (!(name <span class="tok-keyword">in</span> require.cache)) {
    <span class="tok-keyword">let</span> <span class="tok-definition">code</span> = readFile(name);
    <span class="tok-keyword">let</span> <span class="tok-definition">exports</span> = require.cache[name] = {};
    <span class="tok-keyword">let</span> <span class="tok-definition">wrapper</span> = Function(<span class="tok-string">"require, exports"</span>, code);
    wrapper(require, exports);
  }
  <span class="tok-keyword">return</span> require.cache[name];
}
require.cache = Object.create(<span class="tok-keyword">null</span>);</pre>

<p id="eval"><a class="p_ident" id="p-UHReR+n6Qx" href="#p-UHReR+n6Qx" tabindex="-1" role="presentation"></a><code>Function</code> es una función integrada de JavaScript que toma una lista de argumentos (como una cadena separada por comas) y una cadena que contiene el cuerpo de la función, y devuelve un valor de función con esos argumentos y ese cuerpo. Este es un concepto interesante — permite a un programa crear nuevas piezas de programa a partir de datos de cadena — pero también es peligroso, ya que si alguien logra engañar a tu programa para que introduzca una cadena que proporcionan en <code>Function</code>, pueden hacer que el programa haga lo que quieran.</p><p><a class="p_ident" id="p-jGgvuENUE1" href="#p-jGgvuENUE1" tabindex="-1" role="presentation"></a>JavaScript estándar no proporciona una función llamada <code>readFile</code>, pero diferentes entornos de JavaScript, como el navegador y Node.js, ofrecen sus propias maneras de acceder a archivos. El ejemplo simplemente finge que <code>readFile</code> existe.</p>

<p><a class="p_ident" id="p-uyStaKEiIT" href="#p-uyStaKEiIT" tabindex="-1" role="presentation"></a>Para evitar cargar el mismo módulo varias veces, <code>require</code> mantiene una tienda (caché) de módulos ya cargados. Al llamarlo, primero verifica si el módulo solicitado ha sido cargado y, de no ser así, lo carga. Esto implica leer el código del módulo, envolverlo en una función y llamarlo.</p>

<p><a class="p_ident" id="p-Mp/+p+8No3" href="#p-Mp/+p+8No3" tabindex="-1" role="presentation"></a>Al definir <code>require</code>, <code>exports</code> como parámetros para la función envolvente generada (y pasando los valores apropiados al llamarla), el cargador se asegura de que estos enlaces estén disponibles en el ámbito del módulo.</p>

<p><a class="p_ident" id="p-1ZJk+403z3" href="#p-1ZJk+403z3" tabindex="-1" role="presentation"></a>Una diferencia importante entre este sistema y los módulos ES es que las importaciones de módulos ES ocurren antes de que comience a ejecutarse el script de un módulo, mientras que <code>require</code> es una función normal, invocada cuando el módulo ya está en ejecución. A diferencia de las declaraciones <code>import</code>, las llamadas a <code>require</code> <em>pueden</em> aparecer dentro de funciones, y el nombre de la dependencia puede ser cualquier expresión que se evalúe a una cadena, mientras que <code>import</code> solo permite cadenas simples entre comillas.</p>

<p><a class="p_ident" id="p-kJgsFUTJR2" href="#p-kJgsFUTJR2" tabindex="-1" role="presentation"></a>La transición de la comunidad de JavaScript desde el estilo CommonJS hacia los módulos ES ha sido lenta y algo difícil. Pero afortunadamente ahora estamos en un punto donde la mayoría de los paquetes populares en NPM proporcionan su código como módulos ES, y Node.js permite a los módulos ES importar desde módulos CommonJS. Por lo tanto, aunque el código CommonJS todavía es algo con lo que te encontrarás, ya no hay una razón real para escribir programas nuevos en este estilo.</p>

<h2><a class="h_ident" id="h-zWTXAU93DC" href="#h-zWTXAU93DC" tabindex="-1" role="presentation"></a>Construcción y empaquetado</h2>

<p><a class="p_ident" id="p-MwbCHECNZY" href="#p-MwbCHECNZY" tabindex="-1" role="presentation"></a>Muchos paquetes de JavaScript no están, técnicamente, escritos en JavaScript. Hay extensiones, como TypeScript, el dialecto de comprobación de tipos mencionado en <a href="08_error.html#typing">Capítulo 8</a>, que se utilizan ampliamente. La gente también suele empezar a usar extensiones planificadas para el lenguaje mucho antes de que se agreguen a las plataformas que realmente ejecutan JavaScript.</p>

<p><a class="p_ident" id="p-8YI40LC/+x" href="#p-8YI40LC/+x" tabindex="-1" role="presentation"></a>Para hacer esto posible, <em>compilan</em> su código, traduciéndolo desde su dialecto de JavaScript elegido a JavaScript puro—o incluso a una versión anterior de JavaScript—para que los navegadores puedan ejecutarlo.</p><p><a class="p_ident" id="p-ESEmIVUZNc" href="#p-ESEmIVUZNc" tabindex="-1" role="presentation"></a>Incluir un programa modular que consiste en 200 archivos diferentes en una página web produce sus propios problemas. Si buscar un solo archivo en la red toma 50 milisegundos, cargar todo el programa toma 10 segundos, o tal vez la mitad de eso si puedes cargar varios archivos simultáneamente. Eso es mucho tiempo desperdiciado. Debido a que buscar un solo archivo grande tiende a ser más rápido que buscar muchos pequeños, los programadores web han comenzado a usar herramientas que combinan sus programas (que dividieron cuidadosamente en módulos) en un solo archivo grande antes de publicarlo en la Web. Estas herramientas se llaman <em>empaquetadores</em>.</p>

<p><a class="p_ident" id="p-F5bhvXPahh" href="#p-F5bhvXPahh" tabindex="-1" role="presentation"></a>Y podemos ir más allá. Aparte del número de archivos, el <em>tamaño</em> de los archivos también determina cuán rápido pueden transferirse por la red. Por lo tanto, la comunidad de JavaScript ha inventado <em>minificadores</em>. Estas son herramientas que toman un programa de JavaScript y lo hacen más pequeño al eliminar automáticamente comentarios y espacios en blanco, renombrar enlaces, y reemplazar piezas de código con código equivalente que ocupe menos espacio.</p>

<p><a class="p_ident" id="p-jI7bYuMasX" href="#p-jI7bYuMasX" tabindex="-1" role="presentation"></a>Por lo tanto, no es raro que el código que encuentres en un paquete de NPM o que se ejecute en una página web haya pasado por <em>múltiples</em> etapas de transformación—convertido de JavaScript moderno a JavaScript histórico, luego combinando los módulos en un solo archivo, y minificando el código. No entraremos en los detalles de estas herramientas en este libro ya que hay muchas, y cuál es popular cambia regularmente. Simplemente sé consciente de que tales cosas existen, y búscalas cuando las necesites.</p>

<h2><a class="h_ident" id="h-P8pyzbI9vO" href="#h-P8pyzbI9vO" tabindex="-1" role="presentation"></a>Diseño de módulos</h2>

<p><a class="p_ident" id="p-8K2T8s7itK" href="#p-8K2T8s7itK" tabindex="-1" role="presentation"></a>Estructurar programas es uno de los aspectos más sutiles de la programación. Cualquier funcionalidad no trivial puede ser organizada de varias maneras.</p>

<p><a class="p_ident" id="p-98c2qP5s8p" href="#p-98c2qP5s8p" tabindex="-1" role="presentation"></a>El buen diseño de programas es subjetivo—implica compensaciones y cuestiones de gusto. La mejor manera de aprender el valor de un diseño bien estructurado es leer o trabajar en muchos programas y notar qué funciona y qué no. No asumas que un desorden doloroso es "simplemente así". Puedes mejorar la estructura de casi todo poniendo más pensamiento en ello.</p>

<p><a class="p_ident" id="p-uhKTy5PIwF" href="#p-uhKTy5PIwF" tabindex="-1" role="presentation"></a>Un aspecto del diseño de módulos es la facilidad de uso. Si estás diseñando algo que se pretende ser usado por múltiples personas—o incluso por ti mismo, en tres meses cuando ya no recuerdes los detalles de lo que hiciste—es útil que tu interfaz sea simple y predecible.</p><p><a class="p_ident" id="p-hHDSnM2Orb" href="#p-hHDSnM2Orb" tabindex="-1" role="presentation"></a>Eso puede significar seguir convenciones existentes. Un buen ejemplo es el paquete <code>ini</code>. Este módulo imita el objeto estándar <code>JSON</code> al proveer las funciones <code>parse</code> y <code>stringify</code> (para escribir un archivo INI) y, al igual que <code>JSON</code>, convierte entre cadenas y objetos simples. Por lo tanto, la interfaz es pequeña y familiar, y después de haber trabajado con ella una vez, es probable que recuerdes cómo usarla.</p>

<p><a class="p_ident" id="p-zMQYs/H6je" href="#p-zMQYs/H6je" tabindex="-1" role="presentation"></a>Incluso si no hay una función estándar o un paquete ampliamente usado para imitar, puedes mantener tus módulos predecibles al usar estructuras de datos simples y hacer una sola cosa enfoacada. Muchos de los módulos de análisis de archivos INI en NPM proporcionan una función que lee directamente dicho archivo desde el disco y lo analiza, por ejemplo. Esto hace imposible usar dichos módulos en el navegador, donde no tenemos acceso directo al sistema de archivos, y añade complejidad que hubiera sido mejor abordada componiendo el módulo con alguna función de lectura de archivos.</p>

<p><a class="p_ident" id="p-JYcq/PgjlO" href="#p-JYcq/PgjlO" tabindex="-1" role="presentation"></a>Esto señala otro aspecto útil del diseño de módulos: la facilidad con la que algo puede componerse con otro código. Los módulos enfocados en calcular valores son aplicables en una gama más amplia de programas que los módulos más grandes que realizan acciones complicadas con efectos secundarios. Un lector de archivos INI que insiste en leer el archivo desde el disco es inútil en un escenario donde el contenido del archivo proviene de otra fuente.</p>

<p><a class="p_ident" id="p-6cqySeVoki" href="#p-6cqySeVoki" tabindex="-1" role="presentation"></a>Relacionado, los objetos con estado a veces son útiles o incluso necesarios, pero si algo se puede hacer con una función, usa una función. Varios de los lectores de archivos INI en NPM proporcionan un estilo de interfaz que requiere que primero crees un objeto, luego cargues el archivo en tu objeto y finalmente uses métodos especializados para obtener los resultados. Este tipo de enfoque es común en la tradición orientada a objetos y es terrible. En lugar de hacer una sola llamada a una función y continuar, debes realizar el ritual de mover tu objeto a través de sus varios estados. Y como los datos están ahora envueltos en un tipo de objeto especializado, todo el código que interactúa con él debe conocer ese tipo, creando interdependencias innecesarias.</p>

<p><a class="p_ident" id="p-uR7iWbgBIy" href="#p-uR7iWbgBIy" tabindex="-1" role="presentation"></a>A menudo no se puede evitar definir nuevas estructuras de datos—solo unas pocas básicas son proporcionadas por el estándar del lenguaje, y muchos tipos de datos tienen que ser más complejos que un arreglo o un mapa. Pero cuando un arreglo es suficiente, usa un arreglo.</p>

<p><a class="p_ident" id="p-B+RLCa+Zi+" href="#p-B+RLCa+Zi+" tabindex="-1" role="presentation"></a>Un ejemplo de una estructura de datos ligeramente más compleja es el grafo del <a href="07_robot.html">Capítulo 7</a>. No hay una única forma obvia de representar un grafo en JavaScript. En ese capítulo, usamos un objeto cuyas propiedades contienen arreglos de cadenas—los otros nodos alcanzables desde ese nodo.</p><p><a class="p_ident" id="p-17Fkotj+nV" href="#p-17Fkotj+nV" tabindex="-1" role="presentation"></a>Hay varios paquetes de búsqueda de caminos en NPM, pero ninguno de ellos utiliza este formato de grafo. Por lo general, permiten que las aristas del grafo tengan un peso, que es el costo o la distancia asociada a ellas. Eso no es posible en nuestra representación.</p>

<p><a class="p_ident" id="p-d3wpFXYEjN" href="#p-d3wpFXYEjN" tabindex="-1" role="presentation"></a>Por ejemplo, está el paquete <code>dijkstrajs</code>. Un enfoque conocido para la búsqueda de caminos, bastante similar a nuestra función <code>findRoute</code>, se llama <em>algoritmo de Dijkstra</em>, en honor a Edsger Dijkstra, quien lo escribió por primera vez. El sufijo <code>js</code> se añade a menudo a los nombres de los paquetes para indicar que están escritos en JavaScript. Este paquete <code>dijkstrajs</code> utiliza un formato de grafo similar al nuestro, pero en lugar de arrays, utiliza objetos cuyos valores de propiedad son números, los pesos de las aristas.</p>

<p><a class="p_ident" id="p-3iug1e4kQG" href="#p-3iug1e4kQG" tabindex="-1" role="presentation"></a>Así que si quisiéramos usar ese paquete, tendríamos que asegurarnos de que nuestro grafo esté almacenado en el formato que espera. Todas las aristas tienen el mismo peso, ya que nuestro modelo simplificado trata cada camino como teniendo el mismo costo (una vuelta).</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-NyRXVpwPYN" href="#c-NyRXVpwPYN" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> {find_path} = require(<span class="tok-string">"dijkstrajs"</span>);

<span class="tok-keyword">let</span> <span class="tok-definition">grafo</span> = {};
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">nodo</span> <span class="tok-keyword">of</span> Object.keys(roadGraph)) {
  <span class="tok-keyword">let</span> <span class="tok-definition">aristas</span> = grafo[nodo] = {};
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">destino</span> <span class="tok-keyword">of</span> roadGraph[nodo]) {
    aristas[destino] = <span class="tok-number">1</span>;
  }
}

console.log(find_path(grafo, <span class="tok-string">"Oficina de Correos"</span>, <span class="tok-string">"Cabaña"</span>));
<span class="tok-comment">// → ["Oficina de Correos", "Casa de Alicia", "Cabaña"]</span></pre>

<p><a class="p_ident" id="p-X8Ulb726ZC" href="#p-X8Ulb726ZC" tabindex="-1" role="presentation"></a>Esto puede ser una barrera para la composición: cuando varios paquetes están utilizando estructuras de datos diferentes para describir cosas similares, combinarlos es difícil. Por lo tanto, si deseas diseñar para la composabilidad, averigua qué estructuras de datos están utilizando otras personas y, cuando sea posible, sigue su ejemplo.</p>

<p><a class="p_ident" id="p-otAicxL3rq" href="#p-otAicxL3rq" tabindex="-1" role="presentation"></a>Diseñar una estructura de módulo adecuada para un programa puede ser difícil. En la fase en la que todavía estás explorando el problema, tratando diferentes cosas para ver qué funciona, es posible que no quieras preocuparte demasiado por ello, ya que mantener todo organizado puede ser una gran distracción. Una vez que tengas algo que se sienta sólido, ese es un buen momento para dar un paso atrás y organizarlo.</p><h2><a class="h_ident" id="h-ErccPg/l98" href="#h-ErccPg/l98" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-OX2jY0nGFw" href="#p-OX2jY0nGFw" tabindex="-1" role="presentation"></a>Los módulos proporcionan estructura a programas más grandes al separar el código en piezas con interfaces claras y dependencias. La interfaz es la parte del módulo que es visible para otros módulos, y las dependencias son los otros módulos de los que hace uso.</p>

<p><a class="p_ident" id="p-QRNMabkLEU" href="#p-QRNMabkLEU" tabindex="-1" role="presentation"></a>Porque JavaScript no proporcionaba históricamente un sistema de módulos, se construyó el sistema CommonJS sobre él. Luego, en cierto punto, <em>sí</em> obtuvo un sistema incorporado, el cual ahora coexiste incómodamente con el sistema CommonJS.</p>

<p><a class="p_ident" id="p-wDM2Q8HBcB" href="#p-wDM2Q8HBcB" tabindex="-1" role="presentation"></a>Un paquete es un fragmento de código que puede distribuirse por sí solo. NPM es un repositorio de paquetes de JavaScript. Desde allí puedes descargar todo tipo de paquetes útiles (y inútiles).</p>

<h2><a class="h_ident" id="h-TcUD2vzyMe" href="#h-TcUD2vzyMe" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-CJKk6NIC0T" href="#i-CJKk6NIC0T" tabindex="-1" role="presentation"></a>Un robot modular</h3>

<p id="modular_robot"><a class="p_ident" id="p-nPAEnO4pep" href="#p-nPAEnO4pep" tabindex="-1" role="presentation"></a>Estos son los vínculos que el proyecto del <a href="07_robot.html">Capítulo 7</a> crea:</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-/nxTd1W0Sy" href="#c-/nxTd1W0Sy" tabindex="-1" role="presentation"></a>roads
buildGraph
roadGraph
VillageState
runRobot
randomPick
randomRobot
mailRoute
routeRobot
findRoute
goalOrientedRobot</pre>

<p><a class="p_ident" id="p-0LdymcLoV8" href="#p-0LdymcLoV8" tabindex="-1" role="presentation"></a>Si tuvieras que escribir ese proyecto como un programa modular, ¿qué módulos crearías? ¿Qué módulo dependería de qué otro módulo, y cómo serían sus interfaces?</p>

<p><a class="p_ident" id="p-hU/u/IPER+" href="#p-hU/u/IPER+" tabindex="-1" role="presentation"></a>¿Qué piezas es probable que estén disponibles preescritas en NPM? ¿Preferirías usar un paquete de NPM o escribirlos tú mismo?</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-o3MT4wM7DB" href="#p-o3MT4wM7DB" tabindex="-1" role="presentation"></a>Esto es lo que haría (pero nuevamente, no hay una única forma <em>correcta</em> de diseñar un módulo en particular):</p>

<p><a class="p_ident" id="p-vUAq68NJ8i" href="#p-vUAq68NJ8i" tabindex="-1" role="presentation"></a>El código utilizado para construir el grafo de caminos se encuentra en el módulo <code>graph</code>. Como preferiría usar <code>dijkstrajs</code> de NPM en lugar de nuestro propio código de búsqueda de rutas, haremos que este construya el tipo de datos de grafo que <code>dijkstrajs</code> espera. Este módulo exporta una única función, <code>buildGraph</code>. Haría que <code>buildGraph</code> acepte un conjunto de arreglos de dos elementos en lugar de cadenas que contienen guiones, para hacer que el módulo dependa menos del formato de entrada.</p><p><a class="p_ident" id="p-6iLUlYHKWk" href="#p-6iLUlYHKWk" tabindex="-1" role="presentation"></a>El módulo <code>roads</code> contiene los datos brutos de las carreteras (el array <code>roads</code>) y el enlace <code>roadGraph</code>. Este módulo depende de <code>./graph.js</code> y exporta el grafo de carreteras.</p>

<p><a class="p_ident" id="p-JLwefzFde0" href="#p-JLwefzFde0" tabindex="-1" role="presentation"></a>La clase <code>VillageState</code> vive en el módulo <code>state</code>. Depende del módulo <code>./roads</code> porque necesita verificar que una carretera dada existe. También necesita <code>randomPick</code>. Dado que es una función de tres líneas, podríamos simplemente colocarla en el módulo <code>state</code> como una función auxiliar interna. Pero <code>randomRobot</code> también la necesita. Así que tendríamos que duplicarla o ponerla en su propio módulo. Dado que esta función resulta estar disponible en NPM en el paquete <code>random-item</code>, una solución razonable es hacer que ambos módulos dependan de eso. También podemos añadir la función <code>runRobot</code> a este módulo, ya que es pequeña y está relacionada estrechamente con la gestión del estado. Este módulo exporta tanto la clase <code>VillageState</code> como la función <code>runRobot</code>.</p>

<p><a class="p_ident" id="p-aTXmbvQIkt" href="#p-aTXmbvQIkt" tabindex="-1" role="presentation"></a>Finalmente, los robots, junto con los valores en los que dependen como <code>mailRoute</code>, podrían ir en un módulo <code>example-robots</code>, que depende de <code>./roads</code> y exporta las funciones de los robots. Para que sea posible que el <code>goalOrientedRobot</code> encuentre rutas, este módulo también depende de <code>dijkstrajs</code>.</p>

<p><a class="p_ident" id="p-jU189+mtkS" href="#p-jU189+mtkS" tabindex="-1" role="presentation"></a>Al externalizar parte del trabajo a módulos de NPM, el código se volvió un poco más pequeño. Cada módulo individual hace algo bastante simple y puede ser leído por separado. Dividir el código en módulos también a menudo sugiere mejoras adicionales en el diseño del programa. En este caso, parece un poco extraño que el <code>VillageState</code> y los robots dependan de un gráfico de carreteras específico. Podría ser una mejor idea hacer que el gráfico sea un argumento del constructor del estado y hacer que los robots lo lean del objeto de estado, esto reduce las dependencias (lo cual siempre es bueno) y hace posible ejecutar simulaciones en mapas diferentes (lo cual es aún mejor).</p>

<p><a class="p_ident" id="p-rfGj5/gdUx" href="#p-rfGj5/gdUx" tabindex="-1" role="presentation"></a>¿Es una buena idea usar módulos de NPM para cosas que podríamos haber escrito nosotros mismos? En principio, sí, para cosas no triviales como la función de búsqueda de rutas es probable que cometas errores y pierdas tiempo escribiéndolas tú mismo. Para funciones pequeñas como <code>random-item</code>, escribirlas tú mismo es lo suficientemente fácil. Pero añadirlas donde las necesitas tiende a saturar tus módulos.</p>

<p><a class="p_ident" id="p-shhnxYPdPj" href="#p-shhnxYPdPj" tabindex="-1" role="presentation"></a>Sin embargo, tampoco debes subestimar el trabajo involucrado en <em>encontrar</em> un paquete NPM apropiado. E incluso si encuentras uno, podría no funcionar bien o podrías necesitar alguna función que no tenga. Además, depender de paquetes NPM significa que debes asegurarte de que están instalados, debes distribuirlos con tu programa y tal vez debas actualizarlos periódicamente.</p><p><a class="p_ident" id="p-B1mDzf2p8t" href="#p-B1mDzf2p8t" tabindex="-1" role="presentation"></a>Entonces, de nuevo, esto es un compromiso, y puedes decidir de cualquier manera dependiendo de cuánto realmente te ayuda un paquete dado.</p>

</div></details>

<h3><a class="i_ident" id="i-+pU//gQmZ8" href="#i-+pU//gQmZ8" tabindex="-1" role="presentation"></a>Módulo de caminos</h3>

<p><a class="p_ident" id="p-bfMZIuPnuG" href="#p-bfMZIuPnuG" tabindex="-1" role="presentation"></a>Escribe un módulo de ES, basado en el ejemplo del <a href="07_robot.html">Capítulo 7</a>, que contenga el array de caminos y exporte la estructura de datos gráfica que los representa como <code>roadGraph</code>. Debería depender de un módulo <code>./graph.js</code>, que exporta una función <code>buildGraph</code> que se utiliza para construir el grafo. Esta función espera un array de arrays de dos elementos (los puntos de inicio y fin de los caminos).</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-FPEwj7xDOs" href="#c-FPEwj7xDOs" tabindex="-1" role="presentation"></a><span class="tok-comment">// Agregar dependencias y exportaciones</span>

<span class="tok-keyword">const</span> <span class="tok-definition">roads</span> = [
  <span class="tok-string">"Casa de Alicia-Casa de Bob"</span>,   <span class="tok-string">"Casa de Alicia-Cabaña"</span>,
  <span class="tok-string">"Casa de Alicia-Oficina de Correos"</span>,   <span class="tok-string">"Casa de Bob-Casa Consistorial"</span>,
  <span class="tok-string">"Casa de Daria-Casa de Ernie"</span>, <span class="tok-string">"Casa de Daria-Casa Consistorial"</span>,
  <span class="tok-string">"Casa de Ernie-Casa de Grete"</span>, <span class="tok-string">"Casa de Grete-Granja"</span>,
  <span class="tok-string">"Casa de Grete-Tienda"</span>,          <span class="tok-string">"Plaza-Mercado"</span>,
  <span class="tok-string">"Plaza-Oficina de Correos"</span>,     <span class="tok-string">"Plaza-Tienda"</span>,
  <span class="tok-string">"Plaza-Casa Consistorial"</span>,       <span class="tok-string">"Tienda-Casa Consistorial"</span>
];</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-KWk09Gyhem" href="#p-KWk09Gyhem" tabindex="-1" role="presentation"></a>Dado que este es un módulo de ES, debes usar <code>import</code> para acceder al módulo de grafo. Se describió que exporta una función <code>buildGraph</code>, que puedes seleccionar de su objeto de interfaz con una declaración de desestructuración <code>const</code>.</p>

<p><a class="p_ident" id="p-49X3DlQnvo" href="#p-49X3DlQnvo" tabindex="-1" role="presentation"></a>Para exportar <code>roadGraph</code>, colocas la palabra clave <code>export</code> antes de su definición. Debido a que <code>buildGraph</code> toma una estructura de datos que no coincide exactamente con <code>roads</code>, la separación de las cadenas de caminos debe ocurrir en tu módulo.</p>

</div></details>

<h3><a class="i_ident" id="i-E/zWqBFdy8" href="#i-E/zWqBFdy8" tabindex="-1" role="presentation"></a>Dependencias circulares</h3><p><a class="p_ident" id="p-fl2MZMonQV" href="#p-fl2MZMonQV" tabindex="-1" role="presentation"></a>Una dependencia circular es una situación en la que el módulo A depende de B, y B también, directa o indirectamente, depende de A. Muchos sistemas de módulos simplemente prohíben esto porque no importa en qué orden elijas cargar esos módulos, no puedes asegurarte de que las dependencias de cada módulo hayan sido cargadas antes de que se ejecuten.</p>

<p><a class="p_ident" id="p-b5sTJIUt38" href="#p-b5sTJIUt38" tabindex="-1" role="presentation"></a>Los módulos de CommonJS permiten una forma limitada de dependencias cíclicas. Siempre y cuando los módulos no accedan a la interfaz de los demás hasta después de que terminen de cargarse, las dependencias cíclicas están permitidas.</p>

<p><a class="p_ident" id="p-ZjAGpje4gs" href="#p-ZjAGpje4gs" tabindex="-1" role="presentation"></a>La función <code>require</code> mencionada <a href="10_modules.html#require">anteriormente en este capítulo</a> admite este tipo de ciclo de dependencia. ¿Puedes ver cómo maneja los ciclos?</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-nf2U1lY9dq" href="#p-nf2U1lY9dq" tabindex="-1" role="presentation"></a>El truco es que <code>require</code> agrega el objeto de interfaz para un módulo a su caché <em>antes</em> de comenzar a cargar el módulo. De esta manera, si se realiza alguna llamada a <code>require</code> mientras se está ejecutando para cargarlo, ya se conoce, y se devolverá la interfaz actual, en lugar de comenzar a cargar el módulo nuevamente (lo que eventualmente desbordaría la pila).</p>

</div></details><nav><a href="09_regexp.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="11_async.html" title="siguiente capítulo" aria-label="siguiente capítulo">▸</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>
</article>

<script src="js/ejs.js"></script>
</body></html>
<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Proyecto: Un Robot :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="css/ejs.css"><script>
      var page = {"type":"chapter","number":7,"load_files":["code/chapter/07_robot.js","code/animatevillage.js"]}</script></head>

<body><article>
<nav><a href="06_object.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="08_error.html" title="próximo capítulo" aria-label="próximo capítulo">▸</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>

<h1>Proyecto: Un Robot</h1>

<blockquote>

<p><a class="p_ident" id="p-uJUZHUrdPa" href="#p-uJUZHUrdPa" tabindex="-1" role="presentation"></a>[...] la pregunta de si las Máquinas Pueden Pensar [...] es tan relevante como la pregunta de si los Submarinos Pueden Nadar.</p>

<footer>Edsger Dijkstra, <cite>Las Amenazas para la Ciencia de la Computación</cite></footer>

</blockquote><figure class="chapter framed"><img src="images/chapter_picture_7.jpg" alt="Ilustración de un robot sosteniendo un montón de paquetes"></figure>

<p><a class="p_ident" id="p-5AQpMxl1Fi" href="#p-5AQpMxl1Fi" tabindex="-1" role="presentation"></a>En los capítulos de "proyecto", dejaré de bombardearte con nueva teoría por un breve momento, y en su lugar trabajaremos juntos en un programa. La teoría es necesaria para aprender a programar, pero leer y entender programas reales es igual de importante.</p>

<p><a class="p_ident" id="p-ncfl8fD8N8" href="#p-ncfl8fD8N8" tabindex="-1" role="presentation"></a>Nuestro proyecto en este capítulo es construir un autómata, un pequeño programa que realiza una tarea en un mundo virtual. Nuestro autómata será un robot repartidor de correo que recoge y entrega paquetes.</p>

<h2><a class="h_ident" id="h-UmFK5fYed8" href="#h-UmFK5fYed8" tabindex="-1" role="presentation"></a>Meadowfield</h2>

<p><a class="p_ident" id="p-Llm45GA7/u" href="#p-Llm45GA7/u" tabindex="-1" role="presentation"></a>El pueblo de Pradera no es muy grande. Consiste en 11 lugares con 14 caminos entre ellos. Puede ser descrito con este array de caminos:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Zs4LZxNb9d" href="#c-Zs4LZxNb9d" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">caminos</span> = [
  <span class="tok-string">"Casa de Alicia-Casa de Bob"</span>,   <span class="tok-string">"Casa de Alicia-Cabaña"</span>,
  <span class="tok-string">"Casa de Alicia-Oficina de Correos"</span>,   <span class="tok-string">"Casa de Bob-Ayuntamiento"</span>,
  <span class="tok-string">"Casa de Daria-Casa de Ernie"</span>, <span class="tok-string">"Casa de Daria-Ayuntamiento"</span>,
  <span class="tok-string">"Casa de Ernie-Casa de Grete"</span>, <span class="tok-string">"Casa de Grete-Granja"</span>,
  <span class="tok-string">"Casa de Grete-Tienda"</span>,          <span class="tok-string">"Plaza-Mercado"</span>,
  <span class="tok-string">"Plaza-Oficina de Correos"</span>,     <span class="tok-string">"Plaza-Tienda"</span>,
  <span class="tok-string">"Plaza-Ayuntamiento"</span>,       <span class="tok-string">"Tienda-Ayuntamiento"</span>
];</pre><figure><img src="images/village2x.png" alt="Ilustración de arte pixelado de un pequeño pueblo con 11 ubicaciones, etiquetadas con letras, y caminos entre ellas"></figure><p><a class="p_ident" id="p-kUSGv0smF0" href="#p-kUSGv0smF0" tabindex="-1" role="presentation"></a>La red de carreteras en el pueblo forma un <em>gráfico</em>. Un gráfico es una colección de puntos (lugares en el pueblo) con líneas entre ellos (carreteras). Este gráfico será el mundo por el que se moverá nuestro robot.</p>

<p><a class="p_ident" id="p-zOR53PiwWK" href="#p-zOR53PiwWK" tabindex="-1" role="presentation"></a>El array de cadenas no es muy fácil de trabajar. Lo que nos interesa son los destinos a los que podemos llegar desde un lugar dado. Vamos a convertir la lista de carreteras a una estructura de datos que, para cada lugar, nos diga qué se puede alcanzar desde allí.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-k8seJpRr5W" href="#c-k8seJpRr5W" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">construirGrafo</span>(<span class="tok-definition">aristas</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">grafo</span> = Object.create(<span class="tok-keyword">null</span>);
  <span class="tok-keyword">function</span> <span class="tok-definition">agregarArista</span>(<span class="tok-definition">desde</span>, <span class="tok-definition">a</span>) {
    <span class="tok-keyword">if</span> (desde <span class="tok-keyword">in</span> grafo) {
      grafo[desde].push(a);
    } <span class="tok-keyword">else</span> {
      grafo[desde] = [a];
    }
  }
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> [<span class="tok-definition">desde</span>, <span class="tok-definition">a</span>] <span class="tok-keyword">of</span> aristas.map(<span class="tok-definition">r</span> =&gt; r.split(<span class="tok-string">"-"</span>))) {
    agregarArista(desde, a);
    agregarArista(a, desde);
  }
  <span class="tok-keyword">return</span> grafo;
}

<span class="tok-keyword">const</span> <span class="tok-definition">grafoCarreteras</span> = construirGrafo(carreteras);</pre>

<p><a class="p_ident" id="p-zU4tmOhQOK" href="#p-zU4tmOhQOK" tabindex="-1" role="presentation"></a>Dado un array de aristas, <code>construirGrafo</code> crea un objeto de mapa que, para cada nodo, almacena un array de nodos conectados.</p>

<p><a class="p_ident" id="p-/ajYefvBv4" href="#p-/ajYefvBv4" tabindex="-1" role="presentation"></a>Utiliza el método <code>split</code> para pasar de las cadenas de carreteras, que tienen la forma <code>"Inicio-Fin"</code>, a arrays de dos elementos que contienen el inicio y el fin como cadenas separadas.</p>

<h2><a class="h_ident" id="h-oekYfM5x02" href="#h-oekYfM5x02" tabindex="-1" role="presentation"></a>La tarea</h2>

<p><a class="p_ident" id="p-pNB+8S9YMh" href="#p-pNB+8S9YMh" tabindex="-1" role="presentation"></a>Nuestro robot se moverá por el pueblo. Hay paquetes en varios lugares, cada uno dirigido a otro lugar. El robot recoge los paquetes cuando llega a ellos y los entrega cuando llega a sus destinos.</p>

<p><a class="p_ident" id="p-jBwlptGwo9" href="#p-jBwlptGwo9" tabindex="-1" role="presentation"></a>El autómata debe decidir, en cada punto, hacia dónde ir a continuación. Habrá completado su tarea cuando todos los paquetes hayan sido entregados.</p><p><a class="p_ident" id="p-xZG2sIniIX" href="#p-xZG2sIniIX" tabindex="-1" role="presentation"></a>Para poder simular este proceso, debemos definir un mundo virtual que pueda describirlo. Este modelo nos dice dónde está el robot y dónde están los paquetes. Cuando el robot ha decidido moverse a algún lugar, necesitamos actualizar el modelo para reflejar la nueva situación.</p>

<p><a class="p_ident" id="p-XP2aQths2D" href="#p-XP2aQths2D" tabindex="-1" role="presentation"></a>Si estás pensando en términos de programación orientada a objetos, tu primer impulso podría ser empezar a definir objetos para los varios elementos en el mundo: una clase para el robot, una para un paquete, tal vez una para lugares. Estos podrían entonces contener propiedades que describan su estado actual, como la acumulación de paquetes en una ubicación, que podríamos cambiar al actualizar el mundo.</p>

<p><a class="p_ident" id="p-2a4AZsvYpo" href="#p-2a4AZsvYpo" tabindex="-1" role="presentation"></a>Esto es incorrecto. Al menos, usualmente lo es. El hecho de que algo suene como un objeto no significa automáticamente que deba ser un objeto en tu programa. Escribir reflexivamente clases para cada concepto en tu aplicación tiende a dejarte con una colección de objetos interconectados que tienen cada uno su propio estado interno cambiante. Dichos programas a menudo son difíciles de entender y por lo tanto fáciles de romper.</p>

<p><a class="p_ident" id="p-GAVnAUZ9xz" href="#p-GAVnAUZ9xz" tabindex="-1" role="presentation"></a>En cambio, condensemos el estado del pueblo en el conjunto mínimo de valores que lo definen. Está la ubicación actual del robot y la colección de paquetes no entregados, cada uno de los cuales tiene una ubicación actual y una dirección de destino. Eso es todo.</p>

<p><a class="p_ident" id="p-/m1Ukpe9vV" href="#p-/m1Ukpe9vV" tabindex="-1" role="presentation"></a>Y mientras estamos en ello, hagamos que no <em>modifiquemos</em> este estado cuando el robot se mueve, sino más bien que calculemos un <em>nuevo</em> estado para la situación después del movimiento.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-VcDNIi1lcV" href="#c-VcDNIi1lcV" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> EstadoPueblo {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">lugar</span>, <span class="tok-definition">paquetes</span>) {
    <span class="tok-keyword">this</span>.lugar = lugar;
    <span class="tok-keyword">this</span>.paquetes = paquetes;
  }

  <span class="tok-definition">mover</span>(<span class="tok-definition">destino</span>) {
    <span class="tok-keyword">if</span> (!grafoCarreteras[<span class="tok-keyword">this</span>.lugar].includes(destino)) {
      <span class="tok-keyword">return</span> <span class="tok-keyword">this</span>;
    } <span class="tok-keyword">else</span> {
      <span class="tok-keyword">let</span> <span class="tok-definition">paquetes</span> = <span class="tok-keyword">this</span>.paquetes.map(<span class="tok-definition">p</span> =&gt; {
        <span class="tok-keyword">if</span> (p.lugar != <span class="tok-keyword">this</span>.lugar) <span class="tok-keyword">return</span> p;
        <span class="tok-keyword">return</span> {<span class="tok-definition">lugar</span>: destino, <span class="tok-definition">direccion</span>: p.direccion};
      }).filter(<span class="tok-definition">p</span> =&gt; p.lugar != p.direccion);
      <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> EstadoPueblo(destino, paquetes);
    }
  }
}</pre><p><a class="p_ident" id="p-+1K4cYKxXh" href="#p-+1K4cYKxXh" tabindex="-1" role="presentation"></a>El método <code>move</code> es donde ocurre la acción. Primero verifica si hay un camino desde el lugar actual hasta el destino, y si no lo hay, devuelve el antiguo estado ya que este no es un movimiento válido.</p>

<p><a class="p_ident" id="p-8hikodLOP1" href="#p-8hikodLOP1" tabindex="-1" role="presentation"></a>Luego crea un nuevo estado con el destino como el nuevo lugar del robot. Pero también necesita crear un nuevo conjunto de paquetes—los paquetes que el robot lleva consigo (que están en el lugar actual del robot) deben moverse al nuevo lugar. Y los paquetes dirigidos al nuevo lugar deben ser entregados—es decir, deben ser eliminados del conjunto de paquetes no entregados. La llamada a <code>map</code> se encarga del movimiento, y la llamada a <code>filter</code> hace la entrega.</p>

<p><a class="p_ident" id="p-PcrmPD5IEr" href="#p-PcrmPD5IEr" tabindex="-1" role="presentation"></a>Los objetos de paquete no cambian cuando se mueven, sino que se recrean. El método <code>move</code> nos da un nuevo estado de la aldea pero deja intacto el antiguo estado por completo.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Z0crEkc0Bs" href="#c-Z0crEkc0Bs" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">first</span> = <span class="tok-keyword">new</span> VillageState(
  <span class="tok-string">"Oficina de Correos"</span>,
  [{<span class="tok-definition">place</span>: <span class="tok-string">"Oficina de Correos"</span>, <span class="tok-definition">address</span>: <span class="tok-string">"Casa de Alicia"</span>}]
);
<span class="tok-keyword">let</span> <span class="tok-definition">next</span> = first.move(<span class="tok-string">"Casa de Alicia"</span>);

console.log(next.place);
<span class="tok-comment">// → Casa de Alicia</span>
console.log(next.parcels);
<span class="tok-comment">// → []</span>
console.log(first.place);
<span class="tok-comment">// → Oficina de Correos</span></pre>

<p><a class="p_ident" id="p-tNPZKPr/w9" href="#p-tNPZKPr/w9" tabindex="-1" role="presentation"></a>El movimiento hace que el paquete sea entregado, y esto se refleja en el siguiente estado. Pero el estado inicial sigue describiendo la situación donde el robot está en la oficina de correos y el paquete no ha sido entregado.</p>

<h2><a class="h_ident" id="h-BgRu2ZQp4Z" href="#h-BgRu2ZQp4Z" tabindex="-1" role="presentation"></a>Datos persistentes</h2>

<p><a class="p_ident" id="p-0XMckw7hMq" href="#p-0XMckw7hMq" tabindex="-1" role="presentation"></a>Las estructuras de datos que no cambian se llaman <em>inmutables</em> o <em>persistentes</em>. Se comportan de manera similar a las cadenas y números en el sentido de que son lo que son y permanecen así, en lugar de contener diferentes cosas en diferentes momentos.</p>

<p><a class="p_ident" id="p-Vzwj9t5LXR" href="#p-Vzwj9t5LXR" tabindex="-1" role="presentation"></a>En JavaScript, casi todo <em>puede</em> ser cambiado, por lo que trabajar con valores que se supone que son persistentes requiere cierta moderación. Existe una función llamada <code>Object.freeze</code> que cambia un objeto para que escribir en sus propiedades se ignore. Podrías usar eso para asegurarte de que tus objetos no sean modificados, si así lo deseas. Congelar requiere que la computadora haga un trabajo extra, y que las actualizaciones sean ignoradas es tan probable confundir a alguien como hacer la acción incorrecta. Por ello, suelo preferir simplemente decirle a las personas que un objeto dado no debería ser modificado y esperar que lo recuerden.</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-tzmey+74SE" href="#c-tzmey+74SE" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">objeto</span> = Object.freeze({<span class="tok-definition">valor</span>: <span class="tok-number">5</span>});
objeto.value = <span class="tok-number">10</span>;
console.log(objeto.value);
<span class="tok-comment">// → 5</span></pre>

<p><a class="p_ident" id="p-HAywJetNsC" href="#p-HAywJetNsC" tabindex="-1" role="presentation"></a>¿Por qué me estoy esforzando tanto en no cambiar los objetos cuando el lenguaje obviamente espera que lo haga?</p>

<p><a class="p_ident" id="p-OeVgQQywMt" href="#p-OeVgQQywMt" tabindex="-1" role="presentation"></a>Porque me ayuda a entender mis programas. Se trata nuevamente de la gestión de la complejidad. Cuando los objetos en mi sistema son cosas fijas y estables, puedo considerar las operaciones sobre ellos de forma aislada: moverme a la casa de Alicia desde un estado inicial dado siempre produce el mismo nuevo estado. Cuando los objetos cambian con el tiempo, eso añade una nueva dimensión de complejidad a este tipo de razonamiento.</p>

<p><a class="p_ident" id="p-/7pvpOtS4H" href="#p-/7pvpOtS4H" tabindex="-1" role="presentation"></a>Para un sistema pequeño como el que estamos construyendo en este capítulo, podríamos manejar ese poco de complejidad adicional. Pero el límite más importante de qué tipo de sistemas podemos construir es cuánto podemos entender. Cualquier cosa que haga que tu código sea más fácil de entender permite construir un sistema más ambicioso.</p>

<p><a class="p_ident" id="p-rFxLbiWTcZ" href="#p-rFxLbiWTcZ" tabindex="-1" role="presentation"></a>Lamentablemente, aunque entender un sistema construido sobre estructuras de datos persistentes es más fácil, <em>diseñar</em> uno, especialmente cuando tu lenguaje de programación no ayuda, puede ser un poco más difícil. Buscaremos oportunidades para usar estructuras de datos persistentes en este libro, pero también estaremos usando estructuras cambiables.</p>

<h2><a class="h_ident" id="h-jjSUPDU+nv" href="#h-jjSUPDU+nv" tabindex="-1" role="presentation"></a>Simulación</h2>

<p><a class="p_ident" id="p-rl+72XAu8V" href="#p-rl+72XAu8V" tabindex="-1" role="presentation"></a>Un robot de reparto observa el mundo y decide en qué dirección desea moverse. Podríamos decir que un robot es una función que toma un objeto <code>VillageState</code> y devuelve el nombre de un lugar cercano.</p>

<p><a class="p_ident" id="p-d4Z1LYlBJq" href="#p-d4Z1LYlBJq" tabindex="-1" role="presentation"></a>Porque queremos que los robots puedan recordar cosas, para que puedan hacer y ejecutar planes, también les pasamos su memoria y les permitimos devolver una nueva memoria. Así, lo que un robot devuelve es un objeto que contiene tanto la dirección en la que desea moverse como un valor de memoria que se le devolverá la próxima vez que se llame.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-PAmfnoCtiQ" href="#c-PAmfnoCtiQ" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">runRobot</span>(<span class="tok-definition">estado</span>, <span class="tok-definition">robot</span>, <span class="tok-definition">memoria</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">turno</span> = <span class="tok-number">0</span>;; turno++) {
    <span class="tok-keyword">if</span> (estado.parcels.length == <span class="tok-number">0</span>) {
      console.log(<span class="tok-string2">`Hecho en </span>${turno}<span class="tok-string2"> giros`</span>);
      <span class="tok-keyword">break</span>;
    }
    <span class="tok-keyword">let</span> <span class="tok-definition">accion</span> = robot(estado, memoria);
    estado = estado.move(accion.direccion);
    memoria = accion.memoria;
    console.log(<span class="tok-string2">`Movido a </span>${accion.direccion}<span class="tok-string2">`</span>);
  }
}</pre><p><a class="p_ident" id="p-J4CsIfXFJR" href="#p-J4CsIfXFJR" tabindex="-1" role="presentation"></a>Considerar lo que un robot tiene que hacer para "resolver" un estado dado. Debe recoger todos los paquetes visitando cada ubicación que tiene un paquete y entregarlos visitando cada ubicación a la que está dirigido un paquete, pero solo después de recoger el paquete.</p>

<p><a class="p_ident" id="p-g8y41m0ZTO" href="#p-g8y41m0ZTO" tabindex="-1" role="presentation"></a>¿Cuál es la estrategia más tonta que podría funcionar? El robot podría simplemente caminar en una dirección aleatoria en cada movimiento. Eso significa, con gran probabilidad, que eventualmente se encontrará con todos los paquetes y luego, en algún momento, también llegará al lugar donde deben ser entregados.</p>

<p><a class="p_ident" id="p-6Z1OgF/YEs" href="#p-6Z1OgF/YEs" tabindex="-1" role="presentation"></a>Esto es lo que podría parecer:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-eldzpwzhOB" href="#c-eldzpwzhOB" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">randomPick</span>(<span class="tok-definition">array</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">eleccion</span> = Math.floor(Math.random() * array.length);
  <span class="tok-keyword">return</span> array[eleccion];
}

<span class="tok-keyword">function</span> <span class="tok-definition">randomRobot</span>(<span class="tok-definition">estado</span>) {
  <span class="tok-keyword">return</span> {<span class="tok-definition">direccion</span>: randomPick(roadGraph[estado.place])};
}</pre>

<p><a class="p_ident" id="p-XxHqvuoIVP" href="#p-XxHqvuoIVP" tabindex="-1" role="presentation"></a>Recordar que <code>Math.random()</code> devuelve un número entre cero y uno, pero siempre por debajo de uno. Multiplicar ese número por la longitud de un array y luego aplicar <code>Math.floor</code> nos da un índice aleatorio para el array.</p>

<p><a class="p_ident" id="p-sb9lL4ZUdF" href="#p-sb9lL4ZUdF" tabindex="-1" role="presentation"></a>Dado que este robot no necesita recordar nada, ignora su segundo argumento (recordar que las funciones de JavaScript pueden ser llamadas con argumentos extra sin efectos perjudiciales) y omite la propiedad <code>memory</code> en el objeto devuelto.</p>

<p><a class="p_ident" id="p-7mrYzKngQi" href="#p-7mrYzKngQi" tabindex="-1" role="presentation"></a>Para poner a trabajar a este sofisticado robot, primero necesitaremos una forma de crear un nuevo estado con algunos paquetes. Un método estático (escrito aquí directamente agregando una propiedad al constructor) es un buen lugar para poner esa funcionalidad.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-oz9CFlpcci" href="#c-oz9CFlpcci" tabindex="-1" role="presentation"></a>VillageState.random = <span class="tok-keyword">function</span>(<span class="tok-definition">cantidadDePaquetes</span> = <span class="tok-number">5</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">paquetes</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; cantidadDePaquetes; i++) {
    <span class="tok-keyword">let</span> <span class="tok-definition">direccion</span> = randomPick(Object.keys(roadGraph));
    <span class="tok-keyword">let</span> <span class="tok-definition">lugar</span>;
    <span class="tok-keyword">do</span> {
      lugar = randomPick(Object.keys(roadGraph));
    } <span class="tok-keyword">while</span> (lugar == direccion);
    paquetes.push({<span class="tok-definition">lugar</span>, <span class="tok-definition">direccion</span>});
  }
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> VillageState(<span class="tok-string">"Oficina de Correos"</span>, paquetes);
};</pre><p><a class="p_ident" id="p-0gS69ySVJ4" href="#p-0gS69ySVJ4" tabindex="-1" role="presentation"></a>No queremos ningún paquete que sea enviado desde el mismo lugar al que se dirige. Por esta razón, el bucle <code>do</code> sigue eligiendo nuevos lugares cuando obtiene uno que es igual a la dirección.</p>

<p><a class="p_ident" id="p-eqF9VU0qYO" href="#p-eqF9VU0qYO" tabindex="-1" role="presentation"></a>Comencemos un mundo virtual.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-1SZDRlmBkn" href="#c-1SZDRlmBkn" tabindex="-1" role="presentation"></a>runRobot(VillageState.random(), randomRobot);
<span class="tok-comment">// → Se movió al Mercado</span>
<span class="tok-comment">// → Se movió al Ayuntamiento</span>
<span class="tok-comment">// → …</span>
<span class="tok-comment">// → Realizado en 63 turnos</span></pre>

<p><a class="p_ident" id="p-BFu/OgG6OM" href="#p-BFu/OgG6OM" tabindex="-1" role="presentation"></a>El robot tarda muchas vueltas en entregar los paquetes porque no está planificando bien por adelantado. Abordaremos eso pronto.</p>

<p><a class="p_ident" id="p-2yLwjyXxuR" href="#p-2yLwjyXxuR" tabindex="-1" role="presentation"></a>Para una perspectiva más agradable de la simulación, puedes usar la función <code>runRobotAnimation</code> que está disponible en <a href="https://eloquentjavascript.net/code/#7">el entorno de programación de este capítulo</a>. Esto ejecuta la simulación, pero en lugar de mostrar texto, te muestra al robot moviéndose por el mapa del pueblo.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-jWQlJ73x2Z" href="#c-jWQlJ73x2Z" tabindex="-1" role="presentation"></a>runRobotAnimation(VillageState.random(), randomRobot);</pre>

<p><a class="p_ident" id="p-ID6/NPeNSk" href="#p-ID6/NPeNSk" tabindex="-1" role="presentation"></a>La forma en que se implementa <code>runRobotAnimation</code> seguirá siendo un misterio por ahora, pero después de que hayas leído los <a href="14_dom.html">capítulos posteriores</a> de este libro, que discuten la integración de JavaScript en los navegadores web, podrás adivinar cómo funciona.</p>

<h2><a class="h_ident" id="h-Lj40iImbWq" href="#h-Lj40iImbWq" tabindex="-1" role="presentation"></a>La ruta del camión de correo</h2>

<p><a class="p_ident" id="p-srQeoYg/DK" href="#p-srQeoYg/DK" tabindex="-1" role="presentation"></a>Deberíamos poder hacerlo mucho mejor que el robot aleatorio. Una mejora fácil sería tomar una pista de cómo funciona la entrega de correo en el mundo real. Si encontramos una ruta que pase por todos los lugares en el pueblo, el robot podría recorrer esa ruta dos veces, momento en el que se garantiza que haya terminado. Aquí está una de esas rutas (comenzando desde la oficina de correos):</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-smZcG/wBFx" href="#c-smZcG/wBFx" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">mailRoute</span> = [
  <span class="tok-string">"Casa de Alicia"</span>, <span class="tok-string">"Cabaña"</span>, <span class="tok-string">"Casa de Alicia"</span>, <span class="tok-string">"Casa de Bob"</span>,
  <span class="tok-string">"Ayuntamiento"</span>, <span class="tok-string">"Casa de Daria"</span>, <span class="tok-string">"Casa de Ernie"</span>,
  <span class="tok-string">"Casa de Grete"</span>, <span class="tok-string">"Tienda"</span>, <span class="tok-string">"Casa de Grete"</span>, <span class="tok-string">"Granja"</span>,
  <span class="tok-string">"Mercado"</span>, <span class="tok-string">"Oficina de Correos"</span>
];</pre><p><a class="p_ident" id="p-yjFG5x6/qC" href="#p-yjFG5x6/qC" tabindex="-1" role="presentation"></a>Para implementar el robot seguidor de rutas, necesitaremos hacer uso de la memoria del robot. El robot guarda el resto de su ruta en su memoria y descarta el primer elemento en cada giro.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-FlV5rBgCYM" href="#c-FlV5rBgCYM" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">routeRobot</span>(<span class="tok-definition">estado</span>, <span class="tok-definition">memoria</span>) {
  <span class="tok-keyword">if</span> (memoria.length == <span class="tok-number">0</span>) {
    memoria = mailRoute;
  }
  <span class="tok-keyword">return</span> {<span class="tok-definition">dirección</span>: memoria[<span class="tok-number">0</span>], <span class="tok-definition">memoria</span>: memoria.slice(<span class="tok-number">1</span>)};
}</pre>

<p><a class="p_ident" id="p-RfLBkheDsk" href="#p-RfLBkheDsk" tabindex="-1" role="presentation"></a>Este robot ya es mucho más rápido. Tomará un máximo de 26 giros (el doble de la ruta de 13 pasos) pero generalmente menos.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-EkwtJVsUrQ" href="#c-EkwtJVsUrQ" tabindex="-1" role="presentation"></a>runRobotAnimation(VillageState.random(), routeRobot, []);</pre>

<h2><a class="h_ident" id="h-oTHZwtVfKc" href="#h-oTHZwtVfKc" tabindex="-1" role="presentation"></a>Encontrar camino</h2>

<p><a class="p_ident" id="p-zm+XpdJWqT" href="#p-zm+XpdJWqT" tabindex="-1" role="presentation"></a>Aun así, no llamaría a seguir ciegamente una ruta fija un comportamiento inteligente. El robot podría trabajar de manera más eficiente si ajustara su comportamiento a la tarea real que debe realizarse.</p>

<p><a class="p_ident" id="p-I3lgtVYHps" href="#p-I3lgtVYHps" tabindex="-1" role="presentation"></a>Para lograr eso, tiene que ser capaz de moverse deliberadamente hacia un paquete dado o hacia la ubicación donde se debe entregar un paquete. Hacer eso, incluso cuando el objetivo está a más de un movimiento de distancia, requerirá algún tipo de función de búsqueda de ruta.</p>

<p><a class="p_ident" id="p-mZLFbUuvec" href="#p-mZLFbUuvec" tabindex="-1" role="presentation"></a>El problema de encontrar una ruta a través de un grafo es un típico <em>problema de búsqueda</em>. Podemos determinar si una solución dada (una ruta) es válida, pero no podemos calcular directamente la solución como podríamos hacerlo para 2 + 2. En su lugar, tenemos que seguir creando soluciones potenciales hasta encontrar una que funcione.</p>

<p><a class="p_ident" id="p-RL7DngqE+u" href="#p-RL7DngqE+u" tabindex="-1" role="presentation"></a>El número de posibles rutas a través de un grafo es infinito. Pero al buscar una ruta de <em>A</em> a <em>B</em>, solo nos interesan las que comienzan en <em>A</em>. Tampoco nos importan las rutas que visitan el mismo lugar dos veces, esas definitivamente no son la ruta más eficiente. Por lo tanto, se reduce el número de rutas que el buscador de rutas debe considerar.</p><p><a class="p_ident" id="p-tFCHwzdw/z" href="#p-tFCHwzdw/z" tabindex="-1" role="presentation"></a>De hecho, estamos principalmente interesados en la ruta <em>más corta</em>. Por lo tanto, queremos asegurarnos de revisar las rutas cortas antes de mirar las más largas. Un buen enfoque sería "expandir" rutas desde el punto de inicio, explorando cada lugar alcanzable que aún no ha sido visitado, hasta que una ruta alcance la meta. De esta manera, solo exploraremos rutas que sean potencialmente interesantes, y sabremos que la primera ruta que encontremos es la ruta más corta (o una de las rutas más cortas, si hay más de una).</p>

<p id="findRoute"><a class="p_ident" id="p-cQEEfIe4SC" href="#p-cQEEfIe4SC" tabindex="-1" role="presentation"></a>Aquí hay una función que hace esto:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-qT/+IETEgM" href="#c-qT/+IETEgM" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">findRoute</span>(<span class="tok-definition">grafo</span>, <span class="tok-definition">desde</span>, <span class="tok-definition">a</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">trabajo</span> = [{<span class="tok-definition">en</span>: desde, <span class="tok-definition">ruta</span>: []}];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; trabajo.length; i++) {
    <span class="tok-keyword">let</span> {en, ruta} = trabajo[i];
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">lugar</span> <span class="tok-keyword">of</span> grafo[en]) {
      <span class="tok-keyword">if</span> (lugar == a) <span class="tok-keyword">return</span> ruta.concat(lugar);
      <span class="tok-keyword">if</span> (!trabajo.some(<span class="tok-definition">t</span> =&gt; t.en == lugar)) {
        trabajo.push({<span class="tok-definition">en</span>: lugar, <span class="tok-definition">ruta</span>: ruta.concat(lugar)});
      }
    }
  }
}</pre>

<p><a class="p_ident" id="p-OwcNmcqabX" href="#p-OwcNmcqabX" tabindex="-1" role="presentation"></a>La exploración debe hacerse en el orden correcto—los lugares que se alcanzaron primero deben ser explorados primero. No podemos explorar inmediatamente un lugar tan pronto como llegamos a él porque eso significaría que los lugares alcanzados <em>desde ahí</em> también se explorarían inmediatamente, y así sucesivamente, aunque puede haber otros caminos más cortos que aún no se han explorado.</p>

<p><a class="p_ident" id="p-n9z76d0Ph0" href="#p-n9z76d0Ph0" tabindex="-1" role="presentation"></a>Por lo tanto, la función mantiene una <em>lista de trabajo</em>. Esta es un array de lugares que deben ser explorados a continuación, junto con la ruta que nos llevó allí. Comienza con solo la posición de inicio y una ruta vacía.</p>

<p><a class="p_ident" id="p-bijwRAV0uR" href="#p-bijwRAV0uR" tabindex="-1" role="presentation"></a>Luego, la búsqueda funciona tomando el próximo elemento en la lista y explorando eso, lo que significa que se miran todas las carreteras que van desde ese lugar. Si una de ellas es la meta, se puede devolver una ruta terminada. De lo contrario, si no hemos mirado este lugar antes, se agrega un nuevo elemento a la lista. Si lo hemos mirado antes, dado que estamos mirando rutas cortas primero, hemos encontrado o bien una ruta más larga a ese lugar o una precisamente del mismo largo que la existente, y no necesitamos explorarla.</p><p><a class="p_ident" id="p-aN7+zxzOfN" href="#p-aN7+zxzOfN" tabindex="-1" role="presentation"></a>Puedes visualizar esto como una red de rutas conocidas que se extienden desde la ubicación de inicio, creciendo de manera uniforme en todas las direcciones (pero nunca enredándose nuevamente en sí misma). Tan pronto como el primer hilo alcanza la ubicación objetivo, ese hilo es rastreado de vuelta al inicio, dándonos nuestra ruta.</p>

<p><a class="p_ident" id="p-SIkZT2qVfg" href="#p-SIkZT2qVfg" tabindex="-1" role="presentation"></a>Nuestro código no maneja la situación en la que ya no hay más elementos de trabajo en la lista de trabajo porque sabemos que nuestro gráfico está <em>conectado</em>, lo que significa que todas las ubicaciones pueden alcanzarse desde todas las demás ubicaciones. Siempre podremos encontrar una ruta entre dos puntos, y la búsqueda no puede fallar.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-RJgvG9cgxq" href="#c-RJgvG9cgxq" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">goalOrientedRobot</span>({place, parcels}, <span class="tok-definition">route</span>) {
  <span class="tok-keyword">if</span> (route.length == <span class="tok-number">0</span>) {
    <span class="tok-keyword">let</span> <span class="tok-definition">parcel</span> = parcels[<span class="tok-number">0</span>];
    <span class="tok-keyword">if</span> (parcel.place != place) {
      route = findRoute(roadGraph, place, parcel.place);
    } <span class="tok-keyword">else</span> {
      route = findRoute(roadGraph, place, parcel.address);
    }
  }
  <span class="tok-keyword">return</span> {<span class="tok-definition">direction</span>: route[<span class="tok-number">0</span>], <span class="tok-definition">memory</span>: route.slice(<span class="tok-number">1</span>)};
}</pre>

<p><a class="p_ident" id="p-sH38lI2ayD" href="#p-sH38lI2ayD" tabindex="-1" role="presentation"></a>Este robot utiliza su valor de memoria como una lista de direcciones en las que moverse, al igual que el robot que sigue rutas. Cuando esa lista está vacía, tiene que averiguar qué hacer a continuación. Toma el primer paquete no entregado del conjunto y, si ese paquete aún no ha sido recogido, traza una ruta hacia él. Si el paquete <em>ha sido</em> recogido, aún debe ser entregado, así que el robot crea una ruta hacia la dirección de entrega en su lugar.</p>

<p><a class="p_ident" id="p-AA5uJa4YUg" href="#p-AA5uJa4YUg" tabindex="-1" role="presentation"></a>Vamos a ver cómo lo hace.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-yYuNlgXLX9" href="#c-yYuNlgXLX9" tabindex="-1" role="presentation"></a>runRobotAnimation(VillageState.random(),
                  goalOrientedRobot, []);</pre>

<p><a class="p_ident" id="p-iSOwvxhYMe" href="#p-iSOwvxhYMe" tabindex="-1" role="presentation"></a>Este robot suele completar la entrega de 5 paquetes en unos 16 movimientos. Eso es ligeramente mejor que <code>routeRobot</code> pero definitivamente no óptimo.</p>

<h2><a class="h_ident" id="h-TcUD2vzyMe" href="#h-TcUD2vzyMe" tabindex="-1" role="presentation"></a>Ejercicios</h2><h3><a class="i_ident" id="i-JrK0ADjuHH" href="#i-JrK0ADjuHH" tabindex="-1" role="presentation"></a>Medición de un robot</h3>

<p><a class="p_ident" id="p-3o3bz0G4V0" href="#p-3o3bz0G4V0" tabindex="-1" role="presentation"></a>Es difícil comparar objetivamente robots simplemente dejándolos resolver unos cuantos escenarios. Tal vez un robot simplemente tuvo tareas más fáciles o del tipo en el que es bueno, mientras que el otro no.</p>

<p><a class="p_ident" id="p-n9CHE7/Lua" href="#p-n9CHE7/Lua" tabindex="-1" role="presentation"></a>Escribe una función <code>compareRobots</code> que tome dos robots (y su memoria inicial). Debería generar 100 tareas y dejar que cada uno de los robots resuelva cada una de estas tareas. Cuando termine, debería mostrar el número promedio de pasos que cada robot tomó por tarea.</p>

<p><a class="p_ident" id="p-O3TPJDzE3I" href="#p-O3TPJDzE3I" tabindex="-1" role="presentation"></a>Por cuestiones de equidad, asegúrate de dar cada tarea a ambos robots, en lugar de generar tareas diferentes por robot.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Pif/U+hwqO" href="#c-Pif/U+hwqO" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">compareRobots</span>(<span class="tok-definition">robot1</span>, <span class="tok-definition">memory1</span>, <span class="tok-definition">robot2</span>, <span class="tok-definition">memory2</span>) {
  <span class="tok-comment">// Tu código aquí</span>
}

compareRobots(routeRobot, [], goalOrientedRobot, []);</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-nI/WAc+Vc2" href="#p-nI/WAc+Vc2" tabindex="-1" role="presentation"></a>Tendrás que escribir una variante de la función <code>runRobot</code> que, en lugar de registrar los eventos en la consola, devuelva el número de pasos que el robot tomó para completar la tarea.</p>

<p><a class="p_ident" id="p-8LoGdkKyZL" href="#p-8LoGdkKyZL" tabindex="-1" role="presentation"></a>Tu función de medición puede entonces, en un bucle, generar nuevos estados y contar los pasos que cada uno de los robots da. Cuando haya generado suficientes mediciones, puede usar <code>console.log</code> para mostrar el promedio de cada robot, que es el número total de pasos dados dividido por el número de mediciones.</p>

</div></details>

<h3><a class="i_ident" id="i-VbBsQJ1lp6" href="#i-VbBsQJ1lp6" tabindex="-1" role="presentation"></a>Eficiencia del robot</h3>

<p><a class="p_ident" id="p-MjKPE+EDdI" href="#p-MjKPE+EDdI" tabindex="-1" role="presentation"></a>¿Puedes escribir un robot que termine la tarea de entrega más rápido que <code>goalOrientedRobot</code>? Si observas el comportamiento de ese robot, ¿qué cosas obviamente tontas hace? ¿Cómo podrían mejorarse?</p>

<p><a class="p_ident" id="p-qgKBJqRg+r" href="#p-qgKBJqRg+r" tabindex="-1" role="presentation"></a>Si resolviste el ejercicio anterior, es posible que quieras usar tu función <code>compareRobots</code> para verificar si mejoraste el robot.</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-kgk5f055Ej" href="#c-kgk5f055Ej" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu código aquí</span>

runRobotAnimation(VillageState.random(), yourRobot, memory);</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-2jYz1tpdHQ" href="#p-2jYz1tpdHQ" tabindex="-1" role="presentation"></a>La principal limitación de <code>goalOrientedRobot</code> es que solo considera un paquete a la vez. A menudo caminará de un lado a otro del pueblo porque el paquete que está mirando simplemente está en el otro lado del mapa, aunque haya otros mucho más cercanos.</p>

<p><a class="p_ident" id="p-+dCvWOpolq" href="#p-+dCvWOpolq" tabindex="-1" role="presentation"></a>Una posible solución sería calcular rutas para todos los paquetes y luego tomar la más corta. Se pueden obtener resultados aún mejores si hay múltiples rutas más cortas, prefiriendo aquellas que van a recoger un paquete en lugar de entregarlo.</p>

</div></details>

<h3><a class="i_ident" id="i-s+ntyh5xrm" href="#i-s+ntyh5xrm" tabindex="-1" role="presentation"></a>Grupo persistente</h3>

<p><a class="p_ident" id="p-2U3yafqdvH" href="#p-2U3yafqdvH" tabindex="-1" role="presentation"></a>La mayoría de las estructuras de datos proporcionadas en un entorno estándar de JavaScript no son muy adecuadas para un uso persistente. Los arrays tienen métodos <code>slice</code> y <code>concat</code>, que nos permiten crear fácilmente nuevos arrays sin dañar el antiguo. Pero, por ejemplo, <code>Set</code> no tiene métodos para crear un nuevo set con un elemento añadido o eliminado.</p>

<p><a class="p_ident" id="p-GJFOUv4fQp" href="#p-GJFOUv4fQp" tabindex="-1" role="presentation"></a>Escribe una nueva clase <code>PGroup</code>, similar a la clase <code>Group</code> de <a href="06_object.html#groups">Capítulo 6</a>, que almacena un conjunto de valores. Al igual que <code>Group</code>, tiene métodos <code>add</code>, <code>delete</code> y <code>has</code>.</p>

<p><a class="p_ident" id="p-CkpHJcowhH" href="#p-CkpHJcowhH" tabindex="-1" role="presentation"></a>Su método <code>add</code>, sin embargo, debería devolver una instancia de <code>PGroup</code> <em>nueva</em> con el miembro dado añadido y dejar la anterior sin cambios. De manera similar, <code>delete</code> crea una nueva instancia sin un miembro dado.</p>

<p><a class="p_ident" id="p-FVCes4vlh/" href="#p-FVCes4vlh/" tabindex="-1" role="presentation"></a>La clase debería funcionar para valores de cualquier tipo, no solo cadenas. No tiene que ser eficiente cuando se utiliza con grandes cantidades de valores.</p>

<p><a class="p_ident" id="p-oeaa05v28l" href="#p-oeaa05v28l" tabindex="-1" role="presentation"></a>El constructor no debería ser parte de la interfaz de la clase (aunque definitivamente querrás usarlo internamente). En su lugar, hay una instancia vacía, <code>PGroup.empty</code>, que se puede utilizar como valor inicial.</p>

<p><a class="p_ident" id="p-pV/91/QIt2" href="#p-pV/91/QIt2" tabindex="-1" role="presentation"></a>¿Por qué necesitas solamente un valor de <code>PGroup.empty</code>, en lugar de tener una función que cree un nuevo mapa vacío cada vez?</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-KN+ky/iMYB" href="#c-KN+ky/iMYB" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> PGroup {
  <span class="tok-comment">// Tu código aquí</span>
}

<span class="tok-keyword">let</span> <span class="tok-definition">a</span> = PGroup.empty.add(<span class="tok-string">"a"</span>);
<span class="tok-keyword">let</span> <span class="tok-definition">ab</span> = a.add(<span class="tok-string">"b"</span>);
<span class="tok-keyword">let</span> <span class="tok-definition">b</span> = ab.delete(<span class="tok-string">"a"</span>);

console.log(b.has(<span class="tok-string">"b"</span>));
<span class="tok-comment">// → true</span>
console.log(a.has(<span class="tok-string">"b"</span>));
<span class="tok-comment">// → false</span>
console.log(b.has(<span class="tok-string">"a"</span>));
<span class="tok-comment">// → false</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-wJCTKfvlWG" href="#p-wJCTKfvlWG" tabindex="-1" role="presentation"></a>La forma más conveniente de representar el conjunto de valores miembro sigue siendo como un array ya que los arrays son fáciles de copiar.</p>

<p><a class="p_ident" id="p-q2TqU7jyKB" href="#p-q2TqU7jyKB" tabindex="-1" role="presentation"></a>Cuando se agrega un valor al grupo, puedes crear un nuevo grupo con una copia del array original al que se le ha agregado el valor (por ejemplo, usando <code>concat</code>). Cuando se elimina un valor, lo filtras del array.</p>

<p><a class="p_ident" id="p-fVBH+nNpkA" href="#p-fVBH+nNpkA" tabindex="-1" role="presentation"></a>El constructor de la clase puede recibir dicho array como argumento y almacenarlo como la propiedad (única) de la instancia. Este array nunca se actualiza.</p>

<p><a class="p_ident" id="p-6iSMf9Tj0V" href="#p-6iSMf9Tj0V" tabindex="-1" role="presentation"></a>Para añadir la propiedad <code>empty</code> al constructor, puedes declararla como una propiedad estática.</p>

<p><a class="p_ident" id="p-no2z35iuBs" href="#p-no2z35iuBs" tabindex="-1" role="presentation"></a>Sólo necesitas una instancia de <code>empty</code> porque todos los grupos vacíos son iguales y las instancias de la clase no cambian. Puedes crear muchos grupos diferentes a partir de ese único grupo vacío sin afectarlo.</p>

</div></details><nav><a href="06_object.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="08_error.html" title="siguiente capítulo" aria-label="siguiente capítulo">▸</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>
</article>

<script src="js/ejs.js"></script>
</body></html>
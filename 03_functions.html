<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Funciones :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="css/ejs.css"><script>
      var page = {"type":"chapter","number":3}</script></head>

<body><article>
<nav><a href="02_program_structure.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="04_data.html" title="próximo capítulo" aria-label="próximo capítulo">▸</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>

<h1>Funciones</h1>

<blockquote>

<p><a class="p_ident" id="p-hkFlscMSbe" href="#p-hkFlscMSbe" tabindex="-1" role="presentation"></a>La gente piensa que la informática es el arte de los genios, pero la realidad actual es lo contrario, simplemente muchas personas haciendo cosas que se construyen unas sobre otras, como un muro de pequeñas piedras.</p>

<footer>Donald Knuth</footer>

</blockquote><figure class="chapter framed"><img src="images/chapter_picture_3.jpg" alt="Ilustración de hojas de helecho con una forma fractal, abejas en el fondo"></figure>

<p><a class="p_ident" id="p-n3O13DiqIs" href="#p-n3O13DiqIs" tabindex="-1" role="presentation"></a>Las funciones son una de las herramientas más centrales en la programación de JavaScript. El concepto de envolver un fragmento de programa en un valor tiene muchos usos. Nos proporciona una forma de estructurar programas más grandes, de reducir la repetición, de asociar nombres con subprogramas y de aislar estos subprogramas unos de otros.</p>

<p><a class="p_ident" id="p-R3iRdVuyh5" href="#p-R3iRdVuyh5" tabindex="-1" role="presentation"></a>La aplicación más obvia de las funciones es la de definir un nuevo vocabulario. Crear nuevas palabras en prosa suele ser de mal estilo, pero en la programación es indispensable.</p>

<p><a class="p_ident" id="p-ALZjlFHsJo" href="#p-ALZjlFHsJo" tabindex="-1" role="presentation"></a>Los hablantes de inglés adultos típicos tienen alrededor de 20,000 palabras en su vocabulario. Pocas lenguajes de programación vienen con 20,000 comandos incorporados. Y el vocabulario disponible tiende a estar más precisamente definido, y por lo tanto menos flexible, que en el lenguaje humano. Por lo tanto, <em>tenemos</em> que introducir nuevas palabras para evitar una verbosidad excesiva.</p>

<h2><a class="h_ident" id="h-tqLFw/oazr" href="#h-tqLFw/oazr" tabindex="-1" role="presentation"></a>Definir una función</h2>

<p><a class="p_ident" id="p-pBsAbh0THD" href="#p-pBsAbh0THD" tabindex="-1" role="presentation"></a>Una definición de función es un enlace regular donde el valor del enlace es una función. Por ejemplo, este código define que <code>square</code> se refiere a una función que produce el cuadrado de un número dado:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-JW7vLBZMWv" href="#c-JW7vLBZMWv" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">square</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">x</span>) {
  <span class="tok-keyword">return</span> x * x;
};console.log(square(<span class="tok-number">12</span>));
<span class="tok-comment">// → 144</span></pre>

<p><a class="p_ident" id="p-pEd/iApjCb" href="#p-pEd/iApjCb" tabindex="-1" role="presentation"></a>Se crea una función con una expresión que comienza con la palabra clave <code>function</code>. Las funciones tienen un conjunto de <em>parámetros</em> (en este caso, solo <code>x</code>) y un <em>cuerpo</em>, que contiene las instrucciones que se ejecutarán cuando se llame a la función. El cuerpo de una función creada de esta manera siempre debe estar envuelto entre llaves, incluso cuando consiste en una sola instrucción.</p>

<p><a class="p_ident" id="p-EGdFWqiSzT" href="#p-EGdFWqiSzT" tabindex="-1" role="presentation"></a>Una función puede tener múltiples parámetros o no tener parámetros en absoluto. En el siguiente ejemplo, <code>makeNoise</code> no lista nombres de parámetros, mientras que <code>roundTo</code> (que redondea <code>n</code> al múltiplo más cercano de <code>step</code>) lista dos:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-AraW0VhQRe" href="#c-AraW0VhQRe" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">makeNoise</span> = <span class="tok-keyword">function</span>() {
  console.log(<span class="tok-string">"¡Pling!"</span>);
};

makeNoise();
<span class="tok-comment">// → ¡Pling!</span>

<span class="tok-keyword">const</span> <span class="tok-definition">roundTo</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">n</span>, <span class="tok-definition">step</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">resto</span> = n % step;
  <span class="tok-keyword">return</span> n - resto + (resto &lt; step / <span class="tok-number">2</span> ? <span class="tok-number">0</span> : step);
};

console.log(roundTo(<span class="tok-number">23</span>, <span class="tok-number">10</span>));
<span class="tok-comment">// → 20</span></pre>

<p><a class="p_ident" id="p-Pd8LiiNn3y" href="#p-Pd8LiiNn3y" tabindex="-1" role="presentation"></a>Algunas funciones, como <code>roundTo</code> y <code>square</code>, producen un valor, y otras no, como <code>makeNoise</code>, cuyo único resultado es un efecto secundario. Una declaración <code>return</code> determina el valor que la función devuelve. Cuando el control llega a una declaración así, salta inmediatamente fuera de la función actual y le da el valor devuelto al código que llamó a la función. Una palabra clave <code>return</code> sin una expresión después de ella hará que la función devuelva <code>undefined</code>. Las funciones que no tienen una declaración <code>return</code> en absoluto, como <code>makeNoise</code>, también devuelven <code>undefined</code>.</p>

<p><a class="p_ident" id="p-tSSGXmQE8/" href="#p-tSSGXmQE8/" tabindex="-1" role="presentation"></a>Los parámetros de una función se comportan como enlaces regulares, pero sus valores iniciales son dados por el <em>llamante</em> de la función, no por el código en la propia función.</p><h2><a class="h_ident" id="h-XqQR5FlX+8" href="#h-XqQR5FlX+8" tabindex="-1" role="presentation"></a>Vínculos y alcances</h2>

<p><a class="p_ident" id="p-l52g4cvZTH" href="#p-l52g4cvZTH" tabindex="-1" role="presentation"></a>Cada vínculo tiene un <em>alcance</em>, que es la parte del programa en la que el vínculo es visible. Para los vínculos definidos fuera de cualquier función, bloque o módulo (ver <a href="10_modules.html">Capítulo 10</a>), el alcance es todo el programa; puedes hacer referencia a tales vínculos donde quieras. Estos se llaman <em>globales</em>.</p>

<p><a class="p_ident" id="p-xc/9V2q4+o" href="#p-xc/9V2q4+o" tabindex="-1" role="presentation"></a>Los vínculos creados para los parámetros de una función o declarados dentro de una función solo pueden ser referenciados en esa función, por lo que se conocen como vínculos <em>locales</em>. Cada vez que se llama a la función, se crean nuevas instancias de estos vínculos. Esto proporciona cierto aislamiento entre funciones; cada llamada a función actúa en su propio pequeño mundo (su entorno local) y a menudo se puede entender sin saber mucho sobre lo que está sucediendo en el entorno global.</p>

<p><a class="p_ident" id="p-F5R+6ujj0e" href="#p-F5R+6ujj0e" tabindex="-1" role="presentation"></a>Los vínculos declarados con <code>let</code> y <code>const</code> en realidad son locales al <em>bloque</em> en el que se declaran, por lo que si creas uno de esos dentro de un bucle, el código antes y después del bucle no puede "verlo". En JavaScript anterior a 2015, solo las funciones creaban nuevos ámbitos, por lo que los vínculos del estilo antiguo, creados con la palabra clave <code>var</code>, son visibles en toda la función en la que aparecen, o en todo el alcance global si no están dentro de una función.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-RnKIWzGFGD" href="#c-RnKIWzGFGD" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">x</span> = <span class="tok-number">10</span>;   <span class="tok-comment">// global</span>
<span class="tok-keyword">if</span> (true) {
  <span class="tok-keyword">let</span> <span class="tok-definition">y</span> = <span class="tok-number">20</span>; <span class="tok-comment">// local al bloque</span>
  <span class="tok-keyword">var</span> <span class="tok-definition">z</span> = <span class="tok-number">30</span>; <span class="tok-comment">// también global</span>
}</pre>

<p><a class="p_ident" id="p-f7Rf2Pe44s" href="#p-f7Rf2Pe44s" tabindex="-1" role="presentation"></a>Cada alcance puede "mirar hacia afuera" al alcance que lo rodea, por lo que <code>x</code> es visible dentro del bloque en el ejemplo. La excepción es cuando múltiples vínculos tienen el mismo nombre; en ese caso, el código solo puede ver el más interno. Por ejemplo, cuando el código dentro de la función <code>halve</code> hace referencia a <code>n</code>, está viendo su <em>propio</em> <code>n</code>, no el <code>n</code> global.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-5g6POeoiQv" href="#c-5g6POeoiQv" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">halve</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">return</span> n / <span class="tok-number">2</span>;
};<span class="tok-keyword">let</span> <span class="tok-definition">n</span> = <span class="tok-number">10</span>;
console.log(halve(<span class="tok-number">100</span>));
<span class="tok-comment">// → 50</span>
console.log(n);
<span class="tok-comment">// → 10</span></pre>

<h2 id="scoping"><a class="h_ident" id="h-c/Ms2Ed/N0" href="#h-c/Ms2Ed/N0" tabindex="-1" role="presentation"></a>Ámbito anidado</h2>

<p><a class="p_ident" id="p-tVHjFnvTdQ" href="#p-tVHjFnvTdQ" tabindex="-1" role="presentation"></a>JavaScript distingue no solo entre enlaces globales y locales. Los bloques y las funciones pueden crearse dentro de otros bloques y funciones, produciendo múltiples niveles de localidad.</p>

<p><a class="p_ident" id="p-XO/6uCTKGf" href="#p-XO/6uCTKGf" tabindex="-1" role="presentation"></a>Por ejemplo, esta función, la cual genera los ingredientes necesarios para hacer un lote de hummus, tiene otra función dentro de ella:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-cOSfyI1GsW" href="#c-cOSfyI1GsW" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">hummus</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">factor</span>) {
  <span class="tok-keyword">const</span> <span class="tok-definition">ingredient</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">amount</span>, <span class="tok-definition">unit</span>, <span class="tok-definition">name</span>) {
    <span class="tok-keyword">let</span> <span class="tok-definition">ingredientAmount</span> = amount * factor;
    <span class="tok-keyword">if</span> (ingredientAmount &gt; <span class="tok-number">1</span>) {
      unit += <span class="tok-string">"s"</span>;
    }
    console.log(<span class="tok-string2">`</span>${ingredientAmount}<span class="tok-string2"> </span>${unit}<span class="tok-string2"> </span>${name}<span class="tok-string2">`</span>);
  };
  ingredient(<span class="tok-number">1</span>, <span class="tok-string">"can"</span>, <span class="tok-string">"chickpeas"</span>);
  ingredient(<span class="tok-number">0.25</span>, <span class="tok-string">"cup"</span>, <span class="tok-string">"tahini"</span>);
  ingredient(<span class="tok-number">0.25</span>, <span class="tok-string">"cup"</span>, <span class="tok-string">"lemon juice"</span>);
  ingredient(<span class="tok-number">1</span>, <span class="tok-string">"clove"</span>, <span class="tok-string">"garlic"</span>);
  ingredient(<span class="tok-number">2</span>, <span class="tok-string">"tablespoon"</span>, <span class="tok-string">"olive oil"</span>);
  ingredient(<span class="tok-number">0.5</span>, <span class="tok-string">"teaspoon"</span>, <span class="tok-string">"cumin"</span>);
};</pre>

<p><a class="p_ident" id="p-UnbSAUz/Hi" href="#p-UnbSAUz/Hi" tabindex="-1" role="presentation"></a>El código dentro de la función <code>ingredient</code> puede ver el enlace <code>factor</code> de la función externa, pero sus enlaces locales, como <code>unit</code> o <code>ingredientAmount</code>, no son visibles en la función externa.</p><p><a class="p_ident" id="p-OFMMq4wzcg" href="#p-OFMMq4wzcg" tabindex="-1" role="presentation"></a>El conjunto de enlaces visibles dentro de un bloque está determinado por el lugar de ese bloque en el texto del programa. Cada ámbito local también puede ver todos los ámbitos locales que lo contienen, y todos los ámbitos pueden ver el ámbito global. Este enfoque de visibilidad de enlaces se llama <em>ámbito léxico</em>.</p>

<h2><a class="h_ident" id="h-y6WGSsYfER" href="#h-y6WGSsYfER" tabindex="-1" role="presentation"></a>Funciones como valores</h2>

<p><a class="p_ident" id="p-EP0+emaZPf" href="#p-EP0+emaZPf" tabindex="-1" role="presentation"></a>Un enlace de función generalmente simplemente actúa como un nombre para una parte específica del programa. Este enlace se define una vez y nunca se cambia. Esto hace fácil confundir la función con su nombre.</p>

<p><a class="p_ident" id="p-GmVFAjNN+C" href="#p-GmVFAjNN+C" tabindex="-1" role="presentation"></a>Pero los dos son diferentes. Un valor de función puede hacer todas las cosas que pueden hacer otros valores—puedes usarlo en expresiones arbitrarias, no solo llamarlo. Es posible almacenar un valor de función en un nuevo enlace, pasarlo como argumento a una función, y así sucesivamente. De manera similar, un enlace que contiene una función sigue siendo solo un enlace regular y puede, si no es constante, asignarse un nuevo valor, así:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-SZ7MmN0oGC" href="#c-SZ7MmN0oGC" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">lanzarMisiles</span> = <span class="tok-keyword">function</span>() {
  sistemaMisiles.lanzar(<span class="tok-string">"ahora"</span>);
};
<span class="tok-keyword">if</span> (modoSeguro) {
  lanzarMisiles = <span class="tok-keyword">function</span>() {<span class="tok-comment">/* no hacer nada */</span>};
}</pre>

<p><a class="p_ident" id="p-GCdjUSuSRH" href="#p-GCdjUSuSRH" tabindex="-1" role="presentation"></a>En <a href="05_higher_order.html">Capítulo 5</a>, discutiremos las cosas interesantes que podemos hacer pasando valores de función a otras funciones.</p>

<h2><a class="h_ident" id="h-H2WKvqbgVY" href="#h-H2WKvqbgVY" tabindex="-1" role="presentation"></a>Notación de declaración</h2>

<p><a class="p_ident" id="p-m4LM/GjFv8" href="#p-m4LM/GjFv8" tabindex="-1" role="presentation"></a>Existe una forma ligeramente más corta de crear un enlace de función. Cuando la palabra clave <code>function</code> se utiliza al inicio de una declaración, funciona de manera diferente:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-4uHhsg+h7S" href="#c-4uHhsg+h7S" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">cuadrado</span>(<span class="tok-definition">x</span>) {
  <span class="tok-keyword">return</span> x * x;
}</pre>

<p><a class="p_ident" id="p-duIlcl5Ee6" href="#p-duIlcl5Ee6" tabindex="-1" role="presentation"></a>Esta es una declaración de función. La declaración define el enlace <code>cuadrado</code> y lo apunta a la función dada. Es ligeramente más fácil de escribir y no requiere un punto y coma después de la función.</p><p><a class="p_ident" id="p-lCZw7EPvYa" href="#p-lCZw7EPvYa" tabindex="-1" role="presentation"></a>Hay una sutileza con esta forma de definición de función.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-41Tuq8c/gg" href="#c-41Tuq8c/gg" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"El futuro dice:"</span>, future());

<span class="tok-keyword">function</span> <span class="tok-definition">future</span>() {
  <span class="tok-keyword">return</span> <span class="tok-string">"Nunca tendrás autos voladores"</span>;
}</pre>

<p><a class="p_ident" id="p-OO22/MKYA8" href="#p-OO22/MKYA8" tabindex="-1" role="presentation"></a>El código anterior funciona, incluso cuando la función está definida <em>abajo</em> del código que la utiliza. Las declaraciones de funciones no forman parte del flujo regular de control de arriba hacia abajo. Conceptualmente, se mueven hasta arriba de su alcance y pueden ser utilizadas por todo el código en ese alcance. A veces es útil porque ofrece la libertad de ordenar el código de la manera que parezca más clara, sin preocuparse de tener que definir todas las funciones antes de ser utilizadas.</p>

<h2><a class="h_ident" id="h-/G0LSjQxoo" href="#h-/G0LSjQxoo" tabindex="-1" role="presentation"></a>Funciones flecha</h2>

<p><a class="p_ident" id="p-3pnFB5yqlb" href="#p-3pnFB5yqlb" tabindex="-1" role="presentation"></a>Hay una tercera notación para funciones, que se ve muy diferente de las otras. En lugar de la palabra clave <code>function</code>, utiliza una flecha (<code>=&gt;</code>) compuesta por un signo igual y un carácter mayor que (no confundir con el operador mayor o igual, que se escribe <code>&gt;=</code>):</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-5zMRAvLyub" href="#c-5zMRAvLyub" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">roundTo</span> = (<span class="tok-definition">n</span>, <span class="tok-definition">step</span>) =&gt; {
  <span class="tok-keyword">let</span> <span class="tok-definition">remainder</span> = n % step;
  <span class="tok-keyword">return</span> n - remainder + (remainder &lt; step / <span class="tok-number">2</span> ? <span class="tok-number">0</span> : step);
};</pre>

<p><a class="p_ident" id="p-spvzaI8qML" href="#p-spvzaI8qML" tabindex="-1" role="presentation"></a>La flecha viene <em>después</em> de la lista de parámetros y es seguida por el cuerpo de la función. Expresa algo como "este input (los parámetros) produce este resultado (el cuerpo)".</p>

<p><a class="p_ident" id="p-0sh2k0nMwP" href="#p-0sh2k0nMwP" tabindex="-1" role="presentation"></a>Cuando hay solo un nombre de parámetro, puedes omitir los paréntesis alrededor de la lista de parámetros. Si el cuerpo es una sola expresión, en lugar de un bloque entre llaves, esa expresión será devuelta por la función. Así, estas dos definiciones de la función <code>square</code> hacen lo mismo:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-VIDIsvgTjA" href="#c-VIDIsvgTjA" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">square1</span> = (<span class="tok-definition">x</span>) =&gt; { <span class="tok-keyword">return</span> x * x; };
<span class="tok-keyword">const</span> <span class="tok-definition">square2</span> = <span class="tok-definition">x</span> =&gt; x * x;</pre><p><a class="p_ident" id="p-fUkn+dhyOi" href="#p-fUkn+dhyOi" tabindex="-1" role="presentation"></a>Cuando una función flecha no tiene parámetros, su lista de parámetros es simplemente un conjunto vacío de paréntesis.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-VfJZoQnqTl" href="#c-VfJZoQnqTl" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">horn</span> = () =&gt; {
  console.log(<span class="tok-string">"Toot"</span>);
};</pre>

<p><a class="p_ident" id="p-oLNwgJWGUD" href="#p-oLNwgJWGUD" tabindex="-1" role="presentation"></a>No hay una razón profunda para tener tanto funciones flecha como expresiones <code>function</code> en el lenguaje. Aparte de un detalle menor, que discutiremos en el <a href="06_object.html">Capítulo 6</a>, hacen lo mismo. Las funciones flecha se añadieron en 2015, principalmente para permitir escribir expresiones de funciones pequeñas de una manera menos verbosa. Las usaremos a menudo en el <a href="05_higher_order.html">Capítulo 5</a>.</p>

<h2 id="stack"><a class="h_ident" id="h-D2Yui+mx6D" href="#h-D2Yui+mx6D" tabindex="-1" role="presentation"></a>La pila de llamadas</h2>

<p><a class="p_ident" id="p-quQ5qB7h0x" href="#p-quQ5qB7h0x" tabindex="-1" role="presentation"></a>La manera en que el control fluye a través de las funciones es algo complicada. Vamos a examinarlo más de cerca. Aquí hay un programa simple que realiza algunas llamadas de funciones:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-vruWG+bXUz" href="#c-vruWG+bXUz" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">saludar</span>(<span class="tok-definition">quien</span>) {
  console.log(<span class="tok-string">"¡Hola "</span> + quien);
}
saludar(<span class="tok-string">"Harry"</span>);
console.log(<span class="tok-string">"Adiós"</span>);</pre>

<p><a class="p_ident" id="p-XTLaqYuUGF" href="#p-XTLaqYuUGF" tabindex="-1" role="presentation"></a>Un recorrido de este programa sería más o menos así: la llamada a <code>saludar</code> hace que el control salte al inicio de esa función (línea 2). La función llama a <code>console.log</code>, que toma el control, hace su trabajo, y luego devuelve el control a la línea 2. Llega al final de la función <code>saludar</code>, por lo que retorna al lugar que la llamó, la línea 4. La línea siguiente llama a <code>console.log</code> nuevamente. Después de que retorna, el programa llega a su fin.</p>

<p><a class="p_ident" id="p-l2J0qZcbr2" href="#p-l2J0qZcbr2" tabindex="-1" role="presentation"></a>Podríamos mostrar el flujo de control esquemáticamente de esta forma:</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-sK38O0sD4t" href="#c-sK38O0sD4t" tabindex="-1" role="presentation"></a>no en función
   en saludar
        en console.log
   en saludar
no en función
   en console.log
no en función</pre>

<p><a class="p_ident" id="p-0AzS0ZGujS" href="#p-0AzS0ZGujS" tabindex="-1" role="presentation"></a>Debido a que una función tiene que regresar al lugar que la llamó cuando retorna, la computadora debe recordar el contexto desde el cual se realizó la llamada. En un caso, <code>console.log</code> tiene que regresar a la función <code>saludar</code> cuando haya terminado. En el otro caso, regresa al final del programa.</p><p><a class="p_ident" id="p-PCO8aj4Plj" href="#p-PCO8aj4Plj" tabindex="-1" role="presentation"></a>El lugar donde la computadora almacena este contexto es la <em>pila de llamadas</em>. Cada vez que se llama a una función, el contexto actual se almacena en la cima de esta pila. Cuando una función retorna, se elimina el contexto superior de la pila y se utiliza ese contexto para continuar la ejecución.</p>

<p><a class="p_ident" id="p-HxxwtLgAhP" href="#p-HxxwtLgAhP" tabindex="-1" role="presentation"></a>Almacenar esta pila requiere espacio en la memoria de la computadora. Cuando la pila crece demasiado, la computadora fallará con un mensaje como "sin espacio en la pila" o "demasiada recursividad". El siguiente código ilustra esto al hacerle a la computadora una pregunta muy difícil que causa un bucle infinito entre dos funciones. O más bien, <em>sería</em> infinito, si la computadora tuviera una pila infinita. Como es, nos quedaremos sin espacio, o "explotaremos la pila".</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-fZaWglCohr" href="#c-fZaWglCohr" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">chicken</span>() {
  <span class="tok-keyword">return</span> egg();
}
<span class="tok-keyword">function</span> <span class="tok-definition">egg</span>() {
  <span class="tok-keyword">return</span> chicken();
}
console.log(chicken() + <span class="tok-string">" came first."</span>);
<span class="tok-comment">// → ??</span></pre>

<h2><a class="h_ident" id="h-1pGtRjrCUp" href="#h-1pGtRjrCUp" tabindex="-1" role="presentation"></a>Argumentos Opcionales</h2>

<p><a class="p_ident" id="p-npZ63wzfMQ" href="#p-npZ63wzfMQ" tabindex="-1" role="presentation"></a>El siguiente código es permitido y se ejecuta sin problema alguno:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-IckdVt0tqA" href="#c-IckdVt0tqA" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">square</span>(<span class="tok-definition">x</span>) { <span class="tok-keyword">return</span> x * x; }
console.log(square(<span class="tok-number">4</span>, true, <span class="tok-string">"hedgehog"</span>));
<span class="tok-comment">// → 16</span></pre>

<p><a class="p_ident" id="p-JyyXKkZ6u6" href="#p-JyyXKkZ6u6" tabindex="-1" role="presentation"></a>Hemos definido <code>square</code> con solo un parámetro. Sin embargo, cuando lo llamamos con tres, el lenguaje no se queja. Ignora los argumentos extras y calcula el cuadrado del primero.</p>

<p><a class="p_ident" id="p-kzCivbonMM" href="#p-kzCivbonMM" tabindex="-1" role="presentation"></a>JavaScript es extremadamente tolerante en cuanto al número de argumentos que se pueden pasar a una función. Si pasas demasiados, los extras son ignorados. Si pasas muy pocos, los parámetros faltantes se les asigna el valor <code>undefined</code>.</p>

<p><a class="p_ident" id="p-L2hJ8C48nO" href="#p-L2hJ8C48nO" tabindex="-1" role="presentation"></a>La desventaja de esto es que es posible, incluso probable, que accidentalmente pases el número incorrecto de argumentos a las funciones. Y nadie te lo dirá. La ventaja es que puedes usar este comportamiento para permitir que una función sea llamada con diferentes números de argumentos. Por ejemplo, esta función <code>minus</code> intenta imitar al operador <code>-</code> al actuar en uno o dos argumentos:</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-8zGcY0SKdo" href="#c-8zGcY0SKdo" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">resta</span>(<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) {
  <span class="tok-keyword">if</span> (b === undefined) <span class="tok-keyword">return</span> -a;
  <span class="tok-keyword">else</span> <span class="tok-keyword">return</span> a - b;
}

console.log(resta(<span class="tok-number">10</span>));
<span class="tok-comment">// → -10</span>
console.log(resta(<span class="tok-number">10</span>, <span class="tok-number">5</span>));
<span class="tok-comment">// → 5</span></pre>

<p id="roundTo"><a class="p_ident" id="p-ft2GpnObRn" href="#p-ft2GpnObRn" tabindex="-1" role="presentation"></a>If you write an <code>=</code> operator after a parameter, followed by an expression, the value of that expression will replace the argument when it is not given. For example, this version of <code>roundTo</code> makes its second argument optional. If you don’t provide it or pass the value <code>undefined</code>, it will default to one:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-lf5l9+817Y" href="#c-lf5l9+817Y" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">redondearA</span>(<span class="tok-definition">n</span>, <span class="tok-definition">step</span> = <span class="tok-number">1</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">resto</span> = n % step;
  <span class="tok-keyword">return</span> n - resto + (resto &lt; step / <span class="tok-number">2</span> ? <span class="tok-number">0</span> : step);
};

console.log(redondearA(<span class="tok-number">4.5</span>));
<span class="tok-comment">// → 5</span>
console.log(redondearA(<span class="tok-number">4.5</span>, <span class="tok-number">2</span>));
<span class="tok-comment">// → 4</span></pre>

<p><a class="p_ident" id="p-Lhn3qRW+Ke" href="#p-Lhn3qRW+Ke" tabindex="-1" role="presentation"></a>The <a href="04_data.html#rest_parameters">next chapter</a> will introduce a way in which a function body can get at the whole list of arguments it was passed. This is helpful because it allows a function to accept any number of arguments. For example, <code>console.log</code> does this, outputting all the values it is given:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-RvkwVkcUZ7" href="#c-RvkwVkcUZ7" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">"C"</span>, <span class="tok-string">"O"</span>, <span class="tok-number">2</span>);
<span class="tok-comment">// → C O 2</span></pre>

<h2><a class="h_ident" id="h-hOd+yVxaku" href="#h-hOd+yVxaku" tabindex="-1" role="presentation"></a>Clausura</h2>

<p><a class="p_ident" id="p-Y88pfbKskW" href="#p-Y88pfbKskW" tabindex="-1" role="presentation"></a>The ability to treat functions as values, combined with the fact that local bindings are recreated every time a function is called, brings up an interesting question: what happens to local bindings when the function call that created them is no longer active?</p><p><a class="p_ident" id="p-f5+48lfrgA" href="#p-f5+48lfrgA" tabindex="-1" role="presentation"></a>El siguiente código muestra un ejemplo de esto. Define una función, <code>wrapValue</code>, que crea un enlace local. Luego devuelve una función que accede y retorna este enlace local:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-DF70h3opbx" href="#c-DF70h3opbx" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">wrapValue</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">local</span> = n;
  <span class="tok-keyword">return</span> () =&gt; local;
}

<span class="tok-keyword">let</span> <span class="tok-definition">wrap1</span> = wrapValue(<span class="tok-number">1</span>);
<span class="tok-keyword">let</span> <span class="tok-definition">wrap2</span> = wrapValue(<span class="tok-number">2</span>);
console.log(wrap1());
<span class="tok-comment">// → 1</span>
console.log(wrap2());
<span class="tok-comment">// → 2</span></pre>

<p><a class="p_ident" id="p-lgksIxSi8X" href="#p-lgksIxSi8X" tabindex="-1" role="presentation"></a>Esto está permitido y funciona como esperarías. Ambas instancias del enlace aún se pueden acceder. Esta situación es una buena demostración de que los enlaces locales se crean de nuevo para cada llamada, y las diferentes llamadas no afectan los enlaces locales entre sí.</p>

<p><a class="p_ident" id="p-egY8zzLCdU" href="#p-egY8zzLCdU" tabindex="-1" role="presentation"></a>Esta característica—poder hacer referencia a una instancia específica de un enlace local en un ámbito cercano—se llama <em>closure</em>. Una función que hace referencia a enlaces de ámbitos locales a su alrededor es llamada <em>un</em> closure. Este comportamiento no solo te libera de tener que preocuparte por la duración de los enlaces, sino que también hace posible usar valores de función de formas creativas.</p>

<p><a class="p_ident" id="p-YtnB1+ZhQb" href="#p-YtnB1+ZhQb" tabindex="-1" role="presentation"></a>Con un ligero cambio, podemos convertir el ejemplo anterior en una manera de crear funciones que multiplican por una cantidad arbitraria:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-iIlCVmvMSs" href="#c-iIlCVmvMSs" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">multiplier</span>(<span class="tok-definition">factor</span>) {
  <span class="tok-keyword">return</span> <span class="tok-definition">number</span> =&gt; number * factor;
}

<span class="tok-keyword">let</span> <span class="tok-definition">twice</span> = multiplier(<span class="tok-number">2</span>);
console.log(twice(<span class="tok-number">5</span>));
<span class="tok-comment">// → 10</span></pre>

<p><a class="p_ident" id="p-fVSBR58hMQ" href="#p-fVSBR58hMQ" tabindex="-1" role="presentation"></a>El enlace explícito <code>local</code> del ejemplo de <code>wrapValue</code> realmente no es necesario, ya que un parámetro en sí mismo es un enlace local.</p><p><a class="p_ident" id="p-cC96lnpdpR" href="#p-cC96lnpdpR" tabindex="-1" role="presentation"></a>Pensar en programas como este requiere cierta práctica. Un buen modelo mental es pensar en los valores de función como conteniendo tanto el código en su cuerpo como el entorno en el que fueron creados. Cuando se llaman, el cuerpo de la función ve el entorno en el que fue creado, no el entorno en el que es llamado.</p>

<p><a class="p_ident" id="p-OFeldBrm+O" href="#p-OFeldBrm+O" tabindex="-1" role="presentation"></a>En el ejemplo anterior, <code>multiplier</code> es llamado y crea un entorno en el que su parámetro <code>factor</code> está vinculado a 2. El valor de función que devuelve, que está almacenado en <code>twice</code>, recuerda este entorno para que cuando se llame, multiplique su argumento por 2.</p>

<h2><a class="h_ident" id="h-jxl1p970Fy" href="#h-jxl1p970Fy" tabindex="-1" role="presentation"></a>Recursividad</h2>

<p><a class="p_ident" id="p-3H3wGvSnF6" href="#p-3H3wGvSnF6" tabindex="-1" role="presentation"></a>Es perfectamente válido que una función se llame a sí misma, siempre y cuando no lo haga tan a menudo que desborde la pila. Una función que se llama a sí misma se denomina <em>recursiva</em>. La recursividad permite que algunas funciones se escriban de una manera diferente. Toma, por ejemplo, esta función <code>power</code>, que hace lo mismo que el operador <code>**</code> (exponenciación):</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-agdELfiRGm" href="#c-agdELfiRGm" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">potencia</span>(<span class="tok-definition">base</span>, <span class="tok-definition">exponente</span>) {
  <span class="tok-keyword">if</span> (exponente == <span class="tok-number">0</span>) {
    <span class="tok-keyword">return</span> <span class="tok-number">1</span>;
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">return</span> base * power(base, exponente - <span class="tok-number">1</span>);
  }
}

console.log(potencia(<span class="tok-number">2</span>, <span class="tok-number">3</span>));
<span class="tok-comment">// → 8</span></pre>

<p><a class="p_ident" id="p-/7VYZ2mLWF" href="#p-/7VYZ2mLWF" tabindex="-1" role="presentation"></a>Esto está bastante cerca de cómo los matemáticos definen la exponenciación y posiblemente describe el concepto de manera más clara que el bucle que usamos en <a href="02_program_structure.html">Capítulo 2</a>. La función se llama a sí misma múltiples veces con exponentes cada vez más pequeños para lograr la multiplicación repetida.</p>

<p><a class="p_ident" id="p-BCyx7v202p" href="#p-BCyx7v202p" tabindex="-1" role="presentation"></a>Esta implementación tiene un problema, sin embargo: en implementaciones de JavaScript típicas, es aproximadamente tres veces más lenta que una versión que usa un bucle <code>for</code>. Recorrer un bucle simple suele ser más barato que llamar a una función varias veces.</p>

<p><a class="p_ident" id="p-uMHI/JnzZZ" href="#p-uMHI/JnzZZ" tabindex="-1" role="presentation"></a>El dilema entre velocidad y elegancia es interesante. Se puede ver como una especie de continuo entre la amistosidad humana y la amistosidad de la máquina. Casi cualquier programa puede hacerse más rápido haciéndolo más grande y más complicado. El programador debe encontrar un equilibrio adecuado.</p><p><a class="p_ident" id="p-NQDJXQ8GE2" href="#p-NQDJXQ8GE2" tabindex="-1" role="presentation"></a>En el caso de la función <code>power</code>, una versión inelegante (con bucles) sigue siendo bastante simple y fácil de leer. No tiene mucho sentido reemplazarla con una función recursiva. Sin embargo, a menudo un programa trata conceptos tan complejos que renunciar a algo de eficiencia para hacer el programa más sencillo es útil.</p>

<p><a class="p_ident" id="p-ZB1IELNa2n" href="#p-ZB1IELNa2n" tabindex="-1" role="presentation"></a>Preocuparse por la eficiencia puede ser una distracción. Es otro factor que complica el diseño de programas y cuando ya estás haciendo algo que es difícil, preocuparte por eso extra puede ser paralizante.</p>

<p><a class="p_ident" id="p-yfFHmrF8OV" href="#p-yfFHmrF8OV" tabindex="-1" role="presentation"></a>Por lo tanto, generalmente deberías empezar escribiendo algo que sea correcto y fácil de entender. Si te preocupa que sea demasiado lento —lo cual generalmente no es el caso, ya que la mayoría del código simplemente no se ejecuta lo suficiente como para tomar una cantidad significativa de tiempo— puedes medir después y mejorarlo si es necesario.</p>

<p><a class="p_ident" id="p-m264IT3dFt" href="#p-m264IT3dFt" tabindex="-1" role="presentation"></a>La recursión no siempre es solo una alternativa ineficiente a los bucles. Algunos problemas realmente son más fáciles de resolver con recursión que con bucles. Con mayor frecuencia, estos son problemas que requieren explorar o procesar varias "ramas", cada una de las cuales podría ramificar nuevamente en aún más ramas.</p>

<p id="recursive_puzzle"><a class="p_ident" id="p-KNlnW1VpW2" href="#p-KNlnW1VpW2" tabindex="-1" role="presentation"></a>Considera este acertijo: comenzando desde el número 1 y repetidamente sumando 5 o multiplicando por 3, se puede producir un conjunto infinito de números. ¿Cómo escribirías una función que, dado un número, intente encontrar una secuencia de tales sumas y multiplicaciones que produzca ese número? Por ejemplo, el número 13 podría alcanzarse primero multiplicando por 3 y luego sumando 5 dos veces, mientras que el número 15 no se puede alcanzar en absoluto.</p>

<p><a class="p_ident" id="p-ca4W5yMbty" href="#p-ca4W5yMbty" tabindex="-1" role="presentation"></a>Aquí tienes una solución recursiva:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-wJPUK69VFE" href="#c-wJPUK69VFE" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">findSolution</span>(<span class="tok-definition">target</span>) {
  <span class="tok-keyword">function</span> <span class="tok-definition">find</span>(<span class="tok-definition">current</span>, <span class="tok-definition">history</span>) {
    <span class="tok-keyword">if</span> (current == target) {
      <span class="tok-keyword">return</span> history;
    } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (current &gt; target) {
      <span class="tok-keyword">return</span> <span class="tok-keyword">null</span>;
    } <span class="tok-keyword">else</span> {
      <span class="tok-keyword">return</span> find(current + <span class="tok-number">5</span>, <span class="tok-string2">`(</span>${history}<span class="tok-string2"> + 5)`</span>) ??
             find(current * <span class="tok-number">3</span>, <span class="tok-string2">`(</span>${history}<span class="tok-string2"> * 3)`</span>);
    }
  }
  <span class="tok-keyword">return</span> find(<span class="tok-number">1</span>, <span class="tok-string">"1"</span>);
}

console.log(findSolution(24));
<span class="tok-comment">// → (((1 * 3) + 5) * 3)</span></pre>

<p><a class="p_ident" id="p-fhaqzpNMMF" href="#p-fhaqzpNMMF" tabindex="-1" role="presentation"></a>Ten en cuenta que este programa no necesariamente encuentra la secuencia más <em>corta</em> de operaciones. Está satisfecho cuando encuentra cualquier secuencia.</p>

<p><a class="p_ident" id="p-s7tUKMITO0" href="#p-s7tUKMITO0" tabindex="-1" role="presentation"></a>No te preocupes si no ves cómo funciona este código de inmediato. Vamos a trabajar en ello, ya que es un buen ejercicio de pensamiento recursivo.</p>

<p><a class="p_ident" id="p-AlwczX9axy" href="#p-AlwczX9axy" tabindex="-1" role="presentation"></a>La función interna <code>find</code> realiza la recursión real. Toma dos argumentos: el número actual y una cadena que registra cómo llegamos a este número. Si encuentra una solución, devuelve una cadena que muestra cómo llegar al objetivo. Si no puede encontrar una solución comenzando desde este número, devuelve <code>null</code>.</p>

<p><a class="p_ident" id="p-2m+jfYF6Yv" href="#p-2m+jfYF6Yv" tabindex="-1" role="presentation"></a>Para hacer esto, la función realiza una de tres acciones. Si el número actual es el número objetivo, el historial actual es una forma de llegar a ese objetivo, por lo que se devuelve. Si el número actual es mayor que el objetivo, no tiene sentido explorar más esta rama porque tanto la suma como la multiplicación solo harán que el número sea mayor, por lo que devuelve <code>null</code>. Finalmente, si todavía estamos por debajo del número objetivo, la función prueba ambas rutas posibles que parten del número actual llamándose a sí misma dos veces, una vez para la suma y otra vez para la multiplicación. Si la primera llamada devuelve algo que no es <code>null</code>, se devuelve. De lo contrario, se devuelve la segunda llamada, independientemente de si produce una cadena o <code>null</code>.</p>

<p><a class="p_ident" id="p-QvX/6dUvST" href="#p-QvX/6dUvST" tabindex="-1" role="presentation"></a>Para entender mejor cómo esta función produce el efecto que buscamos, veamos todas las llamadas a <code>find</code> que se hacen al buscar una solución para el número 13:</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-KtyfRslIz2" href="#c-KtyfRslIz2" tabindex="-1" role="presentation"></a>find(1, "1")
  find(6, "(1 + 5)")
    find(11, "((1 + 5) + 5)")
      find(16, "(((1 + 5) + 5) + 5)")
        demasiado grande
      find(33, "(((1 + 5) + 5) * 3)")
        demasiado grande
    find(18, "((1 + 5) * 3)")
      demasiado grande
  find(3, "(1 * 3)")
    find(8, "((1 * 3) + 5)")
      find(13, "(((1 * 3) + 5) + 5)")
        encontrado!</pre>

<p><a class="p_ident" id="p-Akhgah+Kcu" href="#p-Akhgah+Kcu" tabindex="-1" role="presentation"></a>La indentación indica la profundidad de la pila de llamadas. La primera vez que se llama a <code>find</code>, la función comienza llamándose a sí misma para explorar la solución que comienza con <code>(1 + 5)</code>. Esa llamada recursiva explorará <em>cada</em> solución continuada que produzca un número menor o igual al número objetivo. Como no encuentra una que alcance el objetivo, devuelve <code>null</code> de nuevo a la primera llamada. Allí, el operador <code>??</code> hace que suceda la llamada que explora <code>(1 * 3)</code>. Esta búsqueda tiene más suerte; su primera llamada recursiva, a través de otra llamada recursiva, llega al número objetivo. Esa llamada más interna devuelve una cadena, y cada uno de los operadores <code>??</code> en las llamadas intermedias pasa esa cadena, devolviendo finalmente la solución. </p><h2><a class="h_ident" id="h-eVDWIAuyBK" href="#h-eVDWIAuyBK" tabindex="-1" role="presentation"></a>Funciones en crecimiento</h2>

<p><a class="p_ident" id="p-FDJnaYNBaa" href="#p-FDJnaYNBaa" tabindex="-1" role="presentation"></a>Hay dos maneras más o menos naturales de introducir funciones en los programas.</p>

<p><a class="p_ident" id="p-i9N3Ht388a" href="#p-i9N3Ht388a" tabindex="-1" role="presentation"></a>La primera ocurre cuando te encuentras escribiendo código similar varias veces. Preferirías no hacer eso, ya que tener más código significa más espacio para que se escondan errores y más material para que las personas que intentan entender el programa tengan que leer. Entonces tomas la funcionalidad repetida, le encuentras un buen nombre y la pones en una función.</p>

<p><a class="p_ident" id="p-HJxU0H/STP" href="#p-HJxU0H/STP" tabindex="-1" role="presentation"></a>La segunda manera es que te das cuenta de que necesitas alguna funcionalidad que aún no has escrito y que suena como si mereciera su propia función. Comienzas por nombrar la función, luego escribes su cuerpo. Incluso podrías comenzar a escribir código que use la función antes de definir la función en sí.</p>

<p><a class="p_ident" id="p-7YCpyNM9KP" href="#p-7YCpyNM9KP" tabindex="-1" role="presentation"></a>Qué difícil es encontrar un buen nombre para una función es una buena indicación de qué tan claro es el concepto que estás intentando encapsular. Vamos a través de un ejemplo.</p>

<p><a class="p_ident" id="p-NB82EwGY1X" href="#p-NB82EwGY1X" tabindex="-1" role="presentation"></a>Queremos escribir un programa que imprime dos números: el número de vacas y pollos en una granja, con las palabras <code>Cows</code> y <code>Chickens</code> después de ellos y ceros añadidos antes de ambos números para que siempre tengan tres dígitos de longitud:</p>

<pre class="snippet" data-language="null"><a class="c_ident" id="c-NGDR3Ll2Zn" href="#c-NGDR3Ll2Zn" tabindex="-1" role="presentation"></a>007 Cows
011 Chickens</pre>

<p><a class="p_ident" id="p-YmL+RnMybe" href="#p-YmL+RnMybe" tabindex="-1" role="presentation"></a>Esto pide una función con dos argumentos: el número de vacas y el número de pollos. ¡Comencemos a codificar!</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-RO+Vw8FSPK" href="#c-RO+Vw8FSPK" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">imprimirInventarioGranja</span>(<span class="tok-definition">vacas</span>, <span class="tok-definition">pollos</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">cadenaVaca</span> = String(vacas);
  <span class="tok-keyword">while</span> (cadenaVaca.length &lt; <span class="tok-number">3</span>) {
    cadenaVaca = <span class="tok-string">"0"</span> + cadenaVaca;
  }
  console.log(<span class="tok-string2">`</span>${cadenaVaca}<span class="tok-string2"> Vaca`</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">cadenaPollo</span> = String(pollos);
  <span class="tok-keyword">while</span> (cadenaPollo.length &lt; <span class="tok-number">3</span>) {
    cadenaPollo = <span class="tok-string">"0"</span> + cadenaPollo;
  }
  console.log(<span class="tok-string2">`</span>${cadenaPollo}<span class="tok-string2"> Pollos`</span>);
}
imprimirInventarioGranja(<span class="tok-number">7</span>, <span class="tok-number">11</span>);</pre><p><a class="p_ident" id="p-YLs54aH93M" href="#p-YLs54aH93M" tabindex="-1" role="presentation"></a>Escribir <code>.length</code> después de una expresión de cadena nos dará la longitud de esa cadena. Por lo tanto, los bucles <code>while</code> siguen agregando ceros al principio de las cadenas numéricas hasta que tengan al menos tres caracteres de longitud.</p>

<p><a class="p_ident" id="p-hlBZoLuLCG" href="#p-hlBZoLuLCG" tabindex="-1" role="presentation"></a>¡Misión cumplida! Pero justo cuando estamos a punto de enviarle al granjero el código (junto con una cuantiosa factura), ella nos llama y nos dice que también ha comenzado a criar cerdos, ¿podríamos por favor extender el software para imprimir también cerdos?</p>

<p><a class="p_ident" id="p-h9O1PaViIa" href="#p-h9O1PaViIa" tabindex="-1" role="presentation"></a>Claro que podemos. Pero justo cuando estamos en proceso de copiar y pegar esas cuatro líneas una vez más, paramos y reconsideramos. Tiene que haber una mejor manera. Aquí está un primer intento:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-RHETS/If7p" href="#c-RHETS/If7p" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">printZeroPaddedWithLabel</span>(<span class="tok-definition">numero</span>, <span class="tok-definition">etiqueta</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">cadenaNumero</span> = String(numero);
  <span class="tok-keyword">while</span> (cadenaNumero.length &lt; <span class="tok-number">3</span>) {
    cadenaNumero = <span class="tok-string">"0"</span> + cadenaNumero;
  }
  console.log(<span class="tok-string2">`</span>${cadenaNumero}<span class="tok-string2"> </span>${etiqueta}<span class="tok-string2">`</span>);
}

<span class="tok-keyword">function</span> <span class="tok-definition">printFarmInventory</span>(<span class="tok-definition">vacas</span>, <span class="tok-definition">pollo</span>, <span class="tok-definition">cerdos</span>) {
  printZeroPaddedWithLabel(vacas, <span class="tok-string">"Vacas"</span>);
  printZeroPaddedWithLabel(pollo, <span class="tok-string">"Pollos"</span>);
  printZeroPaddedWithLabel(cerdos, <span class="tok-string">"Cerdos"</span>);
}

printFarmInventory(<span class="tok-number">7</span>, <span class="tok-number">11</span>, <span class="tok-number">3</span>);</pre>

<p><a class="p_ident" id="p-6/4BxnwWvK" href="#p-6/4BxnwWvK" tabindex="-1" role="presentation"></a>¡Funciona! Pero ese nombre, <code>printZeroPaddedWithLabel</code>, es un poco incómodo. Mezcla tres cosas: imprimir, rellenar con ceros y agregar una etiqueta, en una sola función.</p>

<p><a class="p_ident" id="p-/zEyox400N" href="#p-/zEyox400N" tabindex="-1" role="presentation"></a>En lugar de sacar la parte repetida de nuestro programa completamente, intentemos seleccionar un único <em>concepto</em>:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-L3v+xO5gBH" href="#c-L3v+xO5gBH" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">zeroPad</span>(<span class="tok-definition">numero</span>, <span class="tok-definition">ancho</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">cadena</span> = String(numero);
  <span class="tok-keyword">while</span> (cadena.length &lt; ancho) {
    cadena = <span class="tok-string">"0"</span> + cadena;
  }
  <span class="tok-keyword">return</span> cadena;
}</pre><pre><code><span class="tok-keyword">function</span> <span class="tok-definition">printFarmInventory</span>(<span class="tok-definition">vacas</span>, <span class="tok-definition">pollo</span>, <span class="tok-definition">cerdos</span>) {
  console.log(<span class="tok-string2">`</span>${zeroPad(vacas, <span class="tok-number">3</span>)}<span class="tok-string2"> Vacas`</span>);
  console.log(<span class="tok-string2">`</span>${zeroPad(pollo, <span class="tok-number">3</span>)}<span class="tok-string2"> Pollos`</span>);
  console.log(<span class="tok-string2">`</span>${zeroPad(cerdos, <span class="tok-number">3</span>)}<span class="tok-string2"> Cerdos`</span>);
}

printFarmInventory(<span class="tok-number">7</span>, <span class="tok-number">16</span>, <span class="tok-number">3</span>);</code></pre>

<p><a class="p_ident" id="p-GAKg8ZzVbj" href="#p-GAKg8ZzVbj" tabindex="-1" role="presentation"></a>Una función con un nombre claro y obvio como <code>zeroPad</code> hace que sea más fácil para alguien que lee el código entender qué hace. Tal función también es útil en más situaciones que solo este programa específico. Por ejemplo, podrías usarla para ayudar a imprimir tablas de números alineados de manera ordenada.</p>

<p><a class="p_ident" id="p-JtW9SrsIA6" href="#p-JtW9SrsIA6" tabindex="-1" role="presentation"></a>¿Qué tan inteligente y versátil <em>debería</em> ser nuestra función? Podríamos escribir cualquier cosa, desde una función terriblemente simple que solo puede rellenar un número para que tenga tres caracteres de ancho, hasta un sistema de formateo de números generalizado complicado que maneje números fraccionarios, números negativos, alineación de puntos decimales, relleno con diferentes caracteres, y más.</p>

<p><a class="p_ident" id="p-9fiX2KwoZe" href="#p-9fiX2KwoZe" tabindex="-1" role="presentation"></a>Un principio útil es abstenerse de agregar ingenio a menos que estés absolutamente seguro de que lo vas a necesitar. Puede ser tentador escribir "marcos" generales para cada parte de la funcionalidad con la que te encuentres. Resiste ese impulso. No terminarás haciendo ningún trabajo real, estarás demasiado ocupado escribiendo código que nunca usarás.</p>

<h2 id="pure"><a class="h_ident" id="h-EdyBGBF6y/" href="#h-EdyBGBF6y/" tabindex="-1" role="presentation"></a>Funciones y efectos secundarios</h2>

<p><a class="p_ident" id="p-Yv2DEaMWee" href="#p-Yv2DEaMWee" tabindex="-1" role="presentation"></a>Las funciones pueden dividirse aproximadamente en aquellas que se llaman por sus efectos secundarios y aquellas que se llaman por su valor de retorno (aunque también es posible tener efectos secundarios y devolver un valor).</p>

<p><a class="p_ident" id="p-NoFe+XFM0N" href="#p-NoFe+XFM0N" tabindex="-1" role="presentation"></a>La primera función auxiliar en el ejemplo de la granja, <code>printZeroPaddedWithLabel</code>, se llama por su efecto secundario: imprime una línea. La segunda versión, <code>zeroPad</code>, se llama por su valor de retorno. No es casualidad que la segunda sea útil en más situaciones que la primera. Las funciones que crean valores son más fáciles de combinar de nuevas formas que las funciones que realizan directamente efectos secundarios.</p><p><a class="p_ident" id="p-f/i3GqalXG" href="#p-f/i3GqalXG" tabindex="-1" role="presentation"></a>Una función <em>pura</em> es un tipo específico de función que produce un valor y que no solo no tiene efectos secundarios, sino que tampoco depende de efectos secundarios de otro código, por ejemplo, no lee enlaces globales cuyo valor pueda cambiar. Una función pura tiene la agradable propiedad de que, cuando se llama con los mismos argumentos, siempre produce el mismo valor (y no hace nada más). Una llamada a dicha función puede ser sustituida por su valor de retorno sin cambiar el significado del código. Cuando no estás seguro de que una función pura esté funcionando correctamente, puedes probarla simplemente llamándola y saber que si funciona en ese contexto, funcionará en cualquier otro contexto. Las funciones no puras tienden a requerir más andamiaje para probarlas.</p>

<p><a class="p_ident" id="p-mH0m17T3hr" href="#p-mH0m17T3hr" tabindex="-1" role="presentation"></a>Aun así, no hay necesidad de sentirse mal al escribir funciones que no son puras. Los efectos secundarios a menudo son útiles. No hay forma de escribir una versión pura de <code>console.log</code>, por ejemplo, y es útil tener <code>console.log</code>. Algunas operaciones también son más fáciles de expresar de manera eficiente cuando usamos efectos secundarios.</p>

<h2><a class="h_ident" id="h-ErccPg/l98" href="#h-ErccPg/l98" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-LLhiHGkZNx" href="#p-LLhiHGkZNx" tabindex="-1" role="presentation"></a>Este capítulo te enseñó cómo escribir tus propias funciones. La palabra clave <code>function</code>, cuando se usa como expresión, puede crear un valor de función. Cuando se usa como una declaración, se puede utilizar para declarar un enlace y darle una función como valor. Las funciones de flecha son otra forma de crear funciones.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-x2/+thzlca" href="#c-x2/+thzlca" tabindex="-1" role="presentation"></a><span class="tok-comment">// Define f to hold a function value</span>
<span class="tok-keyword">const</span> <span class="tok-definition">f</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">a</span>) {
  console.log(a + <span class="tok-number">2</span>);
};

<span class="tok-comment">// Declare g to be a function</span>
<span class="tok-keyword">function</span> <span class="tok-definition">g</span>(<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) {
  <span class="tok-keyword">return</span> a * b * <span class="tok-number">3.5</span>;
}

<span class="tok-comment">// A less verbose function value</span>
<span class="tok-keyword">let</span> <span class="tok-definition">h</span> = <span class="tok-definition">a</span> =&gt; a % <span class="tok-number">3</span>;</pre>

<p><a class="p_ident" id="p-qDQhxlvrQv" href="#p-qDQhxlvrQv" tabindex="-1" role="presentation"></a>Una parte clave para entender las funciones es comprender los ámbitos. Cada bloque crea un nuevo ámbito. Los parámetros y enlaces declarados en un ámbito dado son locales y no son visibles desde fuera. Los enlaces declarados con <code>var</code> se comportan de manera diferente, terminan en el ámbito de la función más cercana o en el ámbito global.</p><p><a class="p_ident" id="p-HR2xC/gcHR" href="#p-HR2xC/gcHR" tabindex="-1" role="presentation"></a>Separar las tareas que realiza tu programa en diferentes funciones es útil. No tendrás que repetirte tanto, y las funciones pueden ayudar a organizar un programa agrupando el código en piezas que hacen cosas específicas.</p>

<h2><a class="h_ident" id="h-TcUD2vzyMe" href="#h-TcUD2vzyMe" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-XTmO7z7MPq" href="#i-XTmO7z7MPq" tabindex="-1" role="presentation"></a>Mínimo</h3>

<p><a class="p_ident" id="p-aW/Uoj4mDd" href="#p-aW/Uoj4mDd" tabindex="-1" role="presentation"></a>El <a href="02_program_structure.html#return_values">capítulo anterior</a> introdujo la función estándar <code>Math.min</code> que devuelve su argumento más pequeño. Ahora podemos escribir una función como esa nosotros mismos. Define la función <code>min</code> que toma dos argumentos y devuelve su mínimo.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-zoK4eQ6E3E" href="#c-zoK4eQ6E3E" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu código va aquí.</span>

console.log(min(<span class="tok-number">0</span>, <span class="tok-number">10</span>));
<span class="tok-comment">// → 0</span>
console.log(min(<span class="tok-number">0</span>, -<span class="tok-number">10</span>));
<span class="tok-comment">// → -10</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-jbGq7vKDsS" href="#p-jbGq7vKDsS" tabindex="-1" role="presentation"></a>Si tienes dificultades para colocar llaves y paréntesis en el lugar correcto para obtener una definición de función válida, comienza copiando uno de los ejemplos de este capítulo y modifícalo.</p>

<p><a class="p_ident" id="p-V+p4wKaMty" href="#p-V+p4wKaMty" tabindex="-1" role="presentation"></a>Una función puede contener múltiples declaraciones con <code>return</code>.</p>

</div></details>

<h3><a class="i_ident" id="i-jxl1p970Fy" href="#i-jxl1p970Fy" tabindex="-1" role="presentation"></a>Recursión</h3>

<p><a class="p_ident" id="p-jU1r1XPp0G" href="#p-jU1r1XPp0G" tabindex="-1" role="presentation"></a>Hemos visto que podemos usar <code>%</code> (el operador de resto) para verificar si un número es par o impar, al usar <code>% 2</code> para ver si es divisible por dos. Aquí hay otra forma de definir si un número entero positivo es par o impar:</p>

<ul>

<li>

<p><a class="p_ident" id="p-lCOBPDdrEk" href="#p-lCOBPDdrEk" tabindex="-1" role="presentation"></a>El cero es par.</p></li>

<li>

<p><a class="p_ident" id="p-fWhtKbL+Su" href="#p-fWhtKbL+Su" tabindex="-1" role="presentation"></a>El uno es impar.</p></li>

<li>

<p><a class="p_ident" id="p-1dwrqpocrW" href="#p-1dwrqpocrW" tabindex="-1" role="presentation"></a>Para cualquier otro número <em>N</em>, su paridad es la misma que <em>N</em> - 2.</p></li></ul>

<p><a class="p_ident" id="p-zxMN8E0WOI" href="#p-zxMN8E0WOI" tabindex="-1" role="presentation"></a>Define una función recursiva <code>isEven</code> que corresponda a esta descripción. La función debería aceptar un único parámetro (un número entero positivo) y devolver un booleano.</p><p><a class="p_ident" id="p-0+fMeza2x5" href="#p-0+fMeza2x5" tabindex="-1" role="presentation"></a>Probar con 50 y 75. Ver cómo se comporta con -1. ¿Por qué? ¿Puedes pensar en una forma de solucionar esto?</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-7Dyz/3MMqh" href="#c-7Dyz/3MMqh" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu código aquí.</span>

console.log(isEven(<span class="tok-number">50</span>));
<span class="tok-comment">// → true</span>
console.log(isEven(<span class="tok-number">75</span>));
<span class="tok-comment">// → false</span>
console.log(isEven(-<span class="tok-number">1</span>));
<span class="tok-comment">// → ??</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-4Nl1/L8dAN" href="#p-4Nl1/L8dAN" tabindex="-1" role="presentation"></a>Es probable que tu función se parezca en cierta medida a la función interna <code>find</code> en el ejemplo recursivo de <code>findSolution</code> en este <a href="03_functions.html#recursive_puzzle">capítulo</a>, con una cadena de <code>if</code>/<code>else if</code>/<code>else</code> que prueba cuál de los tres casos se aplica. El <code>else</code> final, correspondiente al tercer caso, realiza la llamada recursiva. Cada una de las ramas debe contener una declaración <code>return</code> o de alguna otra manera garantizar que se devuelva un valor específico.</p>

<p><a class="p_ident" id="p-QIaN+xYJ+M" href="#p-QIaN+xYJ+M" tabindex="-1" role="presentation"></a>Cuando se le da un número negativo, la función se llamará recursivamente una y otra vez, pasándose a sí misma un número cada vez más negativo, alejándose así cada vez más de devolver un resultado. Eventualmente, se quedará sin espacio en la pila y abortará.</p>

</div></details>

<h3><a class="i_ident" id="i-3rsiDgC2do" href="#i-3rsiDgC2do" tabindex="-1" role="presentation"></a>Contando letras B</h3>

<p><a class="p_ident" id="p-8y74cOkS91" href="#p-8y74cOkS91" tabindex="-1" role="presentation"></a>Puedes obtener el <em>ésimo</em> carácter, o letra, de un string escribiendo <code>[N]</code> después del string (por ejemplo, <code>string[2]</code>). El valor resultante será un string que contiene solo un carácter (por ejemplo, <code>"b"</code>). El primer carácter tiene la posición 0, lo que hace que el último se encuentre en la posición <code>string.<wbr>length - 1</code>. En otras palabras, un string de dos caracteres tiene longitud 2, y sus caracteres tienen posiciones 0 y 1.</p>

<p><a class="p_ident" id="p-3+wBcfMbYR" href="#p-3+wBcfMbYR" tabindex="-1" role="presentation"></a>Escribe una función <code>countBs</code> que tome un string como su único argumento y devuelva un número que indique cuántos caracteres B en mayúsculas hay en el string.</p>

<p><a class="p_ident" id="p-WdA52+sgwM" href="#p-WdA52+sgwM" tabindex="-1" role="presentation"></a>Luego, escribe una función llamada <code>countChar</code> que se comporte como <code>countBs</code>, excepto que toma un segundo argumento que indica el carácter que se debe contar (en lugar de contar solo los caracteres B en mayúsculas). Reescribe <code>countBs</code> para usar esta nueva función.</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-fTMxwrQQBV" href="#c-fTMxwrQQBV" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu código aquí.</span>

console.log(countBs(<span class="tok-string">"BOB"</span>));
<span class="tok-comment">// → 2</span>
console.log(countChar(<span class="tok-string">"kakkerlak"</span>, <span class="tok-string">"k"</span>));
<span class="tok-comment">// → 4</span></pre>

<details class="solution"><summary>Display hints...</summary><div class="solution-text">

<p><a class="p_ident" id="p-iXtbGSBd1r" href="#p-iXtbGSBd1r" tabindex="-1" role="presentation"></a> Tu función necesitará un bucle que examine cada carácter en la cadena. Puede ejecutar un índice desde cero hasta uno menos de su longitud (<code>&lt; string.<wbr>length</code>). Si el carácter en la posición actual es igual al que la función está buscando, se suma 1 a una variable de contador. Una vez que el bucle haya terminado, se puede devolver el contador.</p>

<p><a class="p_ident" id="p-h0vFGXYL6A" href="#p-h0vFGXYL6A" tabindex="-1" role="presentation"></a> Asegúrate de hacer que todas las asignaciones utilizadas en la función sean <em>locales</em> a la función declarándolas correctamente con la palabra clave <code>let</code> o <code>const</code>.</p>

</div></details><nav><a href="02_program_structure.html" title="capítulo anterior" aria-label="capítulo anterior">◂</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">●</a>&nbsp;<a href="04_data.html" title="próximo capítulo" aria-label="próximo capítulo">▸</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>
</article>

<script src="js/ejs.js"></script>
</body></html>